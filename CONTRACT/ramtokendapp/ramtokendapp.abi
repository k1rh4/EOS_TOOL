{
  "version": "eosio::abi/1.0",
  "types": [{
      "new_type_name": "order_id_t",
      "type": "uint64"
    },{
      "new_type_name": "ttl_t",
      "type": "int32"
    },{
      "new_type_name": "symbol_name",
      "type": "uint64"
    }
  ],
  "structs": [{
      "name": "index_queue_element",
      "base": "",
      "fields": [{
          "name": "seq",
          "type": "uint64"
        }
      ]
    },{
      "name": "order_t",
      "base": "index_queue_element",
      "fields": [{
          "name": "id",
          "type": "order_id_t"
        },{
          "name": "value",
          "type": "asset"
        },{
          "name": "trader",
          "type": "name"
        },{
          "name": "expiration_time",
          "type": "uint32"
        },{
          "name": "convert_on_expire",
          "type": "bool"
        }
      ]
    },{
      "name": "buy",
      "base": "",
      "fields": [{
          "name": "buyer",
          "type": "name"
        },{
          "name": "value",
          "type": "asset"
        },{
          "name": "ttl",
          "type": "ttl_t"
        },{
          "name": "force_buy",
          "type": "bool"
        }
      ]
    },{
      "name": "sell",
      "base": "",
      "fields": [{
          "name": "seller",
          "type": "name"
        },{
          "name": "value",
          "type": "asset"
        },{
          "name": "ttl",
          "type": "ttl_t"
        },{
          "name": "force_sell",
          "type": "bool"
        }
      ]
    },{
      "name": "cancel",
      "base": "",
      "fields": [{
          "name": "order_id",
          "type": "order_id_t"
        }
      ]
    },{
      "name": "cancelbytxid",
      "base": "",
      "fields": [{
          "name": "txid",
          "type": "checksum256"
        }
      ]
    },{
      "name": "init",
      "base": "",
      "fields": [{
          "name": "fee_recipient",
          "type": "name"
        }
      ]
    },{
      "name": "setfeerecip",
      "base": "",
      "fields": [{
          "name": "account",
          "type": "name"
        }
      ]
    },{
      "name": "setproxy",
      "base": "",
      "fields": [{
          "name": "proxy",
          "type": "name"
        }
      ]
    },{
      "name": "start",
      "base": "",
      "fields": []
    },{
      "name": "stop",
      "base": "",
      "fields": []
    },{
      "name": "clrallorders",
      "base": "",
      "fields": [{
          "name": "reason",
          "type": "string"
        }
      ]
    },{
      "name": "symbol_type",
      "base": "",
      "fields": [{
          "name": "value",
          "type": "symbol_name"
        }
      ]
    },{
      "name": "clrorders",
      "base": "",
      "fields": [{
          "name": "sym",
          "type": "symbol_type"
        },{
          "name": "reason",
          "type": "string"
        }
      ]
    },{
      "name": "state_t",
      "base": "",
      "fields": [{
          "name": "fee_account",
          "type": "name"
        },{
          "name": "transfer_proxy",
          "type": "name"
        },{
          "name": "exchange_running",
          "type": "bool"
        }
      ]
    }
  ],
  "actions": [{
      "name": "buy",
      "type": "buy",
      "ricardian_contract": ""
    },{
      "name": "sell",
      "type": "sell",
      "ricardian_contract": ""
    },{
      "name": "cancel",
      "type": "cancel",
      "ricardian_contract": ""
    },{
      "name": "cancelbytxid",
      "type": "cancelbytxid",
      "ricardian_contract": ""
    },{
      "name": "init",
      "type": "init",
      "ricardian_contract": ""
    },{
      "name": "setfeerecip",
      "type": "setfeerecip",
      "ricardian_contract": ""
    },{
      "name": "setproxy",
      "type": "setproxy",
      "ricardian_contract": ""
    },{
      "name": "start",
      "type": "start",
      "ricardian_contract": ""
    },{
      "name": "stop",
      "type": "stop",
      "ricardian_contract": ""
    },{
      "name": "clrallorders",
      "type": "clrallorders",
      "ricardian_contract": ""
    },{
      "name": "clrorders",
      "type": "clrorders",
      "ricardian_contract": ""
    }
  ],
  "tables": [{
      "name": "orderbook",
      "index_type": "i64",
      "key_names": [
        "id"
      ],
      "key_types": [
        "order_id_t"
      ],
      "type": "order_t"
    },{
      "name": "state",
      "index_type": "i64",
      "key_names": [
        "fee_account"
      ],
      "key_types": [
        "name"
      ],
      "type": "state_t"
    }
  ],
  "ricardian_clauses": [{
      "id": "Warranty",
      "body": "WARRANTY. At no time shall elected block producers freeze or modify this contract if operating as intended.\nRAM exchange dapp developers are not liable for damages caused by the bugs or unintended behaviour. All Parties including the invoker of the contract action, are responsible for auditing the exchange's source code and agreeing to this Ricardian contract before use."
    },{
      "id": "Definition",
      "body": "DEFINITION. RAM exchange is an open-source smart contract that buys/sells RAM bytes from the system contract and issues/burns fully backed RAM token. It also allows users to exchange RAM token for EOS and vice verse. 1 byte of RAM = 1 RAM token.\nRAM token allows wallet and exchanges to fully leverage their existing token infrastructure."
    },{
      "id": "Intent of the Code",
      "body": "INTENT OF THE CODE. The exchange's contract code should never allow *ramtokendapp* contract to issue or contain more RAM tokens than the amount of RAM bytes bought to peg the issued RAM tokens.\nIf a bug in the contract allowed this to occur the arbitration forum or block-producers should restore the peg within their ability.\nIf the peg is impossible to restore due to the inability to recover the funds, the socialised losses would be applied to all accounts (same %) and all of the contract future fees would be used exclusively to make all of the user accounts whole again."
    },{
      "id": "Amendment",
      "body": "AMENDMENT. The contract might be modified or amended with bug fixes or new features. RAM exchange and RAM token transfers might be frozen during the time of fixing the bugs, restoring the peg or during the maintenance and upgrade.\nIn no way would the contract's owner account be used to access or modify users balance that were not a result of a bug or contract's unexpected behaviour.\nIf that still happens, the arbitration forum or block-producers should restore the contract's previous state within their ability."
    },{
      "id": "Code Repository",
      "body": "CODE REPOSITORY. https://github.com/ChainRift/RAMtoken"
    }
  ],
  "error_messages": [],
  "abi_extensions": [],
  "variants": []
}