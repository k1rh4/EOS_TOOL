(data (i32.const 16908) "bigwinshare1\00malloc_from_freed was designed to only be called after _heap was completely allocated\00")
(data (i32.const 17007) "imeoswinner1\00")
(data (i32.const 17020) "invalid symbol name\00")
(data (i32.const 17040) "invalid supply\00")
(data (i32.const 17055) "max-supply must be positive\00")
(data (i32.const 17083) " add\00")
(data (i32.const 17088) " change\00")
(data (i32.const 17096) "memo has more than 256 bytes\00")
(data (i32.const 17125) "token with symbol does not exist, create token before issue\00")
(data (i32.const 17185) "invalid quantity\00")
(data (i32.const 17202) "must issue positive quantity\00")
(data (i32.const 17231) "symbol precision mismatch\00")
(data (i32.const 17257) "quantity exceeds available supply\00")
(data (i32.const 17291) "active\00")
(data (i32.const 17298) "token with symbol does not exist, create token before burn\00")
(data (i32.const 17357) "must burn positive quantity\00")
(data (i32.const 17385) "no balance object found\00")
(data (i32.const 17409) "overdrawn balance\00")
(data (i32.const 17427) "cannot transfer to self\00")
(data (i32.const 17451) "to account does not exist\00")
(data (i32.const 17477) "unable to find key\00")
(data (i32.const 17496) "must transfer positive quantity\00")
(data (i32.const 17528) "EOS\00")
(data (i32.const 17532) "BIT\00")
(data (i32.const 17536) "sym_name:\00")
(data (i32.const 17546) " asset\00")
(data (i32.const 17553) "lock\00")
(data (i32.const 17558) "no accounts object found\00")
(data (i32.const 17583) "finish lock\00")
(data (i32.const 17595) " finish prelock\00")
(data (i32.const 17611) "runstake\00")
(data (i32.const 17620) " finish defer\00")
(data (i32.const 17634) " pid:\00")
(data (i32.const 17640) "unlock\00")
(data (i32.const 17647) "magnitude of asset amount must be less than 2^62\00")
(data (i32.const 17696) "object passed to modify is not in multi_index\00")
(data (i32.const 17742) "cannot modify objects in table of another contract\00")
(data (i32.const 17793) "updater cannot change primary key when modifying an object\00")
(data (i32.const 17852) "attempt to add asset with different symbol\00")
(data (i32.const 17895) "addition underflow\00")
(data (i32.const 17914) "addition overflow\00")
(data (i32.const 17932) "write\00")
(data (i32.const 17938) "cannot pass end iterator to modify\00")
(data (i32.const 17973) "attempt to subtract asset with different symbol\00")
(data (i32.const 18021) "subtraction underflow\00")
(data (i32.const 18043) "subtraction overflow\00")
(data (i32.const 18064) "string is too long to be a valid name\00")
(data (i32.const 18102) "thirteenth character in name cannot be a letter that comes after j\00")
(data (i32.const 18169) "character is not in allowed character set for names\00")
(data (i32.const 18221) "string is too long to be a valid symbol_code\00")
(data (i32.const 18266) "only uppercase letters allowed in symbol_code string\00")
(data (i32.const 18320) "\94G\00\00")
(data (i32.const 18324) ".12345abcdefghijklmnopqrstuvwxyz\00")
(data (i32.const 18357) "object passed to iterator_to is not in multi_index\00")
(data (i32.const 18408) "error reading iterator\00")
(data (i32.const 18431) "read\00")
(data (i32.const 18436) "cannot create objects in table of another contract\00")
(data (i32.const 18487) ".\00")
(data (i32.const 18489) " \00")
(data (i32.const 18491) "object passed to erase is not in multi_index\00")
(data (i32.const 18536) "cannot erase objects in table of another contract\00")
(data (i32.const 18586) "attempt to remove object that was not in multi_index\00")
(data (i32.const 18639) "cannot pass end iterator to erase\00")
(data (i32.const 18673) "cannot increment end iterator\00")
(data (i32.const 18703) "get\00")
(import "env" "db_lowerbound_i64" (func $fimport$0 (param i64 i64 i64 i64) (result i32)))
(import "env" "eosio_assert" (func $fimport$1 (param i32 i32)))
(import "env" "db_find_i64" (func $fimport$2 (param i64 i64 i64 i64) (result i32)))
(import "env" "require_auth" (func $fimport$3 (param i64)))
(import "env" "prints" (func $fimport$4 (param i32)))
(import "env" "current_receiver" (func $fimport$5 (result i64)))
(import "env" "db_update_i64" (func $fimport$6 (param i32 i64 i32 i32)))
(import "env" "db_store_i64" (func $fimport$7 (param i64 i64 i64 i64 i32 i32) (result i32)))
(import "env" "require_recipient" (func $fimport$8 (param i64)))
(import "env" "is_account" (func $fimport$9 (param i64) (result i32)))
(import "env" "printui" (func $fimport$10 (param i64)))
(import "env" "db_remove_i64" (func $fimport$11 (param i32)))
(import "env" "send_inline" (func $fimport$12 (param i32 i32)))
(import "env" "memcpy" (func $fimport$13 (param i32 i32 i32) (result i32)))
(import "env" "current_time" (func $fimport$14 (result i64)))
(import "env" "send_deferred" (func $fimport$15 (param i32 i64 i32 i32 i32)))
(import "env" "db_next_i64" (func $fimport$16 (param i32 i32) (result i32)))
(import "env" "action_data_size" (func $fimport$17 (result i32)))
(import "env" "read_action_data" (func $fimport$18 (param i32 i32) (result i32)))
(import "env" "db_get_i64" (func $fimport$19 (param i32 i32 i32) (result i32)))
(import "env" "printi" (func $fimport$20 (param i64)))
(import "env" "prints_l" (func $fimport$21 (param i32 i32)))
(import "env" "abort" (func $fimport$22))
(import "env" "memset" (func $fimport$23 (param i32 i32 i32) (result i32)))
(import "env" "memmove" (func $fimport$24 (param i32 i32 i32) (result i32)))
(import "env" "unordtf2" (func $fimport$25 (param i64 i64 i64 i64) (result i32)))
(import "env" "eqtf2" (func $fimport$26 (param i64 i64 i64 i64) (result i32)))
(import "env" "multf3" (func $fimport$27 (param i32 i64 i64 i64 i64)))
(import "env" "addtf3" (func $fimport$28 (param i32 i64 i64 i64 i64)))
(import "env" "subtf3" (func $fimport$29 (param i32 i64 i64 i64 i64)))
(import "env" "netf2" (func $fimport$30 (param i64 i64 i64 i64) (result i32)))
(import "env" "fixunstfsi" (func $fimport$31 (param i64 i64) (result i32)))
(import "env" "floatunsitf" (func $fimport$32 (param i32 i32)))
(import "env" "fixtfsi" (func $fimport$33 (param i64 i64) (result i32)))
(import "env" "floatsitf" (func $fimport$34 (param i32 i32)))
(import "env" "extenddftf2" (func $fimport$35 (param i32 f64)))
(import "env" "extendsftf2" (func $fimport$36 (param i32 f32)))
(import "env" "divtf3" (func $fimport$37 (param i32 i64 i64 i64 i64)))
(import "env" "letf2" (func $fimport$38 (param i64 i64 i64 i64) (result i32)))
(import "env" "trunctfdf2" (func $fimport$39 (param i64 i64) (result f64)))
(import "env" "getf2" (func $fimport$40 (param i64 i64 i64 i64) (result i32)))
(import "env" "trunctfsf2" (func $fimport$41 (param i64 i64) (result f32)))
(import "env" "set_blockchain_parameters_packed" (func $fimport$42 (param i32 i32)))
(import "env" "get_blockchain_parameters_packed" (func $fimport$43 (param i32 i32) (result i32)))
(export "memory" (memory $0))
(export "heap_base" (global $global$1))
(export "data_end" (global $global$2))
(export "apply" (func $63))
(export "_ZdlPv" (func $96))
(export "_Znwj" (func $94))
(export "_Znaj" (func $95))
(export "_ZdaPv" (func $97))
(export "_ZnwjSt11align_val_t" (func $98))
(export "_ZnajSt11align_val_t" (func $99))
(export "_ZdlPvSt11align_val_t" (func $100))
(export "_ZdaPvSt11align_val_t" (func $101))
(table $0 14 14 anyfunc)
(elem (i32.const 1) $16 $31 $3 $33 $27 $47 $59 $41 $62 $8 $20 $1 $2)
(global $global$0 (mut i32) (i32.const 8192))
(global $global$1 i32 (i32.const 18707))
(global $global$2 i32 (i32.const 18707))


int_32 .FUNC _ZnwjSt11align_val_t (int_32 $0, int_32 $1)
{
	int_32 $2
	int_32 $3
	$2	 = ($global$0 - [16])
	$global$0 = $2
	$3	 = ( $0 ? [1] : $0 )
	$1	 = ( $1 ? [4] : ((uint_32)$1 > (uint_32)[4]) )
	if ( (CALL $112(($2 + [12]), $1, $3) == 0) ){ goto $label$1 }
	
.LOOP $label$3:
	$0	 = *([0] + [8216])
	if ( ($0 == 0) ){ goto $label$2 }
	CALL void $0()
	if ( CALL $112(($2 + [12]), $1, $3) ){ goto $label$3 }
	goto $label$1 
	
.LABEL $label$2
	*($2 + [12]) = [0]
	
.LABEL $label$1
	$0 = *($2 + [12])
	$global$0 = ($2 + [16])
	return $0
}

int_32 .FUNC _ZnajSt11align_val_t (int_32 $0, int_32 $1)
{
	return CALL _ZnwjSt11align_val_t($0, $1)
}

int_32 .FUNC _Znwj (int_32 $0)
{
	int_32 $1
	int_32 $2
	$1	 = ( $0 ? [1] : $0 )
	$0	 = CALL $114($1)
	if ( $0 ){ goto $label$1 }
	
.LOOP $label$2:
	$0 = [0]
	$2	 = *([0] + [8216])
	if ( ($2 == 0) ){ goto $label$1 }
	CALL void $2()
	$0	 = CALL $114($1)
	if ( ($0 == 0) ){ goto $label$2 }
	
.LABEL $label$1
	return $0
}

int_32 .FUNC _Znaj (int_32 $0)
{
	return CALL _Znwj($0)
}

void .FUNC _ZdlPv (int_32 $0)
{
	if ( ($0 == 0) ){ goto $label$1 }
	CALL $118($0)
	
.LABEL $label$1
}

void .FUNC _ZdaPv (int_32 $0)
{
	CALL _ZdlPv($0)
}

.data 18436 -> ["cannot create objects in table of another contract\00"]
void .FUNC $90 (int_32 $0, int_32 $1, int_64 $2, int_32 $3)
{
	int_32 $4
	int_32 $5
	int_32 $6
	int_32 $7
	$4	 = ($global$0 - [48])
	$global$0 = $4
	*($4 + [40]) = $2
	CALL eosio_assert(((int_64)*($1) == (int_64)CALL $fimport$5()), [18436])     # .data 18436 -> ["cannot create objects in table of another contract"]
	*($4 + [20]) = $3
	*($4 + [16]) = $1
	*($4 + [24]) = ($4 + [40])
	$3	 = CALL _Znwj([32])
	CALL $91($3, $1, ($4 + [16]))
	*($4 + [32]) = $3
	$2	 = *($3)
	*($4 + [16]) = $2
	$5	 = *($3 + [20])
	*($4 + [12]) = $5
	$6	 = ($1 + [28])
	$7	 = *($6)
	if ( ((uint_32)$7 >= (uint_32)*(($1 + [32]))) ){ goto $label$2 }
	*($7 + [8]) = $2
	*($7 + [16]) = $5
	*($4 + [32]) = [0]
	*($7) = $3
	*($6) = ($7 + [24])
	goto $label$1 
	
.LABEL $label$2
	CALL $78(($1 + [24]), ($4 + [32]), ($4 + [16]), ($4 + [12]))
	
.LABEL $label$1
	*($0 + [4]) = $3
	*($0) = $1
	$1 = *($4 + [32])
	*($4 + [32]) = [0]
	if ( ($1 == 0) ){ goto $label$3 }
	CALL _ZdlPv($1)
	
.LABEL $label$3
	$global$0 = ($4 + [48])
}

.data 17932 -> ["write\00"]
int_32 .FUNC $91 (int_32 $0, int_32 $1, int_32 $2)
{
	int_32 $3
	int_64 $4
	$3	 = ($global$0 - [16])
	$global$0 = $3
	*($0 + [16]) = $1
	*($0) = (int_64)0
	*($0 + [8]) = (int_64)1
	$1 = *($2)
	CALL eosio_assert([1], [17932])     # .data 17932 -> ["write"]
	CALL memcpy($3, $0, [8])
	CALL eosio_assert([1], [17932])     # .data 17932 -> ["write"]
	CALL memcpy(($3 | [8]), ($0 + [8]), [8])
	$4	 = *($0)
	*($0 + [20]) = CALL db_store_i64(*($1 + [8]), (int_64)7174797156354621440, *(*($2 + [8])), $4, $3, [16])
	if ( (uint_64)($4 <= *($1 + [16])) ){ goto $label$1 }
	*(($1 + [16])) = ( (int_64)-2 ? ((int_64)$4 + (int_64)1) : ((uint_64)$4 > (uint_64)(int_64)-3) )
	
.LABEL $label$1
	$global$0 = ($3 + [16])
	return $0
}

.data 18431 -> ["read\00"]
.data 18703 -> ["get\00"]
int_32 .FUNC $92 (int_32 $0, int_32 $1)
{
	int_32 $2
	int_32 $3
	int_64 $4
	int_32 $5
	int_32 $6
	int_32 $7
	$2 = *($0 + [4])
	$3 = [0]
	$4 = (int_64)0
	$5 = ($0 + [8])
	$6 = ($0 + [4])
	
.LOOP $label$1:
	CALL eosio_assert(($2 <= *($5)), [18703])     # .data 18703 -> ["get"]
	$2	 = *($6)
	$7 = *($2)
	$2	 = ($2 + [1])
	*($6) = $2
	$3	 = ($3 & [255])
	$4 = ((int_64)$4 | (int_64)(CASTING uint_64)(uint_32 (($7 & [127]) << $3)))
	$3 = ($3 + [7])
	if ( ($7 & [128]) ){ goto $label$1 }
	$6	 = (CASTING uint_32)(uint_64 $4)
	$7	 = *($1)
	$3	 = *($1 + [4])
	$5	 = ($3 - $7)
	if ( ((uint_32)$5 >= (uint_32)$6) ){ goto $label$3 }
	CALL $46($1, ($6 - $5))
	$2 = *(($0 + [4]))
	$3 = *(($1 + [4]))
	$7 = *($1)
	goto $label$2 
	
.LABEL $label$3
	if ( ((uint_32)$5 <= (uint_32)$6) ){ goto $label$2 }
	$3	 = ($7 + $6)
	*(($1 + [4])) = $3
	
.LABEL $label$2
	$2	 = ($3 - $7)
	CALL eosio_assert(((uint_32)(*(($0 + [8])) - $2) >= (uint_32)$2), [18431])     # .data 18431 -> ["read"]
	$3	 = ($0 + [4])
	CALL memcpy($7, *($3), $2)
	*($3) = (*($3) + $2)
	return $0
}

.data 17007 -> ["imeoswinner1\00"]
.data 16908 -> ["bigwinshare1\00malloc_from_freed was designed to only be called after _heap was completely allocated\00"]
void .FUNC $93 ()
{
	int_32 $0
	int_32 $1
	int_32 $2
	*([0] + [8192 align=4]) = (int_64)0
	*([0] + [8200]) = [0]
	$0	 = CALL $109([16908])
	if ( ((uint_32)$0 >= (uint_32)[-16]) ){ goto $label$2 }     # .data 16908 -> ["bigwinshare1"]
	if ( ((uint_32)$0 >= (uint_32)[11]) ){ goto $label$5 }
	*([0] + [8192]) = ($0 << [1])
	$1 = [8193]
	if ( $0 ){ goto $label$4 }
	goto $label$3 
	
.LABEL $label$5
	$2	 = (($0 + [16]) & [-16])
	$1 = CALL _Znwj($2)
	*([0] + [8192]) = ($2 | [1])
	*([0] + [8200]) = $1
	*([0] + [8196]) = $0
	
.LABEL $label$4
	CALL memcpy($1, [16908], $0)     # .data 16908 -> ["bigwinshare1"]
	
.LABEL $label$3
	*(($1 + $0)) = [0]
	CALL $108([12], [0], [8192])
	*([0] + [8204 align=4]) = (int_64)0
	*([0] + [8212]) = [0]
	$0	 = CALL $109([17007])
	if ( ((uint_32)$0 >= (uint_32)[-16]) ){ goto $label$1 }     # .data 17007 -> ["imeoswinner1"]
	if ( ((uint_32)$0 >= (uint_32)[11]) ){ goto $label$8 }
	*([0] + [8204]) = ($0 << [1])
	$1 = [8205]
	if ( $0 ){ goto $label$7 }
	goto $label$6 
	
.LABEL $label$8
	$2	 = (($0 + [16]) & [-16])
	$1 = CALL _Znwj($2)
	*([0] + [8204]) = ($2 | [1])
	*([0] + [8212]) = $1
	*([0] + [8208]) = $0
	
.LABEL $label$7
	CALL memcpy($1, [17007], $0)     # .data 17007 -> ["imeoswinner1"]
	
.LABEL $label$6
	*(($1 + $0)) = [0]
	CALL $108([13], [0], [8192])
	return (unreachable)
	
.LABEL $label$2
	CALL $102([8192])
	
.LABEL $label$1
	CALL $102([8204])
	(unreachable)
}

int_32 .FUNC $115 (int_32 $0, int_32 $1)
{
	int_32 $2
	int_32 $3
	int_32 $4
	int_32 $5
	int_32 $6
	int_32 $7
	int_32 $8
	int_32 $9
	int_32 $10
	int_32 $11
	int_32 $12
	int_32 $13
	if ( ($1 == 0) ){ goto $label$1 }
	$2	 = *($0 + [8384])
	if ( $2 ){ goto $label$2 }
	$2 = [16]
	*(($0 + [8384])) = [16]
	
.LABEL $label$2
	$3	 = (($1 + [4]) & [7])
	$3 = ( (($1 + [8]) - $3) ? $1 : $3 )
	$4	 = *($0 + [8388])
	if ( ((uint_32)$4 >= (uint_32)$2) ){ goto $label$5 }
	$1 = (($0 + ((int_32)$4 * (int_32)[12])) + [8192])
	if ( $4 ){ goto $label$6 }
	$2	 = ($0 + [8196])
	if ( *($2) ){ goto $label$6 }
	*($1) = [8192]
	*($2) = $0
	
.LABEL $label$6
	$4 = ($3 + [4])
	
.LOOP $label$7:
	$2	 = *($1 + [8])
	if ( ((uint_32)($2 + $4) > (uint_32)*($1)) ){ goto $label$8 }
	*(($2 = (*($1 + [4]) + $2))) = ((*($2) & [-2147483648]) | $3)
	*(($1 = ($1 + [8]))) = (*($1) + $4)
	*($2) = (*($2) | [-2147483648])
	$1	 = ($2 + [4])
	if ( $1 ){ goto $label$4 }
	
.LABEL $label$8
	$1	 = CALL $116($0)
	if ( $1 ){ goto $label$7 }
	
.LABEL $label$5
	$5 = ([2147483644] - $3)
	$6 = ($0 + [8392])
	$7 = ($0 + [8384])
	$8	 = *($0 + [8392])
	$2 = $8
	
.LOOP $label$9:
	$9	 = ($1 + [8192])
	$1	 = ($0 + ((int_32)$2 * (int_32)[12]))
	CALL eosio_assert(((int_32)*(($1 + [8200])) == (int_32)*($9)), [16921])
	$10	 = *(($1 + [8196]))
	$2 = ($10 + [4])
	
.LOOP $label$10:
	$11 = ($10 + *($9))
	$12	 = ($2 + [-4])
	$13	 = *($12)
	$1 = ($13 & [2147483647])
	if ( ((int_32)$13 < (int_32)[0]) ){ goto $label$11 }
	if ( ((uint_32)$1 >= (uint_32)$3) ){ goto $label$12 }
	
.LOOP $label$13:
	$4	 = ($2 + $1)
	if ( ((uint_32)$4 >= (uint_32)$11) ){ goto $label$12 }
	$4	 = *($4)
	if ( ((int_32)$4 < (int_32)[0]) ){ goto $label$12 }
	$1	 = (($1 + ($4 & [2147483647])) + [4])
	if ( ($1 <= $3) ){ goto $label$13 }
	
.LABEL $label$12
	*($12) = (( $1 ? $3 : ($1 <= $3) ) | ($13 & [-2147483648]))
	if ( ((uint_32)$1 <= (uint_32)$3) ){ goto $label$14 }
	*(($2 + $3)) = (($5 + $1) & [2147483647])
	
.LABEL $label$14
	if ( ((uint_32)$1 >= (uint_32)$3) ){ goto $label$3 }
	
.LABEL $label$11
	$2	 = (($2 + $1) + [4])
	if ( ($2 <= $11) ){ goto $label$10 }
	$1 = [0]
	$2	 = (*($6) + [1])
	$2	 = ( [0] ? $2 : ((int_32)$2 == (int_32)*($7)) )
	*($6) = $2
	if ( ((int_32)$2 != (int_32)$8) ){ goto $label$9 }
	
.LABEL $label$4
	return $1
	
.LABEL $label$3
	*($12) = (*($12) | [-2147483648])
	return $2
	
.LABEL $label$1
	return [0]
}

.data 17932 -> ["write\00"]
void .FUNC $38 (int_32 $0, int_32 $1)
{
	int_32 $2
	int_32 $3
	int_32 $4
	int_32 $5
	$2	 = ($global$0 - [16])
	$global$0 = $2
	$3 = *($0)
	$4	 = *($1)
	CALL eosio_assert(((int_32)(*($4 + [8]) - *($4 + [4])) > (int_32)[7]), [17932])     # .data 17932 -> ["write"]
	CALL memcpy(*($4 + [4]), $3, [8])
	*($4 + [4]) = (*($4 + [4]) + [8])
	$3 = *($0 + [4])
	$4	 = *($1)
	CALL eosio_assert(((int_32)(*($4 + [8]) - *($4 + [4])) > (int_32)[0]), [17932])     # .data 17932 -> ["write"]
	CALL memcpy(*($4 + [4]), $3, [1])
	*($4 + [4]) = (*($4 + [4]) + [1])
	$3 = *($0 + [8])
	$4	 = *($1)
	CALL eosio_assert(((int_32)(*($4 + [8]) - *($4 + [4])) > (int_32)[7]), [17932])     # .data 17932 -> ["write"]
	CALL memcpy(*($4 + [4]), $3, [8])
	$5	 = (*($4 + [4]) + [8])
	*($4 + [4]) = $5
	*($2 + [8]) = *($3 + [8])
	CALL eosio_assert(((int_32)(*($4 + [8]) - $5) > (int_32)[7]), [17932])     # .data 17932 -> ["write"]
	CALL memcpy(*($4 + [4]), ($2 + [8]), [8])
	*($4 + [4]) = (*($4 + [4]) + [8])
	$0 = *($0 + [12])
	$4	 = *($1)
	CALL eosio_assert(((int_32)(*($4 + [8]) - *($4 + [4])) > (int_32)[7]), [17932])     # .data 17932 -> ["write"]
	CALL memcpy(*($4 + [4]), $0, [8])
	$1	 = (*($4 + [4]) + [8])
	*($4 + [4]) = $1
	*($2 + [8]) = *($0 + [8])
	CALL eosio_assert(((int_32)(*($4 + [8]) - $1) > (int_32)[7]), [17932])     # .data 17932 -> ["write"]
	CALL memcpy(*($4 + [4]), ($2 + [8]), [8])
	*($4 + [4]) = (*($4 + [4]) + [8])
	$global$0 = ($2 + [16])
}

.data 18586 -> ["attempt to remove object that was not in multi_index\00"]
.data 18536 -> ["cannot erase objects in table of another contract\00"]
.data 18491 -> ["object passed to erase is not in multi_index\00"]
void .FUNC $49 (int_32 $0, int_32 $1)
{
	int_32 $2
	int_32 $3
	int_32 $4
	int_32 $5
	int_64 $6
	int_32 $7
	int_32 $8
	CALL eosio_assert(((int_32)*($1 + [24]) == (int_32)$0), [18491])     # .data 18491 -> ["object passed to erase is not in multi_index"]
	CALL eosio_assert(((int_64)*($0) == (int_64)CALL $fimport$5()), [18536])     # .data 18536 -> ["cannot erase objects in table of another contract"]
	$2	 = *($0 + [24])
	$3 = $2
	$4	 = ($0 + [28])
	$5	 = *($4)
	if ( ((int_32)$2 == (int_32)$5) ){ goto $label$1 }
	$6	 = *($1)
	if ( ((int_64)*(*(($5 + [-24]))) != (int_64)$6) ){ goto $label$2 }
	$3 = $5
	goto $label$1 
	
.LABEL $label$2
	$7 = ($2 + [24])
	
.LOOP $label$4:
	if ( ((int_32)$7 == (int_32)$5) ){ goto $label$3 }
	$8 = ($5 + [-48])
	$3	 = ($5 + [-24])
	$5 = $3
	if ( ((int_64)*(*($8)) != (int_64)$6) ){ goto $label$4 }
	goto $label$1 
	
.LABEL $label$3
	$3 = $2
	
.LABEL $label$1
	CALL eosio_assert(((int_32)$3 != (int_32)$2), [18586])     # .data 18586 -> ["attempt to remove object that was not in multi_index"]
	$2	 = *($4)
	if ( ((int_32)$3 == (int_32)$2) ){ goto $label$7 }
	$5 = $3
	
.LOOP $label$8:
	$8 = *($5)
	*($5) = [0]
	$7	 = ($5 + [-24])
	$3 = *($7)
	*($7) = $8
	if ( ($3 == 0) ){ goto $label$9 }
	CALL _ZdlPv($3)
	
.LABEL $label$9
	*(($5 + [-8])) = *(($5 + [16]))
	*(($5 + [-16])) = *(($5 + [8]))
	$5	 = ($5 + [24])
	if ( ((int_32)$2 != (int_32)$5) ){ goto $label$8 }
	$8 = ($5 + [-24])
	$3	 = *(($0 + [28]))
	if ( ((int_32)($3 + [24]) != (int_32)$5) ){ goto $label$6 }
	goto $label$5 
	
.LABEL $label$7
	$8 = ($3 + [-24])
	
.LABEL $label$6
	
.LOOP $label$10:
	$3	 = ($3 + [-24])
	$5 = *($3)
	*($3) = [0]
	if ( ($5 == 0) ){ goto $label$11 }
	CALL _ZdlPv($5)
	
.LABEL $label$11
	if ( ((int_32)$8 != (int_32)$3) ){ goto $label$10 }
	
.LABEL $label$5
	*(($0 + [28])) = $8
	CALL db_remove_i64(*($1 + [28]))
}

.data 18357 -> ["object passed to iterator_to is not in multi_index\00"]
int_32 .FUNC $48 (int_32 $0, int_64 $1, int_32 $2)
{
	int_32 $3
	int_32 $4
	int_32 $5
	int_32 $6
	$4	 = *(($0 + [28]))
	$3	 = *($0 + [24])
	if ( ((int_32)$3 == (int_32)$4) ){ goto $label$1 }
	
.LOOP $label$3:
	$5	 = ($4 + [-24])
	$6	 = *($5)
	if ( ((int_64)*($6) == (int_64)$1) ){ goto $label$2 }
	$4 = $5
	if ( ((int_32)$3 != (int_32)$5) ){ goto $label$3 }
	goto $label$1 
	
.LABEL $label$2
	if ( ((int_32)$3 == (int_32)$4) ){ goto $label$1 }
	CALL eosio_assert(((int_32)*($6 + [24]) == (int_32)$0), [18357])     # .data 18357 -> ["object passed to iterator_to is not in multi_index"]
	CALL eosio_assert(((int_32)$6 != (int_32)[0]), $2)
	return $6
	
.LABEL $label$1
	$5 = [0]
	$4	 = CALL db_find_i64(*($0), *($0 + [8]), (int_64)-8281825045618098176, $1)
	if ( ((int_32)$4 < (int_32)[0]) ){ goto $label$4 }
	$5	 = CALL $44($0, $4)
	CALL eosio_assert(((int_32)*($5 + [24]) == (int_32)$0), [18357])     # .data 18357 -> ["object passed to iterator_to is not in multi_index"]
	
.LABEL $label$4
	CALL eosio_assert(((int_32)$5 != (int_32)[0]), $2)
	return $5
}

.data 17932 -> ["write\00"]
void .FUNC $43 (int_32 $0, int_32 $1)
{
	int_32 $2
	int_32 $3
	int_32 $4
	int_32 $5
	int_32 $6
	int_32 $7
	int_64 $8
	$2	 = ($global$0 - [16])
	$global$0 = $2
	*($0 + [8]) = [0]
	*($0) = (int_64)0
	$3 = [16]
	$4 = ($1 + [16])
	$6	 = *($1 + [16])
	$5	 = *(($1 + [20]))
	$7	 = ($5 - $6)
	$8 = (CASTING uint_64)(uint_32 int_32($7 >> [4]))
	
.LOOP $label$1:
	$3 = ($3 + [1])
	$8	 = (uint_64)$8 >> (uint_64)(int_64)7
	if ( ((int_64)$8) != (int_64)0) ){ goto $label$1 }
	if ( ((int_32)$6 == (int_32)$5) ){ goto $label$2 }
	$3 = (($7 & [-16]) + $3)
	
.LABEL $label$2
	$6	 = *(($1 + [32]))
	$5	 = *($1 + [28])
	$3 = (($5 - $3) - $6)
	$7 = ($1 + [28])
	$8 = (CASTING uint_64)(uint_32 ($6 - $5))
	
.LOOP $label$3:
	$3 = ($3 + [-1])
	$8	 = (uint_64)$8 >> (uint_64)(int_64)7
	if ( ((int_64)$8) != (int_64)0) ){ goto $label$3 }
	$5 = [0]
	if ( ($3 == 0) ){ goto $label$5 }
	CALL $46($0, ([0] - $3))
	$5 = *(($0 + [4]))
	$3 = *($0)
	goto $label$4 
	
.LABEL $label$5
	$3 = [0]
	
.LABEL $label$4
	*($2) = $3
	*($2 + [8]) = $5
	$0	 = ($5 - $3)
	CALL eosio_assert(((int_32)$0 > (int_32)[7]), [17932])     # .data 17932 -> ["write"]
	CALL memcpy($3, $1, [8])
	CALL eosio_assert(((int_32)($0 + [-8]) > (int_32)[7]), [17932])     # .data 17932 -> ["write"]
	CALL memcpy(($3 + [8]), ($1 + [8]), [8])
	*($2 + [4]) = ($3 + [16])
	CALL $76(CALL $75($2, $4), $7)
	$global$0 = ($2 + [16])
}

.data 17932 -> ["write\00"]
int_32 .FUNC $42 (int_32 $0, int_32 $1, int_64 $2, int_64 $3, int_32 $4)
{
	int_32 $5
	int_32 $6
	int_32 $7
	int_32 $8
	int_32 $9
	$5	 = ($global$0 - [16])
	$global$0 = $5
	*($0 + [8]) = $3
	*($0) = $2
	*($0 + [16 align=4]) = (int_64)0
	*(($6 = ($0 + [24]))) = [0]
	$7	 = CALL _Znwj([16])
	*($0 + [16]) = $7
	*(($8 = ($0 + [20]))) = $7
	$9	 = ($7 + [16])
	*($6) = $9
	*(($7 + [8])) = *(($1 + [8]))
	*($7) = *($1)
	*($8) = $9
	*($0 + [28 align=4]) = (int_64)0
	*(($0 + [36])) = [0]
	CALL $46(($0 + [28]), [24])
	$7	 = *($0 + [28])
	$1	 = (*(($0 + [32])) - $7)
	CALL eosio_assert(((int_32)$1 > (int_32)[7]), [17932])     # .data 17932 -> ["write"]
	CALL memcpy($7, $4, [8])
	CALL eosio_assert(((int_32)($1 + [-8]) > (int_32)[7]), [17932])     # .data 17932 -> ["write"]
	CALL memcpy(($7 + [8]), ($4 + [8]), [8])
	*($5 + [8]) = *(($4 + [16]))
	CALL eosio_assert(((int_32)($1 + [-16]) > (int_32)[7]), [17932])     # .data 17932 -> ["write"]
	CALL memcpy(($7 + [16]), ($5 + [8]), [8])
	$global$0 = ($5 + [16])
	return $0
}

.data 18436 -> ["cannot create objects in table of another contract\00"]
.data 17932 -> ["write\00"]
.data 17793 -> ["updater cannot change primary key when modifying an object\00"]
.data 17914 -> ["addition overflow\00"]
.data 17895 -> ["addition underflow\00"]
.data 17852 -> ["attempt to add asset with different symbol\00"]
.data 17742 -> ["cannot modify objects in table of another contract\00"]
.data 17696 -> ["object passed to modify is not in multi_index\00"]
.data 17938 -> ["cannot pass end iterator to modify\00"]
.data 18357 -> ["object passed to iterator_to is not in multi_index\00"]
.data 17553 -> ["lock\00"]
.data 17291 -> ["active\00"]
void .FUNC $41 (int_32 $0, int_64 $1, int_32 $2)
{
	int_32 $3
	int_64 $4
	int_64 $5
	int_32 $6
	int_32 $7
	$3	 = ($global$0 - [128])
	$global$0 = $3
	CALL require_auth($1)
	$4 = *($0)
	*($3 + [96]) = [17291]     # .data 17291 -> ["active"]
	*($3 + [100]) = CALL $109([17291])     # .data 17291 -> ["active"]
	*($3 + [16]) = *($3 + [96])
	*($3 + [32]) = *(CALL $10(($3 + [40]), ($3 + [16])))
	*($3 + [24]) = $4
	$4 = *($0)
	*($3 + [96]) = [17553]     # .data 17553 -> ["lock"]
	*($3 + [100]) = CALL $109([17553])     # .data 17553 -> ["lock"]
	*($3 + [8]) = *($3 + [96])
	$5 = *(CALL $10(($3 + [40]), ($3 + [8])))
	*(($3 + [112])) = *(($2 + [8]))
	*($3 + [96]) = $1
	*($3 + [104]) = *($2)
	$6	 = CALL $42(($3 + [40]), ($3 + [24]), $4, $5, ($3 + [96]))
	CALL $43(($3 + [80]), $6)
	$7	 = *($3 + [80])
	CALL send_inline($7, (*($3 + [84]) - $7))
	$7	 = *($3 + [80])
	if ( ($7 == 0) ){ goto $label$1 }
	*($3 + [84]) = $7
	CALL _ZdlPv($7)
	
.LABEL $label$1
	$7	 = *($6 + [28])
	if ( ($7 == 0) ){ goto $label$2 }
	*(($6 + [32])) = $7
	CALL _ZdlPv($7)
	
.LABEL $label$2
	$7	 = *($6 + [16])
	if ( ($7 == 0) ){ goto $label$3 }
	*(($6 + [20])) = $7
	CALL _ZdlPv($7)
	
.LABEL $label$3
	*(($3 + [72])) = [0]
	*($3 + [56]) = (int_64)-1
	*($3 + [64]) = (int_64)0
	$4	 = *($0)
	*($3 + [40]) = $4
	*($3 + [48]) = $4
	$6	 = CALL db_find_i64($4, $4, (int_64)-8281825045618098176, $1)
	if ( ((int_32)$6 < (int_32)[0]) ){ goto $label$7 }
	$6	 = CALL $44(($3 + [40]), $6)
	CALL eosio_assert(((int_32)*($6 + [24]) == (int_32)($3 + [40])), [18357])     # .data 18357 -> ["object passed to iterator_to is not in multi_index"]
	CALL eosio_assert([1], [17938])     # .data 17938 -> ["cannot pass end iterator to modify"]
	CALL eosio_assert(((int_32)*($6 + [24]) == (int_32)($3 + [40])), [17696])     # .data 17696 -> ["object passed to modify is not in multi_index"]
	CALL eosio_assert(((int_64)*($3 + [40]) == (int_64)CALL $fimport$5()), [17742])     # .data 17742 -> ["cannot modify objects in table of another contract"]
	$4 = *($6)
	$0	 = ($6 + [16])
	CALL eosio_assert(((int_64)*($2 + [8]) == (int_64)*($0)), [17852])     # .data 17852 -> ["attempt to add asset with different symbol"]
	$5	 = ((int_64)*($6 + [8]) + (int_64)*($2))
	*($6 + [8]) = $5
	CALL eosio_assert(((int_64)$5 > (int_64)-4611686018427387904), [17895])     # .data 17895 -> ["addition underflow"]
	CALL eosio_assert(((int_64)*($6 + [8]) < (int_64)4611686018427387904), [17914])     # .data 17914 -> ["addition overflow"]
	CALL eosio_assert(((int_64)$4 == (int_64)*($6)), [17793])     # .data 17793 -> ["updater cannot change primary key when modifying an object"]
	CALL eosio_assert([1], [17932])     # .data 17932 -> ["write"]
	CALL memcpy(($3 + [96]), $6, [8])
	CALL eosio_assert([1], [17932])     # .data 17932 -> ["write"]
	CALL memcpy((($3 + [96]) | [8]), ($6 + [8]), [8])
	*($3 + [24]) = *($0)
	CALL eosio_assert([1], [17932])     # .data 17932 -> ["write"]
	CALL memcpy((($3 + [96]) + [16]), ($3 + [24]), [8])
	CALL db_update_i64(*($6 + [28]), $1, ($3 + [96]), [24])
	$6	 = (($3 + [40]) + [16])
	if ( (uint_64)($4 <= *($6)) ){ goto $label$6 }
	*($6) = ( (int_64)-2 ? ((int_64)$4 + (int_64)1) : ((uint_64)$4 > (uint_64)(int_64)-3) )
	$0	 = *($3 + [64])
	if ( $0 ){ goto $label$5 }
	goto $label$4 
	
.LABEL $label$7
	CALL eosio_assert(((int_64)$4 == (int_64)CALL $fimport$5()), [18436])     # .data 18436 -> ["cannot create objects in table of another contract"]
	*(($6 = CALL _Znwj([40])) + [24]) = ($3 + [40])
	*($6) = $1
	*($6 + [16]) = *(($2 + [8]))
	*($6 + [8]) = *($2)
	CALL eosio_assert([1], [17932])     # .data 17932 -> ["write"]
	CALL memcpy(($3 + [96]), $6, [8])
	CALL eosio_assert([1], [17932])     # .data 17932 -> ["write"]
	CALL memcpy((($3 + [96]) | [8]), ($6 + [8]), [8])
	*($3 + [24]) = *($6 + [16])
	CALL eosio_assert([1], [17932])     # .data 17932 -> ["write"]
	CALL memcpy((($3 + [96]) + [16]), ($3 + [24]), [8])
	$4	 = *($6)
	$0	 = CALL db_store_i64(*((($3 + [40]) + [8])), (int_64)-8281825045618098176, $1, $4, ($3 + [96]), [24])
	*($6 + [28]) = $0
	$2	 = (($3 + [40]) + [16])
	if ( (uint_64)($4 <= *($2)) ){ goto $label$8 }
	*($2) = ( (int_64)-2 ? ((int_64)$4 + (int_64)1) : ((uint_64)$4 > (uint_64)(int_64)-3) )
	
.LABEL $label$8
	*($3 + [24]) = $6
	$1	 = *($6)
	*($3 + [96]) = $1
	*($3 + [80]) = $0
	$7	 = ($3 + [68])
	$2	 = *($7)
	if ( ((uint_32)$2 >= (uint_32)*(($3 + [72]))) ){ goto $label$10 }
	*($2 + [8]) = $1
	*($2 + [16]) = $0
	*($3 + [24]) = [0]
	*($2) = $6
	*($7) = ($2 + [24])
	$6 = *($3 + [24])
	*($3 + [24]) = [0]
	if ( $6 ){ goto $label$9 }
	goto $label$6 
	
.LABEL $label$10
	CALL $45(($3 + [64]), ($3 + [24]), ($3 + [96]), ($3 + [80]))
	$6 = *($3 + [24])
	*($3 + [24]) = [0]
	if ( ($6 == 0) ){ goto $label$6 }
	
.LABEL $label$9
	CALL _ZdlPv($6)
	
.LABEL $label$6
	$0	 = *($3 + [64])
	if ( ($0 == 0) ){ goto $label$4 }
	
.LABEL $label$5
	$7	 = ($3 + [68])
	$6	 = *($7)
	if ( ((int_32)$6 == (int_32)$0) ){ goto $label$12 }
	
.LOOP $label$13:
	$6	 = ($6 + [-24])
	$2 = *($6)
	*($6) = [0]
	if ( ($2 == 0) ){ goto $label$14 }
	CALL _ZdlPv($2)
	
.LABEL $label$14
	if ( ((int_32)$0 != (int_32)$6) ){ goto $label$13 }
	$6 = *(($3 + [64]))
	goto $label$11 
	
.LABEL $label$12
	$6 = $0
	
.LABEL $label$11
	*($7) = $0
	CALL _ZdlPv($6)
	
.LABEL $label$4
	$global$0 = ($3 + [128])
}

.data 17932 -> ["write\00"]
void .FUNC $40 (int_64 $0, int_64 $1, int_32 $2, int_32 $3)
{
	int_32 $4
	int_32 $5
	int_32 $6
	int_32 $7
	int_32 $8
	$4	 = ($global$0 - [80])
	$global$0 = $4
	*($4 + [8]) = [0]
	*($4) = (int_64)0
	$5 = [0]
	$6 = [0]
	$7 = [0]
	$8	 = (*($2 + [4]) - *($2))
	if ( ($8 == 0) ){ goto $label$2 }
	$5	 = int_32($8 >> [4])
	if ( ((uint_32)$5 >= (uint_32)[268435456]) ){ goto $label$1 }
	$7	 = CALL _Znwj($8)
	$5	 = ($7 + ($5 << [4]))
	*(($4 + [8])) = $5
	*($4) = $7
	*($4 + [4]) = $7
	$6	 = *($2)
	$2	 = (*(($2 + [4])) - $6)
	if ( ((int_32)$2 < (int_32)[1]) ){ goto $label$3 }
	CALL memcpy($7, $6, $2)
	$6	 = ($7 + $2)
	*($4 + [4]) = $6
	goto $label$2 
	
.LABEL $label$3
	$6 = $7
	
.LABEL $label$2
	*(($4 + [36])) = $6
	*((($4 + [16]) + [24])) = $5
	*(($4 + [8])) = [0]
	*(($4 + [52])) = [0]
	*($4 + [24]) = $1
	*($4 + [16]) = $0
	*($4 + [32]) = $7
	*($4) = (int_64)0
	*($4 + [44 align=4]) = (int_64)0
	$7	 = *($3 + [24])
	$2	 = ( *(($3 + [28])) ? uint_32($7 >> [1]) : ($7 & [1]) )
	$7 = ($2 + [24])
	$0 = (CASTING uint_64)(uint_32 $2)
	$5 = ($3 + [24])
	$2 = (($4 + [16]) + [28])
	
.LOOP $label$4:
	$7 = ($7 + [1])
	$0	 = (uint_64)$0 >> (uint_64)(int_64)7
	if ( ((int_64)$0) != (int_64)0) ){ goto $label$4 }
	if ( ($7 == 0) ){ goto $label$6 }
	CALL $46($2, $7)
	$2 = *(($4 + [48]))
	$7 = *(($4 + [44]))
	goto $label$5 
	
.LABEL $label$6
	$2 = [0]
	$7 = [0]
	
.LABEL $label$5
	*($4 + [64]) = $7
	*($4 + [72]) = $2
	$2	 = ($2 - $7)
	CALL eosio_assert(((int_32)$2 > (int_32)[7]), [17932])     # .data 17932 -> ["write"]
	CALL memcpy($7, $3, [8])
	CALL eosio_assert(((int_32)($2 + [-8]) > (int_32)[7]), [17932])     # .data 17932 -> ["write"]
	CALL memcpy(($7 + [8]), ($3 + [8]), [8])
	*($4 + [56]) = *(($3 + [16]))
	CALL eosio_assert(((int_32)($2 + [-16]) > (int_32)[7]), [17932])     # .data 17932 -> ["write"]
	CALL memcpy(($7 + [16]), ($4 + [56]), [8])
	*($4 + [68]) = ($7 + [24])
	CALL $83(($4 + [64]), $5)
	CALL $43(($4 + [64]), ($4 + [16]))
	$7	 = *($4 + [64])
	CALL send_inline($7, (*($4 + [68]) - $7))
	$7	 = *($4 + [64])
	if ( ($7 == 0) ){ goto $label$7 }
	*($4 + [68]) = $7
	CALL _ZdlPv($7)
	
.LABEL $label$7
	$7	 = *($4 + [44])
	if ( ($7 == 0) ){ goto $label$8 }
	*(($4 + [48])) = $7
	CALL _ZdlPv($7)
	
.LABEL $label$8
	$7	 = *($4 + [32])
	if ( ($7 == 0) ){ goto $label$9 }
	*(($4 + [36])) = $7
	CALL _ZdlPv($7)
	
.LABEL $label$9
	$7	 = *($4)
	if ( ($7 == 0) ){ goto $label$10 }
	*($4 + [4]) = $7
	CALL _ZdlPv($7)
	
.LABEL $label$10
	$global$0 = ($4 + [80])
	return (unreachable)
	
.LABEL $label$1
	CALL $105($4)
}

.data 17620 -> ["finish defer\00"]
.data 17611 -> ["runstake\00"]
.data 17291 -> ["active\00"]
.data 17595 -> ["finish prelock\00"]
.data 18436 -> ["cannot create objects in table of another contract\00"]
.data 17583 -> ["finish lock\00"]
.data 17932 -> ["write\00"]
.data 17793 -> ["updater cannot change primary key when modifying an object\00"]
.data 18043 -> ["subtraction overflow\00"]
.data 18021 -> ["subtraction underflow\00"]
.data 17973 -> ["attempt to subtract asset with different symbol\00"]
.data 17742 -> ["cannot modify objects in table of another contract\00"]
.data 17696 -> ["object passed to modify is not in multi_index\00"]
.data 17409 -> ["overdrawn balance\00"]
.data 17558 -> ["no accounts object found\00"]
void .FUNC $47 (int_32 $0, int_64 $1, int_32 $2)
{
	int_32 $3
	int_64 $4
	int_32 $5
	int_64 $6
	int_32 $7
	int_32 $8
	int_32 $9
	$3	 = ($global$0 - [192])
	$global$0 = $3
	CALL require_auth($1)
	*(($3 + [104])) = [0]
	*($3 + [88]) = (int_64)-1
	*($3 + [96]) = (int_64)0
	$4	 = *($0)
	*($3 + [72]) = $4
	*($3 + [80]) = $4
	$4	 = *($2)
	$5	 = CALL $48(($3 + [72]), $1, [17558])
	$6	 = *($5 + [8])
	CALL eosio_assert(((int_64)$6 >= (int_64)$4), [17409])     # .data 17558 -> ["no accounts object found"]     # .data 17409 -> ["overdrawn balance"]
	if ( ((int_64)$6 != (int_64)$4) ){ goto $label$2 }
	CALL $49(($3 + [72]), $5)
	goto $label$1 
	
.LABEL $label$2
	CALL eosio_assert(((int_32)*($5 + [24]) == (int_32)($3 + [72])), [17696])     # .data 17696 -> ["object passed to modify is not in multi_index"]
	CALL eosio_assert(((int_64)*($3 + [72]) == (int_64)CALL $fimport$5()), [17742])     # .data 17742 -> ["cannot modify objects in table of another contract"]
	$6 = *($5)
	$7	 = ($5 + [16])
	CALL eosio_assert(((int_64)*($2 + [8]) == (int_64)*($7)), [17973])     # .data 17973 -> ["attempt to subtract asset with different symbol"]
	$4	 = (int_64)
	*($5 + [8]) = $4(*($5 + [8]) - $4))
	CALL eosio_assert(((int_64)$4 > (int_64)-4611686018427387904), [18021])     # .data 18021 -> ["subtraction underflow"]
	CALL eosio_assert(((int_64)*($5 + [8]) < (int_64)4611686018427387904), [18043])     # .data 18043 -> ["subtraction overflow"]
	CALL eosio_assert(((int_64)$6 == (int_64)*($5)), [17793])     # .data 17793 -> ["updater cannot change primary key when modifying an object"]
	CALL eosio_assert([1], [17932])     # .data 17932 -> ["write"]
	CALL memcpy(($3 + [112]), $5, [8])
	CALL eosio_assert([1], [17932])     # .data 17932 -> ["write"]
	CALL memcpy((($3 + [112]) | [8]), ($5 + [8]), [8])
	*($3 + [32]) = *($7)
	CALL eosio_assert([1], [17932])     # .data 17932 -> ["write"]
	CALL memcpy((($3 + [112]) + [16]), ($3 + [32]), [8])
	CALL db_update_i64(*($5 + [28]), $1, ($3 + [112]), [24])
	$5	 = (($3 + [72]) + [16])
	if ( (uint_64)($6 <= *($5)) ){ goto $label$1 }
	*($5) = ( (int_64)-2 ? ((int_64)$6 + (int_64)1) : ((uint_64)$6 > (uint_64)(int_64)-3) )
	
.LABEL $label$1
	CALL prints([17583])     # .data 17583 -> ["finish lock"]
	*(($8 = (($3 + [32]) + [32]))) = [0]
	*($3 + [48]) = (int_64)-1
	*($3 + [56]) = (int_64)0
	$4	 = *($0)
	*($3 + [32]) = $4
	*($3 + [40]) = $4
	$6	 = CALL $50($0)
	*($3 + [24]) = $6
	CALL eosio_assert(((int_64)$4 == (int_64)CALL $fimport$5()), [18436])     # .data 18436 -> ["cannot create objects in table of another contract"]
	*(($5 = CALL _Znwj([56])) + [40]) = ($3 + [32])
	*($5 + [8]) = $1
	*($5) = $6
	*($5 + [16]) = *($2)
	*(($5 + [24])) = *(($2 + [8]))
	*($5 + [32]) = ((int_64)((uint_64)CALL current_time() / (uint_64)(int_64)1000000) & (int_64)4294967295)
	*($3 + [160]) = (($3 + [112]) + [40])
	*($3 + [156]) = ($3 + [112])
	*($3 + [152]) = ($3 + [112])
	*($3 + [168]) = ($3 + [152])
	*($3 + [180]) = ($5 + [8])
	*($3 + [176]) = $5
	*($3 + [184]) = ($5 + [16])
	*($3 + [188]) = ($5 + [32])
	CALL $51(($3 + [176]), ($3 + [168]))
	$4	 = *($5)
	$7	 = CALL db_store_i64(*($3 + [40]), (int_64)-5861687656668200960, $1, $4, ($3 + [112]), [40])
	*($5 + [44]) = $7
	if ( (uint_64)($4 <= *($3 + [48])) ){ goto $label$3 }
	*((($3 + [32]) + [16])) = ( (int_64)-2 ? ((int_64)$4 + (int_64)1) : ((uint_64)$4 > (uint_64)(int_64)-3) )
	
.LABEL $label$3
	*($3 + [176]) = $5
	$1	 = *($5)
	*($3 + [112]) = $1
	*($3 + [152]) = $7
	$9	 = ($3 + [60])
	$2	 = *($9)
	if ( ((uint_32)$2 >= (uint_32)*($8)) ){ goto $label$6 }
	*($2 + [8]) = $1
	*($2 + [16]) = $7
	*($3 + [176]) = [0]
	*($2) = $5
	*($9) = ($2 + [24])
	$5 = *($3 + [176])
	*($3 + [176]) = [0]
	if ( $5 ){ goto $label$5 }
	goto $label$4 
	
.LABEL $label$6
	CALL $52(($3 + [56]), ($3 + [176]), ($3 + [112]), ($3 + [152]))
	$5 = *($3 + [176])
	*($3 + [176]) = [0]
	if ( ($5 == 0) ){ goto $label$4 }
	
.LABEL $label$5
	CALL _ZdlPv($5)
	
.LABEL $label$4
	CALL prints([17595])     # .data 17595 -> ["finish prelock"]
	$4 = CALL $50($0)
	$1 = *($0)
	*($3 + [176]) = [17291]     # .data 17291 -> ["active"]
	*($3 + [180]) = CALL $109([17291])     # .data 17291 -> ["active"]
	*($3 + [16]) = *($3 + [176])
	*($3 + [120]) = *(CALL $10(($3 + [112]), ($3 + [16])))
	*($3 + [112]) = $1
	*($3 + [152]) = [17611]     # .data 17611 -> ["runstake"]
	*($3 + [156]) = CALL $109([17611])     # .data 17611 -> ["runstake"]
	*($3 + [8]) = *($3 + [152])
	*($3 + [176]) = *(CALL $10(($3 + [176]), ($3 + [8])))
	CALL $53((int_64)86400, $4, $1, ($3 + [112]), $0, ($3 + [176]), ($3 + [24]))
	CALL prints([17620])     # .data 17620 -> ["finish defer"]
	$2	 = *($3 + [56])
	if ( ($2 == 0) ){ goto $label$7 }
	$7	 = ($3 + [60])
	$5	 = *($7)
	if ( ((int_32)$5 == (int_32)$2) ){ goto $label$9 }
	
.LOOP $label$10:
	$5	 = ($5 + [-24])
	$0 = *($5)
	*($5) = [0]
	if ( ($0 == 0) ){ goto $label$11 }
	CALL _ZdlPv($0)
	
.LABEL $label$11
	if ( ((int_32)$2 != (int_32)$5) ){ goto $label$10 }
	$5 = *(($3 + [56]))
	goto $label$8 
	
.LABEL $label$9
	$5 = $2
	
.LABEL $label$8
	*($7) = $2
	CALL _ZdlPv($5)
	
.LABEL $label$7
	$2	 = *($3 + [96])
	if ( ($2 == 0) ){ goto $label$12 }
	$7	 = ($3 + [100])
	$5	 = *($7)
	if ( ((int_32)$5 == (int_32)$2) ){ goto $label$14 }
	
.LOOP $label$15:
	$5	 = ($5 + [-24])
	$0 = *($5)
	*($5) = [0]
	if ( ($0 == 0) ){ goto $label$16 }
	CALL _ZdlPv($0)
	
.LABEL $label$16
	if ( ((int_32)$2 != (int_32)$5) ){ goto $label$15 }
	$5 = *(($3 + [96]))
	goto $label$13 
	
.LABEL $label$14
	$5 = $2
	
.LABEL $label$13
	*($7) = $2
	CALL _ZdlPv($5)
	
.LABEL $label$12
	$global$0 = ($3 + [192])
}

void .FUNC $46 (int_32 $0, int_32 $1)
{
	int_32 $2
	int_32 $3
	int_32 $4
	int_32 $5
	int_32 $6
	int_32 $7
	$3	 = *($0 + [4])
	$2	 = *($0 + [8])
	if ( ((uint_32)($2 - $3) >= (uint_32)$1) ){ goto $label$5 }
	$4	 = *($0)
	$5	 = ($3 - $4)
	$6	 = ($5 + $1)
	if ( ((int_32)$6 <= (int_32)[-1]) ){ goto $label$3 }
	$7 = [2147483647]
	$2	 = ($2 - $4)
	if ( ((uint_32)$2 > (uint_32)[1073741822]) ){ goto $label$6 }
	$2	 = ($2 << [1])
	$7	 = ( $6 ? $2 : ($2 <= $6) )
	if ( ($7 == 0) ){ goto $label$4 }
	
.LABEL $label$6
	$2 = CALL _Znwj($7)
	goto $label$2 
	
.LABEL $label$5
	$0 = ($0 + [4])
	
.LOOP $label$7:
	*($3) = [0]
	$3	 = (*($0) + [1])
	*($0) = $3
	$1	 = ($1 + [-1])
	if ( $1 ){ goto $label$7 }
	goto $label$1 
	
.LABEL $label$4
	$7 = [0]
	$2 = [0]
	goto $label$2 
	
.LABEL $label$3
	CALL $105($0)
	
.LABEL $label$2
	$7 = ($2 + $7)
	$4 = (($3 + $1) - $4)
	$5	 = ($2 + $5)
	$3 = $5
	
.LOOP $label$8:
	*($3) = [0]
	$3 = ($3 + [1])
	$1	 = ($1 + [-1])
	if ( $1 ){ goto $label$8 }
	$4 = ($2 + $4)
	$1	 = *($0)
	$6	 = ($0 + [4])
	$3	 = (*($6) - $1)
	$2 = ($5 - $3)
	if ( ((int_32)$3 < (int_32)[1]) ){ goto $label$9 }
	CALL memcpy($2, $1, $3)
	$1 = *($0)
	
.LABEL $label$9
	*($0) = $2
	*($6) = $4
	*(($0 + [8])) = $7
	if ( ($1 == 0) ){ goto $label$1 }
	CALL _ZdlPv($1)
	return 
	
.LABEL $label$1
	(unreachable)
}

void .FUNC $45 (int_32 $0, int_32 $1, int_32 $2, int_32 $3)
{
	int_32 $4
	int_32 $5
	int_32 $6
	int_32 $7
	int_32 $8
	$4	 = *($0)
	$5	 = ((int_32)(*($0 + [4]) - $4) / (int_32)[24])
	$6	 = ($5 + [1])
	if ( ((uint_32)$6 >= (uint_32)[178956971]) ){ goto $label$2 }
	$7 = [178956970]
	$4	 = ((int_32)(*($0 + [8]) - $4) / (int_32)[24])
	if ( ((uint_32)$4 > (uint_32)[89478484]) ){ goto $label$4 }
	$7	 = ($4 << [1])
	$7	 = ( $6 ? $7 : ($7 <= $6) )
	if ( ($7 == 0) ){ goto $label$3 }
	
.LABEL $label$4
	$4 = CALL _Znwj(((int_32)$7 * (int_32)[24]))
	goto $label$1 
	
.LABEL $label$3
	$7 = [0]
	$4 = [0]
	goto $label$1 
	
.LABEL $label$2
	CALL $105($0)
	
.LABEL $label$1
	$6 = *($1)
	*($1) = [0]
	*(($1 = ($4 + ($8 = ((int_32)$5 * (int_32)[24]))))) = $6
	*($1 + [8]) = *($2)
	*($1 + [16]) = *($3)
	$5 = ($4 + ((int_32)$7 * (int_32)[24]))
	$6 = ($1 + [24])
	$7	 = *($0)
	$2	 = *(($0 + [4]))
	if ( ((int_32)$2 == (int_32)$7) ){ goto $label$6 }
	$1 = (($4 + $8) + [-24])
	
.LOOP $label$7:
	$4	 = ($2 + [-24])
	$3 = *($4)
	*($4) = [0]
	*($1) = $3
	*(($1 + [16])) = *(($2 + [-8]))
	*(($1 + [8])) = *(($2 + [-16]))
	$1 = ($1 + [-24])
	$2 = $4
	if ( ((int_32)$7 != (int_32)$4) ){ goto $label$7 }
	$1 = ($1 + [24])
	$7 = *(($0 + [4]))
	$2 = *($0)
	goto $label$5 
	
.LABEL $label$6
	$2 = $7
	
.LABEL $label$5
	*($0) = $1
	*(($0 + [4])) = $6
	*(($0 + [8])) = $5
	if ( ((int_32)$7 == (int_32)$2) ){ goto $label$8 }
	
.LOOP $label$9:
	$7	 = ($7 + [-24])
	$1 = *($7)
	*($7) = [0]
	if ( ($1 == 0) ){ goto $label$10 }
	CALL _ZdlPv($1)
	
.LABEL $label$10
	if ( ((int_32)$2 != (int_32)$7) ){ goto $label$9 }
	
.LABEL $label$8
	if ( ($2 == 0) ){ goto $label$11 }
	CALL _ZdlPv($2)
	
.LABEL $label$11
	(unreachable)
}

.data 18431 -> ["read\00"]
.data 18408 -> ["error reading iterator\00"]
int_32 .FUNC $44 (int_32 $0, int_32 $1)
{
	int_32 $2
	int_32 $3
	int_32 $4
	int_32 $5
	int_32 $6
	int_64 $7
	int_32 $8
	$2	 = ($global$0 - [32])
	$3 = $2
	$global$0 = $2
	$5	 = *(($0 + [28]))
	$4	 = *($0 + [24])
	if ( ((int_32)$4 == (int_32)$5) ){ goto $label$1 }
	
.LOOP $label$3:
	if ( ((int_32)*(($5 + [-8])) == (int_32)$1) ){ goto $label$2 }
	$5	 = ($5 + [-24])
	if ( ((int_32)$4 != (int_32)$5) ){ goto $label$3 }
	goto $label$1 
	
.LABEL $label$2
	if ( ((int_32)$4 == (int_32)$5) ){ goto $label$1 }
	$5 = *(($5 + [-24]))
	$global$0 = ($3 + [32])
	return $5
	
.LABEL $label$1
	$4	 = CALL db_get_i64($1, [0], [0])
	CALL eosio_assert(((int_32)uint_32($4 >> [31]) ^ (int_32)[1]), [18408])     # .data 18408 -> ["error reading iterator"]
	if ( ($4 <= [513]) ){ goto $label$5 }
	$2 = CALL $114($4)
	goto $label$4 
	
.LABEL $label$5
	$2	 = ($2 - (($4 + [15]) & [-16]))
	$global$0 = $2
	
.LABEL $label$4
	CALL db_get_i64($1, $2, $4)
	*(($5 = CALL _Znwj([40])) + [16]) = (int_64)0
	*($5 + [8]) = (int_64)0
	*($5 + [24]) = $0
	CALL eosio_assert(((uint_32)$4 > (uint_32)[7]), [18431])     # .data 18431 -> ["read"]
	CALL memcpy($5, $2, [8])
	$6	 = ($4 & [-8])
	CALL eosio_assert(((int_32)$6 != (int_32)[8]), [18431])     # .data 18431 -> ["read"]
	CALL memcpy(($5 + [8]), ($2 + [8]), [8])
	*($3 + [24]) = (int_64)0
	CALL eosio_assert(((int_32)$6 != (int_32)[16]), [18431])     # .data 18431 -> ["read"]
	CALL memcpy(($3 + [24]), ($2 + [16]), [8])
	*($5 + [16]) = *($3 + [24])
	*($5 + [28]) = $1
	*($3 + [16]) = $5
	$7	 = *($5)
	*($3 + [24]) = $7
	*($3 + [12]) = $1
	$8	 = ($0 + [28])
	$6	 = *($8)
	if ( ((uint_32)$6 >= (uint_32)*(($0 + [32]))) ){ goto $label$8 }
	*($6 + [8]) = $7
	*($6 + [16]) = $1
	*($3 + [16]) = [0]
	*($6) = $5
	*($8) = ($6 + [24])
	if ( ((uint_32)$4 >= (uint_32)[513]) ){ goto $label$7 }
	goto $label$6 
	
.LABEL $label$8
	CALL $45(($0 + [24]), ($3 + [16]), ($3 + [24]), ($3 + [12]))
	if ( ($4 <= [513]) ){ goto $label$6 }
	
.LABEL $label$7
	CALL $118($2)
	
.LABEL $label$6
	$1 = *($3 + [16])
	*($3 + [16]) = [0]
	if ( ($1 == 0) ){ goto $label$9 }
	CALL _ZdlPv($1)
	
.LABEL $label$9
	$global$0 = ($3 + [32])
	return $5
}

.data 17291 -> ["active\00"]
.data 17793 -> ["updater cannot change primary key when modifying an object\00"]
.data 17914 -> ["addition overflow\00"]
.data 17895 -> ["addition underflow\00"]
.data 17852 -> ["attempt to add asset with different symbol\00"]
.data 17742 -> ["cannot modify objects in table of another contract\00"]
.data 17696 -> ["object passed to modify is not in multi_index\00"]
.data 17257 -> ["quantity exceeds available supply\00"]
.data 17231 -> ["symbol precision mismatch\00"]
.data 17202 -> ["must issue positive quantity\00"]
.data 17185 -> ["invalid quantity\00"]
.data 17125 -> ["token with symbol does not exist, create token before issue\00"]
.data 18357 -> ["object passed to iterator_to is not in multi_index\00"]
.data 17096 -> ["memo has more than 256 bytes\00"]
.data 17020 -> ["invalid symbol name\00"]
void .FUNC $8 (int_32 $0, int_64 $1, int_32 $2, int_32 $3)
{
	int_32 $4
	int_32 $5
	int_64 $6
	int_64 $7
	int_64 $8
	int_64 $9
	int_32 $10
	int_32 $11
	int_32 $12
	int_32 $13
	$4	 = ($global$0 - [224])
	$global$0 = $4
	$5 = [0]
	$6	 = *($2 + [8])
	$7	 = (uint_64)$6 >> (uint_64)(int_64)8
	$8 = $7)
	
.LOOP $label$3:
	if ( ((uint_32)(((CASTING uint_32)(uint_64 $8) << [24]) + [-1073741825]) > (uint_32)[452984830]) ){ goto $label$2 }
	$9 = (uint_64)$8 >> (uint_64)(int_64)8)
	if ( ((int_64)((int_64)$8 & (int_64)65280) == (int_64)0) ){ goto $label$4 }
	$8 = $9
	$10 = [1]
	$11	 = $5
	$5 = ($11 + [1])
	if ( ((int_32)$11 < (int_32)[6]) ){ goto $label$3 }
	goto $label$1 
	
.LABEL $label$4
	$8 = $9
	
.LOOP $label$5:
	if ( ((int_64)((int_64)$8 & (int_64)65280) != (int_64)0) ){ goto $label$2 }
	$8 = (uint_64)$8 >> (uint_64)(int_64)8)
	$10 = ((int_32)$5 < (int_32)[6])
	$11	 = ($5 + [1])
	$5 = $11
	if ( $10 ){ goto $label$5 }
	$10 = [1]
	$5 = ($11 + [1])
	if ( ((int_32)$11 < (int_32)[6]) ){ goto $label$3 }
	goto $label$1 
	
.LABEL $label$2
	$10 = [0]
	
.LABEL $label$1
	CALL eosio_assert($10, [17020])     # .data 17020 -> ["invalid symbol name"]
	$5	 = *($3)
	if ( ($5 & [1]) ){ goto $label$7 }
	$5 = uint_32($5 >> [1])
	goto $label$6 
	
.LABEL $label$7
	$5 = *($3 + [4])
	
.LABEL $label$6
	CALL eosio_assert(($5 <= [257]), [17096])     # .data 17096 -> ["memo has more than 256 bytes"]
	$10 = [0]
	*((($4 + [88]) + [32])) = [0]
	*($4 + [104]) = (int_64)-1
	*($4 + [112]) = (int_64)0
	$8	 = *($0)
	*($4 + [88]) = $8
	*($4 + [96]) = $7
	$11 = [0]
	$5	 = CALL db_find_i64($8, $7, (int_64)-4157508551318700032, $6)
	if ( ((int_32)$5 < (int_32)[0]) ){ goto $label$8 }
	$11	 = CALL $4(($4 + [88]), $5)
	CALL eosio_assert(((int_32)*($11 + [40]) == (int_32)($4 + [88])), [18357])     # .data 18357 -> ["object passed to iterator_to is not in multi_index"]
	
.LABEL $label$8
	CALL eosio_assert(((int_32)$11 != (int_32)[0]), [17125])     # .data 17125 -> ["token with symbol does not exist, create token before issue"]
	CALL require_auth(*($11 + [32]))
	$12 = ($11 + [32])
	$8	 = *($2)
	if ( ((uint_64)((int_64)$8 + (int_64)4611686018427387903) > (uint_64)(int_64)9223372036854775806) ){ goto $label$9 }
	$5 = [0]
	
.LOOP $label$11:
	if ( ((uint_32)(((CASTING uint_32)(uint_64 $7) << [24]) + [-1073741825]) > (uint_32)[452984830]) ){ goto $label$10 }
	$9 = (uint_64)$7 >> (uint_64)(int_64)8)
	if ( ((int_64)((int_64)$7 & (int_64)65280) == (int_64)0) ){ goto $label$12 }
	$7 = $9
	$10 = [1]
	$13	 = $5
	$5 = ($13 + [1])
	if ( ((int_32)$13 < (int_32)[6]) ){ goto $label$11 }
	goto $label$9 
	
.LABEL $label$12
	$7 = $9
	
.LOOP $label$13:
	if ( ((int_64)((int_64)$7 & (int_64)65280) != (int_64)0) ){ goto $label$10 }
	$7 = (uint_64)$7 >> (uint_64)(int_64)8)
	$10 = ((int_32)$5 < (int_32)[6])
	$13	 = ($5 + [1])
	$5 = $13
	if ( $10 ){ goto $label$13 }
	$10 = [1]
	$5 = ($13 + [1])
	if ( ((int_32)$13 < (int_32)[6]) ){ goto $label$11 }
	goto $label$9 
	
.LABEL $label$10
	$10 = [0]
	
.LABEL $label$9
	CALL eosio_assert($10, [17185])     # .data 17185 -> ["invalid quantity"]
	CALL eosio_assert(((int_64)$8 > (int_64)0), [17202])     # .data 17202 -> ["must issue positive quantity"]
	CALL eosio_assert(((int_64)$6 == (int_64)*($11 + [8])), [17231])     # .data 17231 -> ["symbol precision mismatch"]
	CALL eosio_assert(((int_64)$8 <= (int_64))(*($11 + [16]) - *($11))), [17257])     # .data 17257 -> ["quantity exceeds available supply"]
	$9 = *($0)
	CALL eosio_assert(((int_32)*($11 + [40]) == (int_32)($4 + [88])), [17696])     # .data 17696 -> ["object passed to modify is not in multi_index"]
	CALL eosio_assert(((int_64)*($4 + [88]) == (int_64)CALL $fimport$5()), [17742])     # .data 17742 -> ["cannot modify objects in table of another contract"]
	$7	 = *($11 + [8])
	CALL eosio_assert(((int_64)$6 == (int_64)$7), [17852])     # .data 17852 -> ["attempt to add asset with different symbol"]
	$8	 = ((int_64)*($11) + (int_64)$8)
	*($11) = $8
	CALL eosio_assert(((int_64)$8 > (int_64)-4611686018427387904), [17895])     # .data 17895 -> ["addition underflow"]
	CALL eosio_assert(((int_64)*($11) < (int_64)4611686018427387904), [17914])     # .data 17914 -> ["addition overflow"]
	CALL eosio_assert(((int_64)$7 == (int_64)*($11 + [8])), [17793])     # .data 17793 -> ["updater cannot change primary key when modifying an object"]
	*($4 + [192]) = (($4 + [128]) + [40])
	*($4 + [188]) = ($4 + [128])
	*($4 + [184]) = ($4 + [128])
	*($4 + [200]) = ($4 + [184])
	*($4 + [212]) = ($11 + [16])
	*($4 + [208]) = $11
	*($4 + [216]) = $12
	CALL $5(($4 + [208]), ($4 + [200]))
	CALL db_update_i64(*($11 + [44]), $9, ($4 + [128]), [40])
	$5	 = (($4 + [88]) + [16])
	if ( (uint_64)($7 <= *($5)) ){ goto $label$14 }
	*($5) = ( (int_64)-2 ? ((int_64)$7 + (int_64)1) : ((uint_64)$7 > (uint_64)(int_64)-3) )
	
.LABEL $label$14
	$5	 = ($2 + [8])
	$9	 = *($5)
	*((($4 + [72]) + [8])) = $9
	$8 = *($12)
	$7 = *($2)
	*((($4 + [8]) + [8])) = $9
	*($4 + [72]) = $7
	*($4 + [8]) = $7
	CALL $9($0, $8, ($4 + [8]), $8)
	$8	 = *($12)
	if ( ((int_64)$8 == (int_64)$1) ){ goto $label$15 }
	$7 = *($0)
	*($4 + [208]) = [17291]     # .data 17291 -> ["active"]
	*($4 + [212]) = CALL $109([17291])     # .data 17291 -> ["active"]
	*($4) = *($4 + [208])
	$9 = *(CALL $10(($4 + [128]), $4))
	*(($10 = (($4 + [24]) + [24]))) = *($5)
	*($4 + [32]) = $1
	*($4 + [24]) = *($12)
	*($4 + [40]) = *($2)
	CALL $103(($4 + [56]), $3)
	*(($5 = CALL _Znwj([16]))) = $8
	*($5 + [8]) = $9
	*((($4 + [128]) + [24])) = *($10)
	$10	 = (($4 + [24]) + [40])
	*(($11 = (($4 + [128]) + [40]))) = *($10)
	*($10) = [0]
	*($4 + [208]) = $5
	$5	 = ($5 + [16])
	*($4 + [216]) = $5
	*($4 + [212]) = $5
	*($4 + [128]) = *($4 + [24])
	*($4 + [136]) = *($4 + [32])
	*($4 + [144]) = *($4 + [40])
	*($4 + [160]) = *($4 + [56])
	*($4 + [56]) = (int_64)0
	CALL $11($7, (int_64)-3617168760277827584, ($4 + [208]), ($4 + [128]))
	if ( ((*($4 + [160]) & [1]) == 0) ){ goto $label$16 }
	CALL _ZdlPv(*($11))
	
.LABEL $label$16
	$5	 = *($4 + [208])
	if ( ($5 == 0) ){ goto $label$17 }
	*($4 + [212]) = $5
	CALL _ZdlPv($5)
	
.LABEL $label$17
	if ( ((*(($4 + [56])) & [1]) == 0) ){ goto $label$15 }
	CALL _ZdlPv(*(($4 + [64])))
	
.LABEL $label$15
	$11	 = *($4 + [112])
	if ( ($11 == 0) ){ goto $label$18 }
	$13	 = ($4 + [116])
	$5	 = *($13)
	if ( ((int_32)$5 == (int_32)$11) ){ goto $label$20 }
	
.LOOP $label$21:
	$5	 = ($5 + [-24])
	$10 = *($5)
	*($5) = [0]
	if ( ($10 == 0) ){ goto $label$22 }
	CALL _ZdlPv($10)
	
.LABEL $label$22
	if ( ((int_32)$11 != (int_32)$5) ){ goto $label$21 }
	$5 = *(($4 + [112]))
	goto $label$19 
	
.LABEL $label$20
	$5 = $11
	
.LABEL $label$19
	*($13) = $11
	CALL _ZdlPv($5)
	
.LABEL $label$18
	$global$0 = ($4 + [224])
}

.data 18436 -> ["cannot create objects in table of another contract\00"]
.data 17793 -> ["updater cannot change primary key when modifying an object\00"]
.data 17914 -> ["addition overflow\00"]
.data 17895 -> ["addition underflow\00"]
.data 17852 -> ["attempt to add asset with different symbol\00"]
.data 17742 -> ["cannot modify objects in table of another contract\00"]
.data 17696 -> ["object passed to modify is not in multi_index\00"]
.data 17938 -> ["cannot pass end iterator to modify\00"]
.data 18357 -> ["object passed to iterator_to is not in multi_index\00"]
void .FUNC $9 (int_32 $0, int_64 $1, int_32 $2, int_64 $3)
{
	int_32 $4
	int_32 $5
	int_64 $6
	int_32 $7
	int_32 $8
	$4	 = ($global$0 - [112])
	$global$0 = $4
	*(($5 = (($4 + [8]) + [32]))) = [0]
	*($4 + [24]) = (int_64)-1
	*($4 + [32]) = (int_64)0
	$6	 = *($0)
	*($4 + [8]) = $6
	*($4 + [16]) = $1
	$0	 = CALL db_find_i64($6, $1, (int_64)3607749779137757184, *($2 + [8]))
	if ( ((int_32)$0 < (int_32)[0]) ){ goto $label$4 }
	$0	 = CALL $12(($4 + [8]), $0)
	CALL eosio_assert(((int_32)*($0 + [32]) == (int_32)($4 + [8])), [18357])     # .data 18357 -> ["object passed to iterator_to is not in multi_index"]
	CALL eosio_assert([1], [17938])     # .data 17938 -> ["cannot pass end iterator to modify"]
	CALL eosio_assert(((int_32)*($0 + [32]) == (int_32)($4 + [8])), [17696])     # .data 17696 -> ["object passed to modify is not in multi_index"]
	CALL eosio_assert(((int_64)*($4 + [8]) == (int_64)CALL $fimport$5()), [17742])     # .data 17742 -> ["cannot modify objects in table of another contract"]
	$1	 = *($0 + [8])
	CALL eosio_assert(((int_64)*(($2 + [8])) == (int_64)$1), [17852])     # .data 17852 -> ["attempt to add asset with different symbol"]
	$6	 = ((int_64)*($0) + (int_64)*($2))
	*($0) = $6
	CALL eosio_assert(((int_64)$6 > (int_64)-4611686018427387904), [17895])     # .data 17895 -> ["addition underflow"]
	CALL eosio_assert(((int_64)*($0) < (int_64)4611686018427387904), [17914])     # .data 17914 -> ["addition overflow"]
	CALL eosio_assert(((int_64)$1 == (int_64)*($0 + [8])), [17793])     # .data 17793 -> ["updater cannot change primary key when modifying an object"]
	*($4 + [88]) = (($4 + [48]) + [32])
	*($4 + [84]) = ($4 + [48])
	*($4 + [80]) = ($4 + [48])
	*($4 + [96]) = ($4 + [80])
	*($4 + [108]) = ($0 + [16])
	*($4 + [104]) = $0
	CALL $13(($4 + [104]), ($4 + [96]))
	CALL db_update_i64(*($0 + [36]), $3, ($4 + [48]), [32])
	$0	 = (($4 + [8]) + [16])
	if ( (uint_64)($1 <= *($0)) ){ goto $label$3 }
	*($0) = ( (int_64)-2 ? ((int_64)$1 + (int_64)1) : ((uint_64)$1 > (uint_64)(int_64)-3) )
	$5	 = *($4 + [32])
	if ( $5 ){ goto $label$2 }
	goto $label$1 
	
.LABEL $label$4
	*($4) = $2
	*($4 + [80]) = $3
	CALL eosio_assert(((int_64)$6 == (int_64)CALL $fimport$5()), [18436])     # .data 18436 -> ["cannot create objects in table of another contract"]
	*($4 + [52]) = $4
	*($4 + [48]) = ($4 + [8])
	*($4 + [56]) = ($4 + [80])
	*(($0 = CALL _Znwj([48])) + [8]) = (int_64)0
	*($0) = (int_64)0
	*($0 + [16]) = (int_64)0
	*($0 + [24]) = (int_64)0
	*($0 + [32]) = ($4 + [8])
	CALL $14(($4 + [48]), $0)
	*($4 + [104]) = $0
	$1	 = *($0 + [8])
	*($4 + [48]) = $1
	$7	 = *($0 + [36])
	*($4 + [96]) = $7
	$8	 = ($4 + [36])
	$2	 = *($8)
	if ( ((uint_32)$2 >= (uint_32)*($5)) ){ goto $label$6 }
	*($2 + [8]) = $1
	*($2 + [16]) = $7
	*($4 + [104]) = [0]
	*($2) = $0
	*($8) = ($2 + [24])
	$0 = *($4 + [104])
	*($4 + [104]) = [0]
	if ( $0 ){ goto $label$5 }
	goto $label$3 
	
.LABEL $label$6
	CALL $15(($4 + [32]), ($4 + [104]), ($4 + [48]), ($4 + [96]))
	$0 = *($4 + [104])
	*($4 + [104]) = [0]
	if ( ($0 == 0) ){ goto $label$3 }
	
.LABEL $label$5
	CALL _ZdlPv($0)
	
.LABEL $label$3
	$5	 = *($4 + [32])
	if ( ($5 == 0) ){ goto $label$1 }
	
.LABEL $label$2
	$7	 = ($4 + [36])
	$0	 = *($7)
	if ( ((int_32)$0 == (int_32)$5) ){ goto $label$8 }
	
.LOOP $label$9:
	$0	 = ($0 + [-24])
	$2 = *($0)
	*($0) = [0]
	if ( ($2 == 0) ){ goto $label$10 }
	CALL _ZdlPv($2)
	
.LABEL $label$10
	if ( ((int_32)$5 != (int_32)$0) ){ goto $label$9 }
	$0 = *(($4 + [32]))
	goto $label$7 
	
.LABEL $label$8
	$0 = $5
	
.LABEL $label$7
	*($7) = $5
	CALL _ZdlPv($0)
	
.LABEL $label$1
	$global$0 = ($4 + [112])
}

.data 18408 -> ["error reading iterator\00"]
int_32 .FUNC $6 (int_32 $0, int_32 $1)
{
	int_32 $2
	int_32 $3
	int_32 $4
	int_32 $5
	int_64 $6
	int_32 $7
	int_32 $8
	$2	 = ($global$0 - [48])
	$3 = $2
	$global$0 = $2
	$5	 = *(($0 + [28]))
	$4	 = *($0 + [24])
	if ( ((int_32)$4 == (int_32)$5) ){ goto $label$1 }
	
.LOOP $label$3:
	if ( ((int_32)*(($5 + [-8])) == (int_32)$1) ){ goto $label$2 }
	$5	 = ($5 + [-24])
	if ( ((int_32)$4 != (int_32)$5) ){ goto $label$3 }
	goto $label$1 
	
.LABEL $label$2
	if ( ((int_32)$4 == (int_32)$5) ){ goto $label$1 }
	$5 = *(($5 + [-24]))
	$global$0 = ($3 + [48])
	return $5
	
.LABEL $label$1
	$4	 = CALL db_get_i64($1, [0], [0])
	CALL eosio_assert(((int_32)uint_32($4 >> [31]) ^ (int_32)[1]), [18408])     # .data 18408 -> ["error reading iterator"]
	if ( ($4 <= [513]) ){ goto $label$5 }
	$2 = CALL $114($4)
	goto $label$4 
	
.LABEL $label$5
	$2	 = ($2 - (($4 + [15]) & [-16]))
	$global$0 = $2
	
.LABEL $label$4
	CALL db_get_i64($1, $2, $4)
	*($3 + [12]) = $2
	*($3 + [8]) = $2
	*($3 + [16]) = ($2 + $4)
	*(($5 = CALL _Znwj([56])) + [8]) = (int_64)0
	*($5) = (int_64)0
	*($5 + [16]) = (int_64)0
	*($5 + [24]) = (int_64)0
	*($5 + [40]) = $0
	*($3 + [24]) = ($3 + [8])
	*($3 + [36]) = ($5 + [16])
	*($3 + [32]) = $5
	*($3 + [40]) = ($5 + [32])
	CALL $80(($3 + [32]), ($3 + [24]))
	*($5 + [44]) = $1
	*($3 + [24]) = $5
	$6	 = *($5 + [8])
	*($3 + [32]) = $6
	*($3 + [4]) = $1
	$7	 = ($0 + [28])
	$8	 = *($7)
	if ( ((uint_32)$8 >= (uint_32)*(($0 + [32]))) ){ goto $label$8 }
	*($8 + [8]) = $6
	*($8 + [16]) = $1
	*($3 + [24]) = [0]
	*($8) = $5
	*($7) = ($8 + [24])
	if ( ((uint_32)$4 >= (uint_32)[513]) ){ goto $label$7 }
	goto $label$6 
	
.LABEL $label$8
	CALL $81(($0 + [24]), ($3 + [24]), ($3 + [32]), ($3 + [4]))
	if ( ($4 <= [513]) ){ goto $label$6 }
	
.LABEL $label$7
	CALL $118($2)
	
.LABEL $label$6
	$1 = *($3 + [24])
	*($3 + [24]) = [0]
	if ( ($1 == 0) ){ goto $label$9 }
	CALL _ZdlPv($1)
	
.LABEL $label$9
	$global$0 = ($3 + [48])
	return $5
}

void .FUNC $7 (int_32 $0, int_32 $1, int_32 $2, int_32 $3)
{
	int_32 $4
	int_32 $5
	int_32 $6
	int_32 $7
	int_32 $8
	$4	 = *($0)
	$5	 = ((int_32)(*($0 + [4]) - $4) / (int_32)[24])
	$6	 = ($5 + [1])
	if ( ((uint_32)$6 >= (uint_32)[178956971]) ){ goto $label$2 }
	$7 = [178956970]
	$4	 = ((int_32)(*($0 + [8]) - $4) / (int_32)[24])
	if ( ((uint_32)$4 > (uint_32)[89478484]) ){ goto $label$4 }
	$7	 = ($4 << [1])
	$7	 = ( $6 ? $7 : ($7 <= $6) )
	if ( ($7 == 0) ){ goto $label$3 }
	
.LABEL $label$4
	$4 = CALL _Znwj(((int_32)$7 * (int_32)[24]))
	goto $label$1 
	
.LABEL $label$3
	$7 = [0]
	$4 = [0]
	goto $label$1 
	
.LABEL $label$2
	CALL $105($0)
	
.LABEL $label$1
	$6 = *($1)
	*($1) = [0]
	*(($1 = ($4 + ($8 = ((int_32)$5 * (int_32)[24]))))) = $6
	*($1 + [8]) = *($2)
	*($1 + [16]) = *($3)
	$5 = ($4 + ((int_32)$7 * (int_32)[24]))
	$6 = ($1 + [24])
	$7	 = *($0)
	$2	 = *(($0 + [4]))
	if ( ((int_32)$2 == (int_32)$7) ){ goto $label$6 }
	$1 = (($4 + $8) + [-24])
	
.LOOP $label$7:
	$4	 = ($2 + [-24])
	$3 = *($4)
	*($4) = [0]
	*($1) = $3
	*(($1 + [16])) = *(($2 + [-8]))
	*(($1 + [8])) = *(($2 + [-16]))
	$1 = ($1 + [-24])
	$2 = $4
	if ( ((int_32)$7 != (int_32)$4) ){ goto $label$7 }
	$1 = ($1 + [24])
	$7 = *(($0 + [4]))
	$2 = *($0)
	goto $label$5 
	
.LABEL $label$6
	$2 = $7
	
.LABEL $label$5
	*($0) = $1
	*(($0 + [4])) = $6
	*(($0 + [8])) = $5
	if ( ((int_32)$7 == (int_32)$2) ){ goto $label$8 }
	
.LOOP $label$9:
	$7	 = ($7 + [-24])
	$1 = *($7)
	*($7) = [0]
	if ( ($1 == 0) ){ goto $label$10 }
	CALL _ZdlPv($1)
	
.LABEL $label$10
	if ( ((int_32)$2 != (int_32)$7) ){ goto $label$9 }
	
.LABEL $label$8
	if ( ($2 == 0) ){ goto $label$11 }
	CALL _ZdlPv($2)
	
.LABEL $label$11
	(unreachable)
}

.data 18408 -> ["error reading iterator\00"]
int_32 .FUNC $4 (int_32 $0, int_32 $1)
{
	int_32 $2
	int_32 $3
	int_32 $4
	int_32 $5
	int_64 $6
	int_32 $7
	int_32 $8
	$2	 = ($global$0 - [48])
	$3 = $2
	$global$0 = $2
	$5	 = *(($0 + [28]))
	$4	 = *($0 + [24])
	if ( ((int_32)$4 == (int_32)$5) ){ goto $label$1 }
	
.LOOP $label$3:
	if ( ((int_32)*(($5 + [-8])) == (int_32)$1) ){ goto $label$2 }
	$5	 = ($5 + [-24])
	if ( ((int_32)$4 != (int_32)$5) ){ goto $label$3 }
	goto $label$1 
	
.LABEL $label$2
	if ( ((int_32)$4 == (int_32)$5) ){ goto $label$1 }
	$5 = *(($5 + [-24]))
	$global$0 = ($3 + [48])
	return $5
	
.LABEL $label$1
	$4	 = CALL db_get_i64($1, [0], [0])
	CALL eosio_assert(((int_32)uint_32($4 >> [31]) ^ (int_32)[1]), [18408])     # .data 18408 -> ["error reading iterator"]
	if ( ($4 <= [513]) ){ goto $label$5 }
	$2 = CALL $114($4)
	goto $label$4 
	
.LABEL $label$5
	$2	 = ($2 - (($4 + [15]) & [-16]))
	$global$0 = $2
	
.LABEL $label$4
	CALL db_get_i64($1, $2, $4)
	*($3 + [12]) = $2
	*($3 + [8]) = $2
	*($3 + [16]) = ($2 + $4)
	*(($5 = CALL _Znwj([56])) + [8]) = (int_64)0
	*($5) = (int_64)0
	*($5 + [16]) = (int_64)0
	*($5 + [24]) = (int_64)0
	*($5 + [40]) = $0
	*($3 + [24]) = ($3 + [8])
	*($3 + [36]) = ($5 + [16])
	*($3 + [32]) = $5
	*($3 + [40]) = ($5 + [32])
	CALL $80(($3 + [32]), ($3 + [24]))
	*($5 + [44]) = $1
	*($3 + [24]) = $5
	$6	 = *($5 + [8])
	*($3 + [32]) = $6
	*($3 + [4]) = $1
	$7	 = ($0 + [28])
	$8	 = *($7)
	if ( ((uint_32)$8 >= (uint_32)*(($0 + [32]))) ){ goto $label$8 }
	*($8 + [8]) = $6
	*($8 + [16]) = $1
	*($3 + [24]) = [0]
	*($8) = $5
	*($7) = ($8 + [24])
	if ( ((uint_32)$4 >= (uint_32)[513]) ){ goto $label$7 }
	goto $label$6 
	
.LABEL $label$8
	CALL $7(($0 + [24]), ($3 + [24]), ($3 + [32]), ($3 + [4]))
	if ( ($4 <= [513]) ){ goto $label$6 }
	
.LABEL $label$7
	CALL $118($2)
	
.LABEL $label$6
	$1 = *($3 + [24])
	*($3 + [24]) = [0]
	if ( ($1 == 0) ){ goto $label$9 }
	CALL _ZdlPv($1)
	
.LABEL $label$9
	$global$0 = ($3 + [48])
	return $5
}

.data 17932 -> ["write\00"]
void .FUNC $5 (int_32 $0, int_32 $1)
{
	int_32 $2
	int_32 $3
	int_32 $4
	int_32 $5
	$2	 = ($global$0 - [16])
	$global$0 = $2
	$3 = *($0)
	$4	 = *($1)
	CALL eosio_assert(((int_32)(*($4 + [8]) - *($4 + [4])) > (int_32)[7]), [17932])     # .data 17932 -> ["write"]
	CALL memcpy(*($4 + [4]), $3, [8])
	$5	 = (*($4 + [4]) + [8])
	*($4 + [4]) = $5
	*($2 + [8]) = *($3 + [8])
	CALL eosio_assert(((int_32)(*($4 + [8]) - $5) > (int_32)[7]), [17932])     # .data 17932 -> ["write"]
	CALL memcpy(*($4 + [4]), ($2 + [8]), [8])
	*($4 + [4]) = (*($4 + [4]) + [8])
	$3 = *($0 + [4])
	$4	 = *($1)
	CALL eosio_assert(((int_32)(*($4 + [8]) - *($4 + [4])) > (int_32)[7]), [17932])     # .data 17932 -> ["write"]
	CALL memcpy(*($4 + [4]), $3, [8])
	$5	 = (*($4 + [4]) + [8])
	*($4 + [4]) = $5
	*($2 + [8]) = *($3 + [8])
	CALL eosio_assert(((int_32)(*($4 + [8]) - $5) > (int_32)[7]), [17932])     # .data 17932 -> ["write"]
	CALL memcpy(*($4 + [4]), ($2 + [8]), [8])
	*($4 + [4]) = (*($4 + [4]) + [8])
	$0 = *($0 + [8])
	$4	 = *($1)
	CALL eosio_assert(((int_32)(*($4 + [8]) - *($4 + [4])) > (int_32)[7]), [17932])     # .data 17932 -> ["write"]
	CALL memcpy(*($4 + [4]), $0, [8])
	*($4 + [4]) = (*($4 + [4]) + [8])
	$global$0 = ($2 + [16])
}

void .FUNC $2 (int_32 $0)
{
	if ( ((*([0] + [8204]) & [1]) == 0) ){ goto $label$1 }
	CALL _ZdlPv(*([0] + [8212]))
	
.LABEL $label$1
}

.data 18436 -> ["cannot create objects in table of another contract\00"]
.data 17083 -> ["add\00"]
.data 17647 -> ["magnitude of asset amount must be less than 2^62\00"]
.data 17793 -> ["updater cannot change primary key when modifying an object\00"]
.data 17742 -> ["cannot modify objects in table of another contract\00"]
.data 17696 -> ["object passed to modify is not in multi_index\00"]
.data 17938 -> ["cannot pass end iterator to modify\00"]
.data 17088 -> ["change\00"]
.data 18357 -> ["object passed to iterator_to is not in multi_index\00"]
.data 17055 -> ["max-supply must be positive\00"]
.data 17040 -> ["invalid supply\00"]
.data 17020 -> ["invalid symbol name\00"]
void .FUNC $3 (int_32 $0, int_64 $1, int_32 $2)
{
	int_32 $3
	int_32 $4
	int_64 $5
	int_64 $6
	int_64 $7
	int_64 $8
	int_32 $9
	int_32 $10
	int_64 $11
	$3	 = ($global$0 - [160])
	$global$0 = $3
	CALL require_auth(*($0))
	$4 = [0]
	$5	 = *($2 + [8])
	$6	 = (uint_64)$5 >> (uint_64)(int_64)8
	$7 = $6)
	
.LOOP $label$3:
	if ( ((uint_32)(((CASTING uint_32)(uint_64 $7) << [24]) + [-1073741825]) > (uint_32)[452984830]) ){ goto $label$2 }
	$8 = (uint_64)$7 >> (uint_64)(int_64)8)
	if ( ((int_64)((int_64)$7 & (int_64)65280) == (int_64)0) ){ goto $label$4 }
	$7 = $8
	$9 = [1]
	$10	 = $4
	$4 = ($10 + [1])
	if ( ((int_32)$10 < (int_32)[6]) ){ goto $label$3 }
	goto $label$1 
	
.LABEL $label$4
	$7 = $8
	
.LOOP $label$5:
	if ( ((int_64)((int_64)$7 & (int_64)65280) != (int_64)0) ){ goto $label$2 }
	$7 = (uint_64)$7 >> (uint_64)(int_64)8)
	$9 = ((int_32)$4 < (int_32)[6])
	$10	 = ($4 + [1])
	$4 = $10
	if ( $9 ){ goto $label$5 }
	$9 = [1]
	$4 = ($10 + [1])
	if ( ((int_32)$10 < (int_32)[6]) ){ goto $label$3 }
	goto $label$1 
	
.LABEL $label$2
	$9 = [0]
	
.LABEL $label$1
	CALL eosio_assert($9, [17020])     # .data 17020 -> ["invalid symbol name"]
	$9 = [0]
	$11	 = *($2)
	if ( ((uint_64)((int_64)$11 + (int_64)4611686018427387903) > (uint_64)(int_64)9223372036854775806) ){ goto $label$6 }
	$4 = [0]
	$7 = $6
	
.LOOP $label$8:
	if ( ((uint_32)(((CASTING uint_32)(uint_64 $7) << [24]) + [-1073741825]) > (uint_32)[452984830]) ){ goto $label$7 }
	$8 = (uint_64)$7 >> (uint_64)(int_64)8)
	if ( ((int_64)((int_64)$7 & (int_64)65280) == (int_64)0) ){ goto $label$9 }
	$7 = $8
	$9 = [1]
	$10	 = $4
	$4 = ($10 + [1])
	if ( ((int_32)$10 < (int_32)[6]) ){ goto $label$8 }
	goto $label$6 
	
.LABEL $label$9
	$7 = $8
	
.LOOP $label$10:
	if ( ((int_64)((int_64)$7 & (int_64)65280) != (int_64)0) ){ goto $label$7 }
	$7 = (uint_64)$7 >> (uint_64)(int_64)8)
	$9 = ((int_32)$4 < (int_32)[6])
	$10	 = ($4 + [1])
	$4 = $10
	if ( $9 ){ goto $label$10 }
	$9 = [1]
	$4 = ($10 + [1])
	if ( ((int_32)$10 < (int_32)[6]) ){ goto $label$8 }
	goto $label$6 
	
.LABEL $label$7
	$9 = [0]
	
.LABEL $label$6
	CALL eosio_assert($9, [17040])     # .data 17040 -> ["invalid supply"]
	CALL eosio_assert(((int_64)$11 > (int_64)0), [17055])     # .data 17055 -> ["max-supply must be positive"]
	*((($3 + [40]) + [32])) = [0]
	*($3 + [56]) = (int_64)-1
	*($3 + [64]) = (int_64)0
	$7	 = *($0)
	*($3 + [40]) = $7
	*($3 + [48]) = $6
	$4	 = CALL db_find_i64($7, $6, (int_64)-4157508551318700032, $5)
	if ( ((int_32)$4 < (int_32)[0]) ){ goto $label$14 }
	$4	 = CALL $4(($3 + [40]), $4)
	CALL eosio_assert(((int_32)*($4 + [40]) == (int_32)($3 + [40])), [18357])     # .data 18357 -> ["object passed to iterator_to is not in multi_index"]
	CALL prints([17088])     # .data 17088 -> ["change"]
	$6 = *($0)
	CALL eosio_assert([1], [17938])     # .data 17938 -> ["cannot pass end iterator to modify"]
	CALL eosio_assert(((int_32)*($4 + [40]) == (int_32)($3 + [40])), [17696])     # .data 17696 -> ["object passed to modify is not in multi_index"]
	CALL eosio_assert(((int_64)*($3 + [40]) == (int_64)CALL $fimport$5()), [17742])     # .data 17742 -> ["cannot modify objects in table of another contract"]
	*($4 + [32]) = $1
	$7 = *($4 + [8])
	CALL eosio_assert([1], [17793])     # .data 17793 -> ["updater cannot change primary key when modifying an object"]
	*($3 + [152]) = (($3 + [80]) + [40])
	*($3 + [148]) = ($3 + [80])
	*($3 + [144]) = ($3 + [80])
	*($3 + [120]) = ($3 + [144])
	*($3 + [4]) = ($4 + [16])
	*($3) = $4
	*($3 + [8]) = ($4 + [32])
	CALL $5($3, ($3 + [120]))
	CALL db_update_i64(*($4 + [44]), $6, ($3 + [80]), [40])
	$4	 = (($3 + [40]) + [16])
	if ( (uint_64)($7 <= *($4)) ){ goto $label$13 }
	*($4) = ( (int_64)-2 ? ((int_64)$7 + (int_64)1) : ((uint_64)$7 > (uint_64)(int_64)-3) )
	$10	 = *($3 + [64])
	if ( $10 ){ goto $label$12 }
	goto $label$11 
	
.LABEL $label$14
	CALL eosio_assert([1], [17647])     # .data 17647 -> ["magnitude of asset amount must be less than 2^62"]
	$4 = [0]
	
.LOOP $label$17:
	if ( ((uint_32)(((CASTING uint_32)(uint_64 $6) << [24]) + [-1073741825]) > (uint_32)[452984830]) ){ goto $label$16 }
	$7 = (uint_64)$6 >> (uint_64)(int_64)8)
	if ( ((int_64)((int_64)$6 & (int_64)65280) == (int_64)0) ){ goto $label$18 }
	$6 = $7
	$9 = [1]
	$10	 = $4
	$4 = ($10 + [1])
	if ( ((int_32)$10 < (int_32)[6]) ){ goto $label$17 }
	goto $label$15 
	
.LABEL $label$18
	$6 = $7
	
.LOOP $label$19:
	if ( ((int_64)((int_64)$6 & (int_64)65280) != (int_64)0) ){ goto $label$16 }
	$6 = (uint_64)$6 >> (uint_64)(int_64)8)
	$9 = ((int_32)$4 < (int_32)[6])
	$10	 = ($4 + [1])
	$4 = $10
	if ( $9 ){ goto $label$19 }
	$9 = [1]
	$4 = ($10 + [1])
	if ( ((int_32)$10 < (int_32)[6]) ){ goto $label$17 }
	goto $label$15 
	
.LABEL $label$16
	$9 = [0]
	
.LABEL $label$15
	CALL eosio_assert($9, [17020])     # .data 17020 -> ["invalid symbol name"]
	*(($3 + [32])) = [0]
	*($3 + [16]) = (int_64)-1
	$7 = (int_64)0
	*($3 + [24]) = (int_64)0
	$6	 = *($0)
	*($3) = $6
	*($3 + [8]) = $5
	$4	 = CALL db_find_i64($6, $5, (int_64)-4157495357179166720, $5)
	if ( ((int_32)$4 < (int_32)[0]) ){ goto $label$20 }
	$4	 = CALL $6($3, $4)
	CALL eosio_assert(((int_32)*($4 + [40]) == (int_32)$3), [18357])     # .data 18357 -> ["object passed to iterator_to is not in multi_index"]
	$5 = *($4 + [8])
	$7 = *($4)
	
.LABEL $label$20
	CALL prints([17083])     # .data 17083 -> ["add"]
	$6 = *($0)
	CALL eosio_assert(((int_64)*($3 + [40]) == (int_64)CALL $fimport$5()), [18436])     # .data 18436 -> ["cannot create objects in table of another contract"]
	*(($4 = CALL _Znwj([56])) + [40]) = ($3 + [40])
	*($4 + [8]) = $5
	*($4) = $7
	*($4 + [32]) = $1
	*($4 + [16]) = *($2)
	*(($4 + [24])) = *(($2 + [8]))
	*($3 + [128]) = (($3 + [80]) + [40])
	*($3 + [124]) = ($3 + [80])
	*($3 + [120]) = ($3 + [80])
	*($3 + [136]) = ($3 + [120])
	*($3 + [148]) = ($4 + [16])
	*($3 + [144]) = $4
	*($3 + [152]) = ($4 + [32])
	CALL $5(($3 + [144]), ($3 + [136]))
	$7	 = *($4 + [8])
	$10	 = CALL db_store_i64(*((($3 + [40]) + [8])), (int_64)-4157508551318700032, $6, $7, ($3 + [80]), [40])
	*($4 + [44]) = $10
	$9	 = (($3 + [40]) + [16])
	if ( (uint_64)($7 <= *($9)) ){ goto $label$21 }
	*($9) = ( (int_64)-2 ? ((int_64)$7 + (int_64)1) : ((uint_64)$7 > (uint_64)(int_64)-3) )
	
.LABEL $label$21
	*($3 + [144]) = $4
	$7	 = *(($4 + [8]))
	*($3 + [80]) = $7
	*($3 + [120]) = $10
	$0	 = ($3 + [68])
	$9	 = *($0)
	if ( ((uint_32)$9 >= (uint_32)*(($3 + [72]))) ){ goto $label$24 }
	*($9 + [8]) = $7
	*($9 + [16]) = $10
	*($3 + [144]) = [0]
	*($9) = $4
	*($0) = ($9 + [24])
	$4 = *($3 + [144])
	*($3 + [144]) = [0]
	if ( $4 ){ goto $label$23 }
	goto $label$22 
	
.LABEL $label$24
	CALL $7(($3 + [64]), ($3 + [144]), ($3 + [80]), ($3 + [120]))
	$4 = *($3 + [144])
	*($3 + [144]) = [0]
	if ( ($4 == 0) ){ goto $label$22 }
	
.LABEL $label$23
	CALL _ZdlPv($4)
	
.LABEL $label$22
	$10	 = *($3 + [24])
	if ( ($10 == 0) ){ goto $label$13 }
	$0	 = ($3 + [28])
	$4	 = *($0)
	if ( ((int_32)$4 == (int_32)$10) ){ goto $label$26 }
	
.LOOP $label$27:
	$4	 = ($4 + [-24])
	$9 = *($4)
	*($4) = [0]
	if ( ($9 == 0) ){ goto $label$28 }
	CALL _ZdlPv($9)
	
.LABEL $label$28
	if ( ((int_32)$10 != (int_32)$4) ){ goto $label$27 }
	$4 = *(($3 + [24]))
	goto $label$25 
	
.LABEL $label$26
	$4 = $10
	
.LABEL $label$25
	*($0) = $10
	CALL _ZdlPv($4)
	
.LABEL $label$13
	$10	 = *($3 + [64])
	if ( ($10 == 0) ){ goto $label$11 }
	
.LABEL $label$12
	$0	 = ($3 + [68])
	$4	 = *($0)
	if ( ((int_32)$4 == (int_32)$10) ){ goto $label$30 }
	
.LOOP $label$31:
	$4	 = ($4 + [-24])
	$9 = *($4)
	*($4) = [0]
	if ( ($9 == 0) ){ goto $label$32 }
	CALL _ZdlPv($9)
	
.LABEL $label$32
	if ( ((int_32)$10 != (int_32)$4) ){ goto $label$31 }
	$4 = *(($3 + [64]))
	goto $label$29 
	
.LABEL $label$30
	$4 = $10
	
.LABEL $label$29
	*($0) = $10
	CALL _ZdlPv($4)
	$global$0 = ($3 + [160])
	return 
	
.LABEL $label$11
	$global$0 = ($3 + [160])
}

void .FUNC memory ()
{
	CALL $93()
}

void .FUNC $1 (int_32 $0)
{
	if ( ((*([0] + [8192]) & [1]) == 0) ){ goto $label$1 }
	CALL _ZdlPv(*([0] + [8200]))
	
.LABEL $label$1
}

.data 17020 -> ["invalid symbol name\00"]
.data 17647 -> ["magnitude of asset amount must be less than 2^62\00"]
void .FUNC $14 (int_32 $0, int_32 $1)
{
	int_32 $2
	int_32 $3
	int_32 $4
	int_32 $5
	int_32 $6
	int_64 $7
	int_64 $8
	int_64 $9
	int_32 $10
	$2	 = ($global$0 - [32])
	$3 = $2
	$global$0 = $2
	$4 = *($0)
	$5	 = *($0 + [4])
	$6	 = *($5)
	*($1) = *($6)
	*(($1 + [8])) = *(($6 + [8]))
	$7 = *(*($5) + [8])
	CALL eosio_assert([1], [17647])     # .data 17647 -> ["magnitude of asset amount must be less than 2^62"]
	$8 = (uint_64)$7 >> (uint_64)(int_64)8)
	$5 = [0]
	
.LOOP $label$3:
	if ( ((uint_32)(((CASTING uint_32)(uint_64 $8) << [24]) + [-1073741825]) > (uint_32)[452984830]) ){ goto $label$2 }
	$9 = (uint_64)$8 >> (uint_64)(int_64)8)
	if ( ((int_64)((int_64)$8 & (int_64)65280) == (int_64)0) ){ goto $label$4 }
	$8 = $9
	$6 = [1]
	$10	 = $5
	$5 = ($10 + [1])
	if ( ((int_32)$10 < (int_32)[6]) ){ goto $label$3 }
	goto $label$1 
	
.LABEL $label$4
	$8 = $9
	
.LOOP $label$5:
	if ( ((int_64)((int_64)$8 & (int_64)65280) != (int_64)0) ){ goto $label$2 }
	$8 = (uint_64)$8 >> (uint_64)(int_64)8)
	$6 = ((int_32)$5 < (int_32)[6])
	$10	 = ($5 + [1])
	$5 = $10
	if ( $6 ){ goto $label$5 }
	$6 = [1]
	$5 = ($10 + [1])
	if ( ((int_32)$10 < (int_32)[6]) ){ goto $label$3 }
	goto $label$1 
	
.LABEL $label$2
	$6 = [0]
	
.LABEL $label$1
	CALL eosio_assert($6, [17020])     # .data 17020 -> ["invalid symbol name"]
	*(($1 + [24])) = $7
	*($1 + [16]) = (int_64)0
	$6	 = $2
	$5	 = ($6 + [-32])
	$global$0 = $5
	*($3 + [4]) = $5
	*($3) = $5
	*($3 + [8]) = $6
	*($3 + [16]) = $3
	*($3 + [28]) = ($1 + [16])
	*($3 + [24]) = $1
	CALL $13(($3 + [24]), ($3 + [16]))
	$8	 = *($1 + [8])
	*($1 + [36]) = CALL db_store_i64(*($4 + [8]), (int_64)3607749779137757184, *(*($0 + [8])), $8, $5, [32])
	if ( (uint_64)($8 <= *($4 + [16])) ){ goto $label$6 }
	*(($4 + [16])) = ( (int_64)-2 ? ((int_64)$8 + (int_64)1) : ((uint_64)$8 > (uint_64)(int_64)-3) )
	
.LABEL $label$6
	$global$0 = ($3 + [32])
}

void .FUNC $15 (int_32 $0, int_32 $1, int_32 $2, int_32 $3)
{
	int_32 $4
	int_32 $5
	int_32 $6
	int_32 $7
	int_32 $8
	$4	 = *($0)
	$5	 = ((int_32)(*($0 + [4]) - $4) / (int_32)[24])
	$6	 = ($5 + [1])
	if ( ((uint_32)$6 >= (uint_32)[178956971]) ){ goto $label$2 }
	$7 = [178956970]
	$4	 = ((int_32)(*($0 + [8]) - $4) / (int_32)[24])
	if ( ((uint_32)$4 > (uint_32)[89478484]) ){ goto $label$4 }
	$7	 = ($4 << [1])
	$7	 = ( $6 ? $7 : ($7 <= $6) )
	if ( ($7 == 0) ){ goto $label$3 }
	
.LABEL $label$4
	$4 = CALL _Znwj(((int_32)$7 * (int_32)[24]))
	goto $label$1 
	
.LABEL $label$3
	$7 = [0]
	$4 = [0]
	goto $label$1 
	
.LABEL $label$2
	CALL $105($0)
	
.LABEL $label$1
	$6 = *($1)
	*($1) = [0]
	*(($1 = ($4 + ($8 = ((int_32)$5 * (int_32)[24]))))) = $6
	*($1 + [8]) = *($2)
	*($1 + [16]) = *($3)
	$5 = ($4 + ((int_32)$7 * (int_32)[24]))
	$6 = ($1 + [24])
	$7	 = *($0)
	$2	 = *(($0 + [4]))
	if ( ((int_32)$2 == (int_32)$7) ){ goto $label$6 }
	$1 = (($4 + $8) + [-24])
	
.LOOP $label$7:
	$4	 = ($2 + [-24])
	$3 = *($4)
	*($4) = [0]
	*($1) = $3
	*(($1 + [16])) = *(($2 + [-8]))
	*(($1 + [8])) = *(($2 + [-16]))
	$1 = ($1 + [-24])
	$2 = $4
	if ( ((int_32)$7 != (int_32)$4) ){ goto $label$7 }
	$1 = ($1 + [24])
	$7 = *(($0 + [4]))
	$2 = *($0)
	goto $label$5 
	
.LABEL $label$6
	$2 = $7
	
.LABEL $label$5
	*($0) = $1
	*(($0 + [4])) = $6
	*(($0 + [8])) = $5
	if ( ((int_32)$7 == (int_32)$2) ){ goto $label$8 }
	
.LOOP $label$9:
	$7	 = ($7 + [-24])
	$1 = *($7)
	*($7) = [0]
	if ( ($1 == 0) ){ goto $label$10 }
	CALL _ZdlPv($1)
	
.LABEL $label$10
	if ( ((int_32)$2 != (int_32)$7) ){ goto $label$9 }
	
.LABEL $label$8
	if ( ($2 == 0) ){ goto $label$11 }
	CALL _ZdlPv($2)
	
.LABEL $label$11
	(unreachable)
}

.data 17793 -> ["updater cannot change primary key when modifying an object\00"]
.data 18043 -> ["subtraction overflow\00"]
.data 18021 -> ["subtraction underflow\00"]
.data 17973 -> ["attempt to subtract asset with different symbol\00"]
.data 17742 -> ["cannot modify objects in table of another contract\00"]
.data 17696 -> ["object passed to modify is not in multi_index\00"]
.data 17257 -> ["quantity exceeds available supply\00"]
.data 17231 -> ["symbol precision mismatch\00"]
.data 17357 -> ["must burn positive quantity\00"]
.data 17185 -> ["invalid quantity\00"]
.data 17298 -> ["token with symbol does not exist, create token before burn\00"]
.data 18357 -> ["object passed to iterator_to is not in multi_index\00"]
.data 17096 -> ["memo has more than 256 bytes\00"]
.data 17020 -> ["invalid symbol name\00"]
void .FUNC $16 (int_32 $0, int_64 $1, int_32 $2, int_32 $3)
{
	int_32 $4
	int_32 $5
	int_64 $6
	int_64 $7
	int_64 $8
	int_64 $9
	int_32 $10
	int_32 $11
	$4	 = ($global$0 - [160])
	$global$0 = $4
	$5 = [0]
	$6	 = *($2 + [8])
	$7	 = (uint_64)$6 >> (uint_64)(int_64)8
	$8 = $7)
	
.LOOP $label$3:
	if ( ((uint_32)(((CASTING uint_32)(uint_64 $8) << [24]) + [-1073741825]) > (uint_32)[452984830]) ){ goto $label$2 }
	$9 = (uint_64)$8 >> (uint_64)(int_64)8)
	if ( ((int_64)((int_64)$8 & (int_64)65280) == (int_64)0) ){ goto $label$4 }
	$8 = $9
	$10 = [1]
	$11	 = $5
	$5 = ($11 + [1])
	if ( ((int_32)$11 < (int_32)[6]) ){ goto $label$3 }
	goto $label$1 
	
.LABEL $label$4
	$8 = $9
	
.LOOP $label$5:
	if ( ((int_64)((int_64)$8 & (int_64)65280) != (int_64)0) ){ goto $label$2 }
	$8 = (uint_64)$8 >> (uint_64)(int_64)8)
	$10 = ((int_32)$5 < (int_32)[6])
	$11	 = ($5 + [1])
	$5 = $11
	if ( $10 ){ goto $label$5 }
	$10 = [1]
	$5 = ($11 + [1])
	if ( ((int_32)$11 < (int_32)[6]) ){ goto $label$3 }
	goto $label$1 
	
.LABEL $label$2
	$10 = [0]
	
.LABEL $label$1
	CALL eosio_assert($10, [17020])     # .data 17020 -> ["invalid symbol name"]
	$5	 = *($3)
	if ( ($5 & [1]) ){ goto $label$7 }
	$5 = uint_32($5 >> [1])
	goto $label$6 
	
.LABEL $label$7
	$5 = *($3 + [4])
	
.LABEL $label$6
	CALL eosio_assert(($5 <= [257]), [17096])     # .data 17096 -> ["memo has more than 256 bytes"]
	$10 = [0]
	*(($4 + [72])) = [0]
	*($4 + [56]) = (int_64)-1
	*($4 + [64]) = (int_64)0
	$8	 = *($0)
	*($4 + [40]) = $8
	*($4 + [48]) = $7
	$11 = [0]
	$5	 = CALL db_find_i64($8, $7, (int_64)-4157508551318700032, $6)
	if ( ((int_32)$5 < (int_32)[0]) ){ goto $label$8 }
	$11	 = CALL $4(($4 + [40]), $5)
	CALL eosio_assert(((int_32)*($11 + [40]) == (int_32)($4 + [40])), [18357])     # .data 18357 -> ["object passed to iterator_to is not in multi_index"]
	
.LABEL $label$8
	CALL eosio_assert(((int_32)$11 != (int_32)[0]), [17298])     # .data 17298 -> ["token with symbol does not exist, create token before burn"]
	CALL require_auth($1)
	CALL require_recipient($1)
	$8	 = *($2)
	if ( ((uint_64)((int_64)$8 + (int_64)4611686018427387903) > (uint_64)(int_64)9223372036854775806) ){ goto $label$9 }
	$5 = [0]
	
.LOOP $label$11:
	if ( ((uint_32)(((CASTING uint_32)(uint_64 $7) << [24]) + [-1073741825]) > (uint_32)[452984830]) ){ goto $label$10 }
	$9 = (uint_64)$7 >> (uint_64)(int_64)8)
	if ( ((int_64)((int_64)$7 & (int_64)65280) == (int_64)0) ){ goto $label$12 }
	$7 = $9
	$10 = [1]
	$3	 = $5
	$5 = ($3 + [1])
	if ( ((int_32)$3 < (int_32)[6]) ){ goto $label$11 }
	goto $label$9 
	
.LABEL $label$12
	$7 = $9
	
.LOOP $label$13:
	if ( ((int_64)((int_64)$7 & (int_64)65280) != (int_64)0) ){ goto $label$10 }
	$7 = (uint_64)$7 >> (uint_64)(int_64)8)
	$10 = ((int_32)$5 < (int_32)[6])
	$3	 = ($5 + [1])
	$5 = $3
	if ( $10 ){ goto $label$13 }
	$10 = [1]
	$5 = ($3 + [1])
	if ( ((int_32)$3 < (int_32)[6]) ){ goto $label$11 }
	goto $label$9 
	
.LABEL $label$10
	$10 = [0]
	
.LABEL $label$9
	CALL eosio_assert($10, [17185])     # .data 17185 -> ["invalid quantity"]
	CALL eosio_assert(((int_64)$8 > (int_64)0), [17357])     # .data 17357 -> ["must burn positive quantity"]
	CALL eosio_assert(((int_64)$6 == (int_64)*($11 + [8])), [17231])     # .data 17231 -> ["symbol precision mismatch"]
	CALL eosio_assert(((int_64)$8 <= (int_64)*($11)), [17257])     # .data 17257 -> ["quantity exceeds available supply"]
	$9 = *($0)
	CALL eosio_assert(((int_32)*($11 + [40]) == (int_32)($4 + [40])), [17696])     # .data 17696 -> ["object passed to modify is not in multi_index"]
	CALL eosio_assert(((int_64)*($4 + [40]) == (int_64)CALL $fimport$5()), [17742])     # .data 17742 -> ["cannot modify objects in table of another contract"]
	$7	 = *($11 + [8])
	CALL eosio_assert(((int_64)$6 == (int_64)$7), [17973])     # .data 17973 -> ["attempt to subtract asset with different symbol"]
	$8	 = (int_64)
	*($11) = $8(*($11) - $8))
	CALL eosio_assert(((int_64)$8 > (int_64)-4611686018427387904), [18021])     # .data 18021 -> ["subtraction underflow"]
	CALL eosio_assert(((int_64)*($11) < (int_64)4611686018427387904), [18043])     # .data 18043 -> ["subtraction overflow"]
	CALL eosio_assert(((int_64)$7 == (int_64)*($11 + [8])), [17793])     # .data 17793 -> ["updater cannot change primary key when modifying an object"]
	*($4 + [128]) = (($4 + [80]) + [40])
	*($4 + [124]) = ($4 + [80])
	*($4 + [120]) = ($4 + [80])
	*($4 + [136]) = ($4 + [120])
	*($4 + [148]) = ($11 + [16])
	*($4 + [144]) = $11
	*($4 + [152]) = ($11 + [32])
	CALL $5(($4 + [144]), ($4 + [136]))
	CALL db_update_i64(*($11 + [44]), $9, ($4 + [80]), [40])
	$5	 = (($4 + [40]) + [16])
	if ( (uint_64)($7 <= *($5)) ){ goto $label$14 }
	*($5) = ( (int_64)-2 ? ((int_64)$7 + (int_64)1) : ((uint_64)$7 > (uint_64)(int_64)-3) )
	
.LABEL $label$14
	$7	 = *(($2 + [8]))
	*((($4 + [24]) + [8])) = $7
	$8 = *($2)
	*((($4 + [8]) + [8])) = $7
	*($4 + [8]) = $8
	*($4 + [24]) = $8
	CALL $17($0, $1, ($4 + [8]))
	$11	 = *($4 + [64])
	if ( ($11 == 0) ){ goto $label$15 }
	$3	 = ($4 + [68])
	$5	 = *($3)
	if ( ((int_32)$5 == (int_32)$11) ){ goto $label$17 }
	
.LOOP $label$18:
	$5	 = ($5 + [-24])
	$10 = *($5)
	*($5) = [0]
	if ( ($10 == 0) ){ goto $label$19 }
	CALL _ZdlPv($10)
	
.LABEL $label$19
	if ( ((int_32)$11 != (int_32)$5) ){ goto $label$18 }
	$5 = *(($4 + [64]))
	goto $label$16 
	
.LABEL $label$17
	$5 = $11
	
.LABEL $label$16
	*($3) = $11
	CALL _ZdlPv($5)
	
.LABEL $label$15
	$global$0 = ($4 + [160])
}

.data 17793 -> ["updater cannot change primary key when modifying an object\00"]
.data 18043 -> ["subtraction overflow\00"]
.data 18021 -> ["subtraction underflow\00"]
.data 17973 -> ["attempt to subtract asset with different symbol\00"]
.data 17742 -> ["cannot modify objects in table of another contract\00"]
.data 17696 -> ["object passed to modify is not in multi_index\00"]
.data 17409 -> ["overdrawn balance\00"]
.data 17385 -> ["no balance object found\00"]
void .FUNC $17 (int_32 $0, int_64 $1, int_32 $2)
{
	int_32 $3
	int_64 $4
	int_64 $5
	int_32 $6
	int_64 $7
	int_32 $8
	$3	 = ($global$0 - [112])
	$global$0 = $3
	*((($3 + [8]) + [32])) = [0]
	*($3 + [16]) = $1
	*($3 + [24]) = (int_64)-1
	*($3 + [32]) = (int_64)0
	*($3 + [8]) = *($0)
	$5	 = *($2)
	$4	 = *($2 + [8])
	$0	 = CALL $18(($3 + [8]), $4, [17385])
	CALL eosio_assert(((int_64))(*($0) - *($0 + [16])) >= (int_64)$5), [17409])     # .data 17385 -> ["no balance object found"]     # .data 17409 -> ["overdrawn balance"]
	if ( ((int_64)$5 != (int_64)*($0)) ){ goto $label$3 }
	CALL $19(($3 + [8]), $0)
	$6	 = *($3 + [32])
	if ( $6 ){ goto $label$2 }
	goto $label$1 
	
.LABEL $label$3
	CALL eosio_assert(((int_32)*($0 + [32]) == (int_32)($3 + [8])), [17696])     # .data 17696 -> ["object passed to modify is not in multi_index"]
	CALL eosio_assert(((int_64)*($3 + [8]) == (int_64)CALL $fimport$5()), [17742])     # .data 17742 -> ["cannot modify objects in table of another contract"]
	$7	 = *($0 + [8])
	CALL eosio_assert(((int_64)$4 == (int_64)$7), [17973])     # .data 17973 -> ["attempt to subtract asset with different symbol"]
	$5	 = (int_64)
	*($0) = $5(*($0) - $5))
	CALL eosio_assert(((int_64)$5 > (int_64)-4611686018427387904), [18021])     # .data 18021 -> ["subtraction underflow"]
	CALL eosio_assert(((int_64)*($0) < (int_64)4611686018427387904), [18043])     # .data 18043 -> ["subtraction overflow"]
	CALL eosio_assert(((int_64)$7 == (int_64)*($0 + [8])), [17793])     # .data 17793 -> ["updater cannot change primary key when modifying an object"]
	*($3 + [88]) = (($3 + [48]) + [32])
	*($3 + [84]) = ($3 + [48])
	*($3 + [80]) = ($3 + [48])
	*($3 + [96]) = ($3 + [80])
	*($3 + [108]) = ($0 + [16])
	*($3 + [104]) = $0
	CALL $13(($3 + [104]), ($3 + [96]))
	CALL db_update_i64(*($0 + [36]), $1, ($3 + [48]), [32])
	$0	 = (($3 + [8]) + [16])
	if ( (uint_64)($7 <= *($0)) ){ goto $label$4 }
	*($0) = ( (int_64)-2 ? ((int_64)$7 + (int_64)1) : ((uint_64)$7 > (uint_64)(int_64)-3) )
	
.LABEL $label$4
	$6	 = *($3 + [32])
	if ( ($6 == 0) ){ goto $label$1 }
	
.LABEL $label$2
	$8	 = ($3 + [36])
	$0	 = *($8)
	if ( ((int_32)$0 == (int_32)$6) ){ goto $label$6 }
	
.LOOP $label$7:
	$0	 = ($0 + [-24])
	$2 = *($0)
	*($0) = [0]
	if ( ($2 == 0) ){ goto $label$8 }
	CALL _ZdlPv($2)
	
.LABEL $label$8
	if ( ((int_32)$6 != (int_32)$0) ){ goto $label$7 }
	$0 = *(($3 + [32]))
	goto $label$5 
	
.LABEL $label$6
	$0 = $6
	
.LABEL $label$5
	*($8) = $6
	CALL _ZdlPv($0)
	
.LABEL $label$1
	$global$0 = ($3 + [112])
}

.data 18102 -> ["thirteenth character in name cannot be a letter that comes after j\00"]
.data 18169 -> ["character is not in allowed character set for names\00"]
.data 18064 -> ["string is too long to be a valid name\00"]
int_32 .FUNC $10 (int_32 $0, int_32 $1)
{
	int_32 $2
	int_32 $3
	int_64 $4
	int_32 $5
	int_32 $6
	int_32 $7
	*($0) = (int_64)0
	$2	 = *($1 + [4])
	if ( ($2 <= [14]) ){ goto $label$4 }
	CALL eosio_assert([0], [18064])     # .data 18064 -> ["string is too long to be a valid name"]
	$3 = [12]
	goto $label$3 
	
.LABEL $label$4
	$3	 = ( $2 ? [12] : ($2 <= [12]) )
	if ( ($3 == 0) ){ goto $label$2 }
	
.LABEL $label$3
	$4 = *($0)
	$5 = *($1)
	$6 = [0]
	
.LOOP $label$5:
	$4	 = ((int_64)$4 << (int_64)5)
	*($0) = $4
	$7	 = *(($5 + $6))
	if ( ((int_32)$7 != (int_32)[46]) ){ goto $label$7 }
	$7 = [0]
	goto $label$6 
	
.LABEL $label$7
	if ( ((uint_32)(($7 + [-49]) & [255]) > (uint_32)[4]) ){ goto $label$8 }
	$7 = ($7 + [-48])
	goto $label$6 
	
.LABEL $label$8
	if ( ((uint_32)(($7 + [-97]) & [255]) > (uint_32)[25]) ){ goto $label$9 }
	$7 = ($7 + [-91])
	goto $label$6 
	
.LABEL $label$9
	$7 = [0]
	CALL eosio_assert([0], [18169])     # .data 18169 -> ["character is not in allowed character set for names"]
	$4 = *($0)
	
.LABEL $label$6
	$4	 = ((int_64)$4 | (int_64)((int_64)(CASTING uint_64)(uint_32 $7) & (int_64)255))
	*($0) = $4
	$6	 = ($6 + [1])
	if ( ($6 <= $3) ){ goto $label$5 }
	goto $label$1 
	
.LABEL $label$2
	$4 = *($0)
	$3 = [0]
	
.LABEL $label$1
	*($0) = ((int_64)$4 << (int_64)(CASTING uint_64)(uint_32 (((int_32)([12] - $3) * (int_32)[5]) + [4])))
	if ( ((int_32)$2 != (int_32)[13]) ){ goto $label$10 }
	$4 = (int_64)0
	$6	 = *(*($1) + [12])
	if ( ((int_32)$6 == (int_32)[46]) ){ goto $label$11 }
	if ( ((uint_32)(($6 + [-49]) & [255]) > (uint_32)[4]) ){ goto $label$12 }
	$4 = ((int_64)(CASTING uint_64)(uint_32 ($6 + [-48])) & (int_64)255)
	goto $label$11 
	
.LABEL $label$12
	if ( ((uint_32)(($6 + [-97]) & [255]) >= (uint_32)[26]) ){ goto $label$13 }
	$6	 = ($6 + [-91])
	$4 = ((int_64)(CASTING uint_64)(uint_32 $6) & (int_64)255)
	if ( (($6 & [255]) <= [16]) ){ goto $label$11 }
	CALL eosio_assert([0], [18102])     # .data 18102 -> ["thirteenth character in name cannot be a letter that comes after j"]
	goto $label$11 
	
.LABEL $label$13
	CALL eosio_assert([0], [18169])     # .data 18169 -> ["character is not in allowed character set for names"]
	
.LABEL $label$11
	*($0) = ((int_64)*($0) | (int_64)$4)
	
.LABEL $label$10
	return $0
}

void .FUNC $11 (int_64 $0, int_64 $1, int_32 $2, int_32 $3)
{
	int_32 $4
	int_32 $5
	int_32 $6
	int_32 $7
	int_32 $8
	$4	 = ($global$0 - [96])
	$global$0 = $4
	*($4 + [16]) = [0]
	*($4 + [8]) = (int_64)0
	$5 = [0]
	$6 = [0]
	$7 = [0]
	$8	 = (*($2 + [4]) - *($2))
	if ( ($8 == 0) ){ goto $label$2 }
	$5	 = int_32($8 >> [4])
	if ( ((uint_32)$5 >= (uint_32)[268435456]) ){ goto $label$1 }
	$7	 = CALL _Znwj($8)
	$5	 = ($7 + ($5 << [4]))
	*(($4 + [16])) = $5
	*($4 + [8]) = $7
	*($4 + [12]) = $7
	$6	 = *($2)
	$2	 = (*(($2 + [4])) - $6)
	if ( ((int_32)$2 < (int_32)[1]) ){ goto $label$3 }
	CALL memcpy($7, $6, $2)
	$6	 = ($7 + $2)
	*($4 + [12]) = $6
	goto $label$2 
	
.LABEL $label$3
	$6 = $7
	
.LABEL $label$2
	*(($4 + [44])) = $6
	*(($4 + [48])) = $5
	*(($4 + [16])) = [0]
	*((($4 + [24]) + [36])) = [0]
	*($4 + [32]) = $1
	*($4 + [24]) = $0
	*($4 + [40]) = $7
	*($4 + [8]) = (int_64)0
	*($4 + [52 align=4]) = (int_64)0
	$7	 = *($3 + [32])
	$2	 = ( *(($3 + [36])) ? uint_32($7 >> [1]) : ($7 & [1]) )
	$7 = ($2 + [32])
	$0 = (CASTING uint_64)(uint_32 $2)
	$2 = ($4 + [52])
	
.LOOP $label$4:
	$7 = ($7 + [1])
	$0	 = (uint_64)$0 >> (uint_64)(int_64)7
	if ( ((int_64)$0) != (int_64)0) ){ goto $label$4 }
	if ( ($7 == 0) ){ goto $label$6 }
	CALL $46($2, $7)
	$2 = *(($4 + [56]))
	$7 = *(($4 + [52]))
	goto $label$5 
	
.LABEL $label$6
	$2 = [0]
	$7 = [0]
	
.LABEL $label$5
	*($4 + [84]) = $7
	*($4 + [80]) = $7
	*($4 + [88]) = $2
	*($4 + [64]) = ($4 + [80])
	*($4 + [72]) = $3
	CALL $82(($4 + [72]), ($4 + [64]))
	CALL $43(($4 + [80]), ($4 + [24]))
	$7	 = *($4 + [80])
	CALL send_inline($7, (*($4 + [84]) - $7))
	$7	 = *($4 + [80])
	if ( ($7 == 0) ){ goto $label$7 }
	*($4 + [84]) = $7
	CALL _ZdlPv($7)
	
.LABEL $label$7
	$7	 = *($4 + [52])
	if ( ($7 == 0) ){ goto $label$8 }
	*(($4 + [56])) = $7
	CALL _ZdlPv($7)
	
.LABEL $label$8
	$7	 = *($4 + [40])
	if ( ($7 == 0) ){ goto $label$9 }
	*(($4 + [44])) = $7
	CALL _ZdlPv($7)
	
.LABEL $label$9
	$7	 = *($4 + [8])
	if ( ($7 == 0) ){ goto $label$10 }
	*($4 + [12]) = $7
	CALL _ZdlPv($7)
	
.LABEL $label$10
	$global$0 = ($4 + [96])
	return (unreachable)
	
.LABEL $label$1
	CALL $105(($4 + [8]))
}

.data 18408 -> ["error reading iterator\00"]
int_32 .FUNC $12 (int_32 $0, int_32 $1)
{
	int_32 $2
	int_32 $3
	int_32 $4
	int_32 $5
	int_64 $6
	int_32 $7
	int_32 $8
	$2	 = ($global$0 - [48])
	$3 = $2
	$global$0 = $2
	$5	 = *(($0 + [28]))
	$4	 = *($0 + [24])
	if ( ((int_32)$4 == (int_32)$5) ){ goto $label$1 }
	
.LOOP $label$3:
	if ( ((int_32)*(($5 + [-8])) == (int_32)$1) ){ goto $label$2 }
	$5	 = ($5 + [-24])
	if ( ((int_32)$4 != (int_32)$5) ){ goto $label$3 }
	goto $label$1 
	
.LABEL $label$2
	if ( ((int_32)$4 == (int_32)$5) ){ goto $label$1 }
	$5 = *(($5 + [-24]))
	$global$0 = ($3 + [48])
	return $5
	
.LABEL $label$1
	$4	 = CALL db_get_i64($1, [0], [0])
	CALL eosio_assert(((int_32)uint_32($4 >> [31]) ^ (int_32)[1]), [18408])     # .data 18408 -> ["error reading iterator"]
	if ( ($4 <= [513]) ){ goto $label$5 }
	$2 = CALL $114($4)
	goto $label$4 
	
.LABEL $label$5
	$2	 = ($2 - (($4 + [15]) & [-16]))
	$global$0 = $2
	
.LABEL $label$4
	CALL db_get_i64($1, $2, $4)
	*($3 + [20]) = $2
	*($3 + [16]) = $2
	*($3 + [24]) = ($2 + $4)
	*(($5 = CALL _Znwj([48])) + [8]) = (int_64)0
	*($5) = (int_64)0
	*($5 + [16]) = (int_64)0
	*($5 + [24]) = (int_64)0
	*($5 + [32]) = $0
	*($3 + [32]) = ($3 + [16])
	*($3 + [44]) = ($5 + [16])
	*($3 + [40]) = $5
	CALL $84(($3 + [40]), ($3 + [32]))
	*($5 + [36]) = $1
	*($3 + [32]) = $5
	$6	 = *($5 + [8])
	*($3 + [40]) = $6
	*($3 + [12]) = $1
	$7	 = ($0 + [28])
	$8	 = *($7)
	if ( ((uint_32)$8 >= (uint_32)*(($0 + [32]))) ){ goto $label$8 }
	*($8 + [8]) = $6
	*($8 + [16]) = $1
	*($3 + [32]) = [0]
	*($8) = $5
	*($7) = ($8 + [24])
	if ( ((uint_32)$4 >= (uint_32)[513]) ){ goto $label$7 }
	goto $label$6 
	
.LABEL $label$8
	CALL $15(($0 + [24]), ($3 + [32]), ($3 + [40]), ($3 + [12]))
	if ( ($4 <= [513]) ){ goto $label$6 }
	
.LABEL $label$7
	CALL $118($2)
	
.LABEL $label$6
	$1 = *($3 + [32])
	*($3 + [32]) = [0]
	if ( ($1 == 0) ){ goto $label$9 }
	CALL _ZdlPv($1)
	
.LABEL $label$9
	$global$0 = ($3 + [48])
	return $5
}

.data 17932 -> ["write\00"]
void .FUNC $13 (int_32 $0, int_32 $1)
{
	int_32 $2
	int_32 $3
	int_32 $4
	int_32 $5
	$2	 = ($global$0 - [16])
	$global$0 = $2
	$3 = *($0)
	$4	 = *($1)
	CALL eosio_assert(((int_32)(*($4 + [8]) - *($4 + [4])) > (int_32)[7]), [17932])     # .data 17932 -> ["write"]
	CALL memcpy(*($4 + [4]), $3, [8])
	$5	 = (*($4 + [4]) + [8])
	*($4 + [4]) = $5
	*($2 + [8]) = *($3 + [8])
	CALL eosio_assert(((int_32)(*($4 + [8]) - $5) > (int_32)[7]), [17932])     # .data 17932 -> ["write"]
	CALL memcpy(*($4 + [4]), ($2 + [8]), [8])
	*($4 + [4]) = (*($4 + [4]) + [8])
	$0 = *($0 + [4])
	$4	 = *($1)
	CALL eosio_assert(((int_32)(*($4 + [8]) - *($4 + [4])) > (int_32)[7]), [17932])     # .data 17932 -> ["write"]
	CALL memcpy(*($4 + [4]), $0, [8])
	$1	 = (*($4 + [4]) + [8])
	*($4 + [4]) = $1
	*($2 + [8]) = *($0 + [8])
	CALL eosio_assert(((int_32)(*($4 + [8]) - $1) > (int_32)[7]), [17932])     # .data 17932 -> ["write"]
	CALL memcpy(*($4 + [4]), ($2 + [8]), [8])
	*($4 + [4]) = (*($4 + [4]) + [8])
	$global$0 = ($2 + [16])
}

.data 17932 -> ["write\00"]
int_32 .FUNC $75 (int_32 $0, int_32 $1)
{
	int_32 $2
	int_64 $3
	int_32 $4
	int_32 $5
	int_32 $6
	int_32 $7
	$2	 = ($global$0 - [16])
	$global$0 = $2
	$3 = (CASTING uint_64)(uint_32 int_32((*($1 + [4]) - *($1)) >> [4]))
	$4 = *($0 + [4])
	$5 = ($0 + [8])
	
.LOOP $label$1:
	$6 = (CASTING uint_32)(uint_64 $3)
	$3	 = (uint_64)$3 >> (uint_64)(int_64)7
	$7	 = ((int_64)$3) != (int_64)0
	*($2 + [15]) = (($7) << [7]) | ($6 & [127]))
	CALL eosio_assert(((int_32)(*($5) - $4) > (int_32)[0]), [17932])     # .data 17932 -> ["write"]
	$6	 = ($0 + [4])
	CALL memcpy(*($6), ($2 + [15]), [1])
	$4	 = (*($6) + [1])
	*($6) = $4
	if ( $7 ){ goto $label$1 }
	$1	 = *(($1 + [4]))
	$7	 = *($1)
	if ( ((int_32)$7 == (int_32)$1) ){ goto $label$2 }
	$6 = ($0 + [4])
	
.LOOP $label$3:
	$5	 = ($0 + [8])
	CALL eosio_assert(((int_32)(*($5) - $4) > (int_32)[7]), [17932])     # .data 17932 -> ["write"]
	CALL memcpy(*($6), $7, [8])
	$4	 = (*($6) + [8])
	*($6) = $4
	CALL eosio_assert(((int_32)(*($5) - $4) > (int_32)[7]), [17932])     # .data 17932 -> ["write"]
	CALL memcpy(*($6), ($7 + [8]), [8])
	$4	 = (*($6) + [8])
	*($6) = $4
	$7	 = ($7 + [16])
	if ( ((int_32)$7 != (int_32)$1) ){ goto $label$3 }
	
.LABEL $label$2
	$global$0 = ($2 + [16])
	return $0
}

.data 18357 -> ["object passed to iterator_to is not in multi_index\00"]
int_32 .FUNC $18 (int_32 $0, int_64 $1, int_32 $2)
{
	int_32 $3
	int_32 $4
	int_32 $5
	int_32 $6
	$4	 = *(($0 + [28]))
	$3	 = *($0 + [24])
	if ( ((int_32)$3 == (int_32)$4) ){ goto $label$1 }
	
.LOOP $label$3:
	$5	 = ($4 + [-24])
	$6	 = *($5)
	if ( ((int_64)*($6 + [8]) == (int_64)$1) ){ goto $label$2 }
	$4 = $5
	if ( ((int_32)$3 != (int_32)$5) ){ goto $label$3 }
	goto $label$1 
	
.LABEL $label$2
	if ( ((int_32)$3 == (int_32)$4) ){ goto $label$1 }
	CALL eosio_assert(((int_32)*($6 + [32]) == (int_32)$0), [18357])     # .data 18357 -> ["object passed to iterator_to is not in multi_index"]
	CALL eosio_assert(((int_32)$6 != (int_32)[0]), $2)
	return $6
	
.LABEL $label$1
	$5 = [0]
	$4	 = CALL db_find_i64(*($0), *($0 + [8]), (int_64)3607749779137757184, $1)
	if ( ((int_32)$4 < (int_32)[0]) ){ goto $label$4 }
	$5	 = CALL $12($0, $4)
	CALL eosio_assert(((int_32)*($5 + [32]) == (int_32)$0), [18357])     # .data 18357 -> ["object passed to iterator_to is not in multi_index"]
	
.LABEL $label$4
	CALL eosio_assert(((int_32)$5 != (int_32)[0]), $2)
	return $5
}

.data 18586 -> ["attempt to remove object that was not in multi_index\00"]
.data 18536 -> ["cannot erase objects in table of another contract\00"]
.data 18491 -> ["object passed to erase is not in multi_index\00"]
void .FUNC $19 (int_32 $0, int_32 $1)
{
	int_32 $2
	int_32 $3
	int_32 $4
	int_32 $5
	int_64 $6
	int_32 $7
	int_32 $8
	CALL eosio_assert(((int_32)*($1 + [32]) == (int_32)$0), [18491])     # .data 18491 -> ["object passed to erase is not in multi_index"]
	CALL eosio_assert(((int_64)*($0) == (int_64)CALL $fimport$5()), [18536])     # .data 18536 -> ["cannot erase objects in table of another contract"]
	$2	 = *($0 + [24])
	$3 = $2
	$4	 = ($0 + [28])
	$5	 = *($4)
	if ( ((int_32)$2 == (int_32)$5) ){ goto $label$1 }
	$6	 = *($1 + [8])
	if ( ((int_64)*(*(($5 + [-24])) + [8]) != (int_64)$6) ){ goto $label$2 }
	$3 = $5
	goto $label$1 
	
.LABEL $label$2
	$7 = ($2 + [24])
	
.LOOP $label$4:
	if ( ((int_32)$7 == (int_32)$5) ){ goto $label$3 }
	$8 = ($5 + [-48])
	$3	 = ($5 + [-24])
	$5 = $3
	if ( ((int_64)*(*($8) + [8]) != (int_64)$6) ){ goto $label$4 }
	goto $label$1 
	
.LABEL $label$3
	$3 = $2
	
.LABEL $label$1
	CALL eosio_assert(((int_32)$3 != (int_32)$2), [18586])     # .data 18586 -> ["attempt to remove object that was not in multi_index"]
	$2	 = *($4)
	if ( ((int_32)$3 == (int_32)$2) ){ goto $label$7 }
	$5 = $3
	
.LOOP $label$8:
	$8 = *($5)
	*($5) = [0]
	$7	 = ($5 + [-24])
	$3 = *($7)
	*($7) = $8
	if ( ($3 == 0) ){ goto $label$9 }
	CALL _ZdlPv($3)
	
.LABEL $label$9
	*(($5 + [-8])) = *(($5 + [16]))
	*(($5 + [-16])) = *(($5 + [8]))
	$5	 = ($5 + [24])
	if ( ((int_32)$2 != (int_32)$5) ){ goto $label$8 }
	$8 = ($5 + [-24])
	$3	 = *(($0 + [28]))
	if ( ((int_32)($3 + [24]) != (int_32)$5) ){ goto $label$6 }
	goto $label$5 
	
.LABEL $label$7
	$8 = ($3 + [-24])
	
.LABEL $label$6
	
.LOOP $label$10:
	$3	 = ($3 + [-24])
	$5 = *($3)
	*($3) = [0]
	if ( ($5 == 0) ){ goto $label$11 }
	CALL _ZdlPv($5)
	
.LABEL $label$11
	if ( ((int_32)$8 != (int_32)$3) ){ goto $label$10 }
	
.LABEL $label$5
	*(($0 + [28])) = $8
	CALL db_remove_i64(*($1 + [36]))
}

int_32 .FUNC $58 (int_32 $0)
{
	int_32 $1
	int_32 $2
	int_32 $3
	int_32 $4
	int_32 $5
	$1	 = *($0 + [48])
	if ( ($1 == 0) ){ goto $label$1 }
	$2	 = ($0 + [52])
	$3	 = *($2)
	if ( ((int_32)$3 == (int_32)$1) ){ goto $label$3 }
	
.LOOP $label$4:
	$4 = ($3 + [-16])
	$5	 = *(($3 + [-12]))
	if ( ($5 == 0) ){ goto $label$5 }
	*(($3 + [-8])) = $5
	CALL _ZdlPv($5)
	
.LABEL $label$5
	$3 = $4
	if ( ((int_32)$1 != (int_32)$4) ){ goto $label$4 }
	$3 = *(($0 + [48]))
	goto $label$2 
	
.LABEL $label$3
	$3 = $1
	
.LABEL $label$2
	*($2) = $1
	CALL _ZdlPv($3)
	
.LABEL $label$1
	$1	 = *($0 + [36])
	if ( ($1 == 0) ){ goto $label$6 }
	$2	 = ($0 + [40])
	$3	 = *($2)
	if ( ((int_32)$3 == (int_32)$1) ){ goto $label$8 }
	
.LOOP $label$9:
	$4	 = *(($3 + [-12]))
	if ( ($4 == 0) ){ goto $label$10 }
	*(($3 + [-8])) = $4
	CALL _ZdlPv($4)
	
.LABEL $label$10
	$4 = ($3 + [-40])
	$5	 = *(($3 + [-24]))
	if ( ($5 == 0) ){ goto $label$11 }
	*(($3 + [-20])) = $5
	CALL _ZdlPv($5)
	
.LABEL $label$11
	$3 = $4
	if ( ((int_32)$1 != (int_32)$4) ){ goto $label$9 }
	$3 = *(($0 + [36]))
	goto $label$7 
	
.LABEL $label$8
	$3 = $1
	
.LABEL $label$7
	*($2) = $1
	CALL _ZdlPv($3)
	
.LABEL $label$6
	$1	 = *($0 + [24])
	if ( ($1 == 0) ){ goto $label$12 }
	$2	 = ($0 + [28])
	$3	 = *($2)
	if ( ((int_32)$3 == (int_32)$1) ){ goto $label$14 }
	
.LOOP $label$15:
	$4	 = *(($3 + [-12]))
	if ( ($4 == 0) ){ goto $label$16 }
	*(($3 + [-8])) = $4
	CALL _ZdlPv($4)
	
.LABEL $label$16
	$4 = ($3 + [-40])
	$5	 = *(($3 + [-24]))
	if ( ($5 == 0) ){ goto $label$17 }
	*(($3 + [-20])) = $5
	CALL _ZdlPv($5)
	
.LABEL $label$17
	$3 = $4
	if ( ((int_32)$1 != (int_32)$4) ){ goto $label$15 }
	$3 = *(($0 + [24]))
	goto $label$13 
	
.LABEL $label$14
	$3 = $1
	
.LABEL $label$13
	*($2) = $1
	CALL _ZdlPv($3)
	
.LABEL $label$12
	return $0
}

.data 18673 -> ["cannot increment end iterator\00"]
.data 18639 -> ["cannot pass end iterator to erase\00"]
.data 17640 -> ["unlock\00"]
.data 17291 -> ["active\00"]
.data 17558 -> ["no accounts object found\00"]
.data 18357 -> ["object passed to iterator_to is not in multi_index\00"]
.data 17634 -> ["pid:\00"]
void .FUNC $59 (int_32 $0, int_64 $1)
{
	int_32 $2
	int_64 $3
	int_32 $4
	int_32 $5
	int_64 $6
	int_32 $7
	$2	 = ($global$0 - [160])
	$global$0 = $2
	CALL require_auth(*($0))
	CALL prints([17634])     # .data 17634 -> ["pid:"]
	CALL printui($1)
	*(($2 + [136])) = [0]
	*($2 + [120]) = (int_64)-1
	*($2 + [128]) = (int_64)0
	$3	 = *($0)
	*($2 + [104]) = $3
	*($2 + [112]) = $3
	$4 = [0]
	$5	 = CALL db_find_i64($3, $3, (int_64)-5861687656668200960, $1)
	if ( ((int_32)$5 < (int_32)[0]) ){ goto $label$1 }
	$4	 = CALL $60(($2 + [104]), $5)
	CALL eosio_assert(((int_32)*($4 + [40]) == (int_32)($2 + [104])), [18357])     # .data 18357 -> ["object passed to iterator_to is not in multi_index"]
	
.LABEL $label$1
	$5	 = ((int_32)$4 != (int_32)[0])
	CALL eosio_assert($5, [17558])     # .data 17558 -> ["no accounts object found"]
	$3 = *($0)
	*($2 + [24]) = [17291]     # .data 17291 -> ["active"]
	*($2 + [28]) = CALL $109([17291])     # .data 17291 -> ["active"]
	*($2 + [16]) = *($2 + [24])
	*($2 + [56]) = *(CALL $10(($2 + [64]), ($2 + [16])))
	*($2 + [48]) = $3
	$3 = *($0)
	*($2 + [24]) = [17640]     # .data 17640 -> ["unlock"]
	*($2 + [28]) = CALL $109([17640])     # .data 17640 -> ["unlock"]
	*($2 + [8]) = *($2 + [24])
	$1 = *(CALL $10(($2 + [64]), ($2 + [8])))
	$6 = *($4 + [8])
	*(($2 + [40])) = *(($4 + [24]))
	*($2 + [24]) = $6
	*($2 + [32]) = *($4 + [16])
	$0	 = CALL $42(($2 + [64]), ($2 + [48]), $3, $1, ($2 + [24]))
	CALL $43(($2 + [144]), $0)
	$7	 = *($2 + [144])
	CALL send_inline($7, (*($2 + [148]) - $7))
	$7	 = *($2 + [144])
	if ( ($7 == 0) ){ goto $label$2 }
	*($2 + [148]) = $7
	CALL _ZdlPv($7)
	
.LABEL $label$2
	$7	 = *($0 + [28])
	if ( ($7 == 0) ){ goto $label$3 }
	*(($0 + [32])) = $7
	CALL _ZdlPv($7)
	
.LABEL $label$3
	$7	 = *($0 + [16])
	if ( ($7 == 0) ){ goto $label$4 }
	*(($0 + [20])) = $7
	CALL _ZdlPv($7)
	
.LABEL $label$4
	CALL eosio_assert($5, [18639])     # .data 18639 -> ["cannot pass end iterator to erase"]
	CALL eosio_assert($5, [18673])     # .data 18673 -> ["cannot increment end iterator"]
	$0	 = CALL db_next_i64(*($4 + [44]), ($2 + [64]))
	if ( ((int_32)$0 < (int_32)[0]) ){ goto $label$5 }
	CALL $60(($2 + [104]), $0)
	
.LABEL $label$5
	CALL $61(($2 + [104]), $4)
	$5	 = *($2 + [128])
	if ( ($5 == 0) ){ goto $label$6 }
	$7	 = ($2 + [132])
	$4	 = *($7)
	if ( ((int_32)$4 == (int_32)$5) ){ goto $label$8 }
	
.LOOP $label$9:
	$4	 = ($4 + [-24])
	$0 = *($4)
	*($4) = [0]
	if ( ($0 == 0) ){ goto $label$10 }
	CALL _ZdlPv($0)
	
.LABEL $label$10
	if ( ((int_32)$5 != (int_32)$4) ){ goto $label$9 }
	$4 = *(($2 + [128]))
	goto $label$7 
	
.LABEL $label$8
	$4 = $5
	
.LABEL $label$7
	*($7) = $5
	CALL _ZdlPv($4)
	
.LABEL $label$6
	$global$0 = ($2 + [160])
}

.data 17477 -> ["unable to find key\00"]
int_64 .FUNC $50 (int_32 $0)
{
	int_32 $1
	int_64 $2
	int_32 $3
	int_32 $4
	int_32 $5
	$1	 = ($global$0 - [64])
	$global$0 = $1
	*(($1 + [56])) = [0]
	*($1 + [40]) = (int_64)-1
	$2	 = *($0)
	*($1 + [24]) = $2
	*($1 + [32]) = $2
	*($1 + [48]) = (int_64)0
	$3	 = CALL $54(($1 + [24]), (int_64)0, [17477])
	*($1 + [16]) = ((int_64)*($3 + [8]) + (int_64)1)     # .data 17477 -> ["unable to find key"]
	$2 = *($0)
	*($1 + [8]) = ($1 + [16])
	CALL $55(($1 + [24]), $3, $2, ($1 + [8]))
	$2 = *($1 + [16])
	$4	 = *($1 + [48])
	if ( ($4 == 0) ){ goto $label$1 }
	$5	 = ($1 + [52])
	$0	 = *($5)
	if ( ((int_32)$0 == (int_32)$4) ){ goto $label$3 }
	
.LOOP $label$4:
	$0	 = ($0 + [-24])
	$3 = *($0)
	*($0) = [0]
	if ( ($3 == 0) ){ goto $label$5 }
	CALL _ZdlPv($3)
	
.LABEL $label$5
	if ( ((int_32)$4 != (int_32)$0) ){ goto $label$4 }
	$0 = *(($1 + [48]))
	goto $label$2 
	
.LABEL $label$3
	$0 = $4
	
.LABEL $label$2
	*($5) = $4
	CALL _ZdlPv($0)
	
.LABEL $label$1
	$global$0 = ($1 + [64])
	return $2
}

.data 17932 -> ["write\00"]
void .FUNC $51 (int_32 $0, int_32 $1)
{
	int_32 $2
	int_32 $3
	int_32 $4
	int_32 $5
	$2	 = ($global$0 - [16])
	$global$0 = $2
	$3 = *($0)
	$4	 = *($1)
	CALL eosio_assert(((int_32)(*($4 + [8]) - *($4 + [4])) > (int_32)[7]), [17932])     # .data 17932 -> ["write"]
	CALL memcpy(*($4 + [4]), $3, [8])
	*($4 + [4]) = (*($4 + [4]) + [8])
	$3 = *($0 + [4])
	$4	 = *($1)
	CALL eosio_assert(((int_32)(*($4 + [8]) - *($4 + [4])) > (int_32)[7]), [17932])     # .data 17932 -> ["write"]
	CALL memcpy(*($4 + [4]), $3, [8])
	*($4 + [4]) = (*($4 + [4]) + [8])
	$3 = *($0 + [8])
	$4	 = *($1)
	CALL eosio_assert(((int_32)(*($4 + [8]) - *($4 + [4])) > (int_32)[7]), [17932])     # .data 17932 -> ["write"]
	CALL memcpy(*($4 + [4]), $3, [8])
	$5	 = (*($4 + [4]) + [8])
	*($4 + [4]) = $5
	*($2 + [8]) = *($3 + [8])
	CALL eosio_assert(((int_32)(*($4 + [8]) - $5) > (int_32)[7]), [17932])     # .data 17932 -> ["write"]
	CALL memcpy(*($4 + [4]), ($2 + [8]), [8])
	*($4 + [4]) = (*($4 + [4]) + [8])
	$0 = *($0 + [12])
	$4	 = *($1)
	CALL eosio_assert(((int_32)(*($4 + [8]) - *($4 + [4])) > (int_32)[7]), [17932])     # .data 17932 -> ["write"]
	CALL memcpy(*($4 + [4]), $0, [8])
	*($4 + [4]) = (*($4 + [4]) + [8])
	$global$0 = ($2 + [16])
}

void .FUNC $52 (int_32 $0, int_32 $1, int_32 $2, int_32 $3)
{
	int_32 $4
	int_32 $5
	int_32 $6
	int_32 $7
	int_32 $8
	$4	 = *($0)
	$5	 = ((int_32)(*($0 + [4]) - $4) / (int_32)[24])
	$6	 = ($5 + [1])
	if ( ((uint_32)$6 >= (uint_32)[178956971]) ){ goto $label$2 }
	$7 = [178956970]
	$4	 = ((int_32)(*($0 + [8]) - $4) / (int_32)[24])
	if ( ((uint_32)$4 > (uint_32)[89478484]) ){ goto $label$4 }
	$7	 = ($4 << [1])
	$7	 = ( $6 ? $7 : ($7 <= $6) )
	if ( ($7 == 0) ){ goto $label$3 }
	
.LABEL $label$4
	$4 = CALL _Znwj(((int_32)$7 * (int_32)[24]))
	goto $label$1 
	
.LABEL $label$3
	$7 = [0]
	$4 = [0]
	goto $label$1 
	
.LABEL $label$2
	CALL $105($0)
	
.LABEL $label$1
	$6 = *($1)
	*($1) = [0]
	*(($1 = ($4 + ($8 = ((int_32)$5 * (int_32)[24]))))) = $6
	*($1 + [8]) = *($2)
	*($1 + [16]) = *($3)
	$5 = ($4 + ((int_32)$7 * (int_32)[24]))
	$6 = ($1 + [24])
	$7	 = *($0)
	$2	 = *(($0 + [4]))
	if ( ((int_32)$2 == (int_32)$7) ){ goto $label$6 }
	$1 = (($4 + $8) + [-24])
	
.LOOP $label$7:
	$4	 = ($2 + [-24])
	$3 = *($4)
	*($4) = [0]
	*($1) = $3
	*(($1 + [16])) = *(($2 + [-8]))
	*(($1 + [8])) = *(($2 + [-16]))
	$1 = ($1 + [-24])
	$2 = $4
	if ( ((int_32)$7 != (int_32)$4) ){ goto $label$7 }
	$1 = ($1 + [24])
	$7 = *(($0 + [4]))
	$2 = *($0)
	goto $label$5 
	
.LABEL $label$6
	$2 = $7
	
.LABEL $label$5
	*($0) = $1
	*(($0 + [4])) = $6
	*(($0 + [8])) = $5
	if ( ((int_32)$7 == (int_32)$2) ){ goto $label$8 }
	
.LOOP $label$9:
	$7	 = ($7 + [-24])
	$1 = *($7)
	*($7) = [0]
	if ( ($1 == 0) ){ goto $label$10 }
	CALL _ZdlPv($1)
	
.LABEL $label$10
	if ( ((int_32)$2 != (int_32)$7) ){ goto $label$9 }
	
.LABEL $label$8
	if ( ($2 == 0) ){ goto $label$11 }
	CALL _ZdlPv($2)
	
.LABEL $label$11
	(unreachable)
}

void .FUNC $53 (int_64 $0, int_64 $1, int_64 $2, int_32 $3, int_32 $4, int_32 $5, int_32 $6)
{
	int_32 $7
	int_64 $8
	$7	 = ($global$0 - [96])
	$global$0 = $7
	$8 = CALL current_time()
	*(($7 + [44])) = (int_64)0
	*(($7 + [60])) = (int_64)0
	*(($7 + [68])) = (int_64)0
	*($7 + [28]) = [0]
	*($7 + [32]) = [0]
	*($7 + [36 align=4]) = (int_64)0
	*($7 + [52 align=4]) = (int_64)0
	*($7 + [16]) = ((CASTING uint_32)(uint_64 ((uint_64)$8 / (uint_64)(int_64)1000000)) + [60])
	CALL $56(($7 + [52]), $3, $4, $5, $6)
	*($7 + [36]) = $0
	*($7 + [8]) = (int_64)0
	*($7) = $1
	CALL $57(($7 + [80]), ($7 + [16]))
	$3	 = *($7 + [80])
	CALL send_deferred($7, $2, $3, (*($7 + [84]) - $3), [0])
	$3	 = *($7 + [80])
	if ( ($3 == 0) ){ goto $label$1 }
	*($7 + [84]) = $3
	CALL _ZdlPv($3)
	
.LABEL $label$1
	CALL $58(($7 + [16]))
	$global$0 = ($7 + [96])
}

.data 18357 -> ["object passed to iterator_to is not in multi_index\00"]
int_32 .FUNC $54 (int_32 $0, int_64 $1, int_32 $2)
{
	int_32 $3
	int_32 $4
	int_32 $5
	int_32 $6
	$4	 = *(($0 + [28]))
	$3	 = *($0 + [24])
	if ( ((int_32)$3 == (int_32)$4) ){ goto $label$1 }
	
.LOOP $label$3:
	$5	 = ($4 + [-24])
	$6	 = *($5)
	if ( ((int_64)*($6) == (int_64)$1) ){ goto $label$2 }
	$4 = $5
	if ( ((int_32)$3 != (int_32)$5) ){ goto $label$3 }
	goto $label$1 
	
.LABEL $label$2
	if ( ((int_32)$3 == (int_32)$4) ){ goto $label$1 }
	CALL eosio_assert(((int_32)*($6 + [16]) == (int_32)$0), [18357])     # .data 18357 -> ["object passed to iterator_to is not in multi_index"]
	CALL eosio_assert(((int_32)$6 != (int_32)[0]), $2)
	return $6
	
.LABEL $label$1
	$5 = [0]
	$4	 = CALL db_find_i64(*($0), *($0 + [8]), (int_64)7174797156354621440, $1)
	if ( ((int_32)$4 < (int_32)[0]) ){ goto $label$4 }
	$5	 = CALL $77($0, $4)
	CALL eosio_assert(((int_32)*($5 + [16]) == (int_32)$0), [18357])     # .data 18357 -> ["object passed to iterator_to is not in multi_index"]
	
.LABEL $label$4
	CALL eosio_assert(((int_32)$5 != (int_32)[0]), $2)
	return $5
}

.data 17020 -> ["invalid symbol name\00"]
.data 17647 -> ["magnitude of asset amount must be less than 2^62\00"]
.data 18266 -> ["only uppercase letters allowed in symbol_code string\00"]
.data 18221 -> ["string is too long to be a valid symbol_code\00"]
.data 17532 -> ["BIT\00"]
void .FUNC $34 (int_32 $0, int_32 $1)
{
	int_32 $2
	int_32 $3
	int_32 $4
	int_32 $5
	int_64 $6
	int_32 $7
	int_64 $8
	int_32 $9
	int_64 $10
	int_32 $11
	$2	 = ($global$0 - [48])
	$3 = $2
	$global$0 = $2
	*($1 + [8]) = [100]
	$4 = *($0)
	$5	 = CALL $109([17532])
	if ( ($5 <= [8]) ){ goto $label$4 }     # .data 17532 -> ["BIT"]
	CALL eosio_assert([0], [18221])     # .data 18221 -> ["string is too long to be a valid symbol_code"]
	goto $label$3 
	
.LABEL $label$4
	if ( ($5 == 0) ){ goto $label$2 }
	
.LABEL $label$3
	$6 = (int_64)0
	
.LOOP $label$5:
	$7	 = *(($5 + [17531]))
	if ( ((($7 + [-65]) & [255]) <= [26]) ){ goto $label$6 }
	CALL eosio_assert([0], [18266])     # .data 18266 -> ["only uppercase letters allowed in symbol_code string"]
	
.LABEL $label$6
	$6 = ((int_64)((int_64)$6 << (int_64)8) | (int_64)((int_64)(CASTING uint_64)(uint_32 $7) << (int_64)56) >> (int_64)56))
	$5	 = ($5 + [-1])
	if ( $5 ){ goto $label$5 }
	$8 = ((int_64)((int_64)$6 << (int_64)8) | (int_64)4)
	goto $label$1 
	
.LABEL $label$2
	$8 = (int_64)4
	
.LABEL $label$1
	$9 = ($1 + [8])
	CALL eosio_assert([1], [17647])     # .data 17647 -> ["magnitude of asset amount must be less than 2^62"]
	$6 = (uint_64)$8 >> (uint_64)(int_64)8)
	$5 = [0]
	
.LOOP $label$9:
	if ( ((uint_32)(((CASTING uint_32)(uint_64 $6) << [24]) + [-1073741825]) > (uint_32)[452984830]) ){ goto $label$8 }
	$10 = (uint_64)$6 >> (uint_64)(int_64)8)
	if ( ((int_64)((int_64)$6 & (int_64)65280) == (int_64)0) ){ goto $label$10 }
	$6 = $10
	$7 = [1]
	$11	 = $5
	$5 = ($11 + [1])
	if ( ((int_32)$11 < (int_32)[6]) ){ goto $label$9 }
	goto $label$7 
	
.LABEL $label$10
	$6 = $10
	
.LOOP $label$11:
	if ( ((int_64)((int_64)$6 & (int_64)65280) != (int_64)0) ){ goto $label$8 }
	$6 = (uint_64)$6 >> (uint_64)(int_64)8)
	$7 = ((int_32)$5 < (int_32)[6])
	$11	 = ($5 + [1])
	$5 = $11
	if ( $7 ){ goto $label$11 }
	$7 = [1]
	$5 = ($11 + [1])
	if ( ((int_32)$11 < (int_32)[6]) ){ goto $label$9 }
	goto $label$7 
	
.LABEL $label$8
	$7 = [0]
	
.LABEL $label$7
	CALL eosio_assert($7, [17020])     # .data 17020 -> ["invalid symbol name"]
	*(($1 + [24])) = $8
	*($1 + [16]) = (int_64)0
	$5	 = CALL $109([17532])
	if ( ($5 <= [8]) ){ goto $label$15 }     # .data 17532 -> ["BIT"]
	CALL eosio_assert([0], [18221])     # .data 18221 -> ["string is too long to be a valid symbol_code"]
	goto $label$14 
	
.LABEL $label$15
	if ( ($5 == 0) ){ goto $label$13 }
	
.LABEL $label$14
	$6 = (int_64)0
	
.LOOP $label$16:
	$7	 = *(($5 + [17531]))
	if ( ((($7 + [-65]) & [255]) <= [26]) ){ goto $label$17 }
	CALL eosio_assert([0], [18266])     # .data 18266 -> ["only uppercase letters allowed in symbol_code string"]
	
.LABEL $label$17
	$6 = ((int_64)((int_64)$6 << (int_64)8) | (int_64)((int_64)(CASTING uint_64)(uint_32 $7) << (int_64)56) >> (int_64)56))
	$5	 = ($5 + [-1])
	if ( $5 ){ goto $label$16 }
	$8 = ((int_64)((int_64)$6 << (int_64)8) | (int_64)4)
	goto $label$12 
	
.LABEL $label$13
	$8 = (int_64)4
	
.LABEL $label$12
	CALL eosio_assert([1], [17647])     # .data 17647 -> ["magnitude of asset amount must be less than 2^62"]
	$6 = (uint_64)$8 >> (uint_64)(int_64)8)
	$5 = [0]
	
.LOOP $label$20:
	if ( ((uint_32)(((CASTING uint_32)(uint_64 $6) << [24]) + [-1073741825]) > (uint_32)[452984830]) ){ goto $label$19 }
	$10 = (uint_64)$6 >> (uint_64)(int_64)8)
	if ( ((int_64)((int_64)$6 & (int_64)65280) == (int_64)0) ){ goto $label$21 }
	$6 = $10
	$7 = [1]
	$11	 = $5
	$5 = ($11 + [1])
	if ( ((int_32)$11 < (int_32)[6]) ){ goto $label$20 }
	goto $label$18 
	
.LABEL $label$21
	$6 = $10
	
.LOOP $label$22:
	if ( ((int_64)((int_64)$6 & (int_64)65280) != (int_64)0) ){ goto $label$19 }
	$6 = (uint_64)$6 >> (uint_64)(int_64)8)
	$7 = ((int_32)$5 < (int_32)[6])
	$11	 = ($5 + [1])
	$5 = $11
	if ( $7 ){ goto $label$22 }
	$7 = [1]
	$5 = ($11 + [1])
	if ( ((int_32)$11 < (int_32)[6]) ){ goto $label$20 }
	goto $label$18 
	
.LABEL $label$19
	$7 = [0]
	
.LABEL $label$18
	CALL eosio_assert($7, [17020])     # .data 17020 -> ["invalid symbol name"]
	*(($1 + [40])) = $8
	*($1 + [32]) = (int_64)0
	$7	 = $2
	$5	 = ($7 + [-48])
	$global$0 = $5
	*($3 + [12]) = $5
	*($3 + [8]) = $5
	*($3 + [16]) = ($7 + [-7])
	*($3 + [24]) = ($3 + [8])
	*($3 + [36]) = $9
	*($3 + [32]) = $1
	*($3 + [40]) = ($1 + [16])
	*($3 + [44]) = ($1 + [32])
	CALL $38(($3 + [32]), ($3 + [24]))
	$6	 = *($1)
	*($1 + [52]) = CALL db_store_i64(*($4 + [8]), (int_64)7235159544932859904, *(*($0 + [8])), $6, $5, [41])
	if ( (uint_64)($6 <= *($4 + [16])) ){ goto $label$23 }
	*(($4 + [16])) = ( (int_64)-2 ? ((int_64)$6 + (int_64)1) : ((uint_64)$6 > (uint_64)(int_64)-3) )
	
.LABEL $label$23
	$global$0 = ($3 + [48])
}

.data 17932 -> ["write\00"]
void .FUNC $56 (int_32 $0, int_32 $1, int_32 $2, int_32 $3, int_32 $4)
{
	int_32 $5
	int_32 $6
	int_32 $7
	int_32 $8
	int_32 $9
	int_32 $10
	int_32 $11
	$5	 = *($0)
	$6	 = ((int_32)(*($0 + [4]) - $5) / (int_32)[40])
	$7	 = ($6 + [1])
	if ( ((uint_32)$7 >= (uint_32)[107374183]) ){ goto $label$2 }
	$8 = [107374182]
	$5	 = ((int_32)(*($0 + [8]) - $5) / (int_32)[40])
	if ( ((uint_32)$5 > (uint_32)[53687090]) ){ goto $label$4 }
	$8	 = ($5 << [1])
	$8	 = ( $7 ? $8 : ($8 <= $7) )
	if ( ($8 == 0) ){ goto $label$3 }
	
.LABEL $label$4
	$5 = CALL _Znwj(((int_32)$8 * (int_32)[40]))
	goto $label$1 
	
.LABEL $label$3
	$8 = [0]
	$5 = [0]
	goto $label$1 
	
.LABEL $label$2
	CALL $105($0)
	
.LABEL $label$1
	*(($6 = ($5 + ((int_32)$6 * (int_32)[40])))) = *($2)
	*($6 + [8]) = *($3)
	*($6 + [16 align=4]) = (int_64)0
	*(($3 = ($6 + [24]))) = [0]
	$2	 = CALL _Znwj([16])
	*($6 + [16]) = $2
	*($6 + [28 align=4]) = (int_64)0
	*(($6 + [36])) = [0]
	$7	 = ($2 + [16])
	*($3) = $7
	*($2) = *($1)
	*(($2 + [8])) = *(($1 + [8]))
	*(($6 + [20])) = $7
	CALL $46(($6 + [28]), [8])
	$2	 = *($6 + [28])
	CALL eosio_assert(((int_32)(*(($6 + [32])) - $2) > (int_32)[7]), [17932])     # .data 17932 -> ["write"]
	CALL memcpy($2, $4, [8])
	$9 = ($5 + ((int_32)$8 * (int_32)[40]))
	$10 = ($6 + [40])
	$2	 = *($0)
	$7	 = *(($0 + [4]))
	if ( ((int_32)$7 == (int_32)$2) ){ goto $label$6 }
	$11 = ($2 - $7)
	$1 = [0]
	
.LOOP $label$7:
	$8	 = ($7 + $1)
	*((($2 = ($6 + $1)) + [-32])) = *(($8 + [-32]))
	*(($2 + [-40])) = *(($8 + [-40]))
	*(($5 = ($2 + [-24]))) = (int_64)0
	*(($3 = ($2 + [-16]))) = [0]
	$4	 = ($8 + [-24])
	*($5) = *($4)
	$5	 = ($8 + [-16])
	*($3) = *($5)
	*($5) = [0]
	*(($5 = ($2 + [-12]))) = (int_64)0
	*(($2 = ($2 + [-4]))) = [0]
	$3	 = ($8 + [-12])
	*($5) = *($3)
	*($4) = (int_64)0
	$8	 = ($8 + [-4])
	*($2) = *($8)
	*($8) = [0]
	*($3) = (int_64)0
	$1	 = ($1 + [-40])
	if ( ((int_32)$11 != (int_32)$1) ){ goto $label$7 }
	$6 = ($6 + $1)
	$2 = *(($0 + [4]))
	$5 = *($0)
	goto $label$5 
	
.LABEL $label$6
	$5 = $2
	
.LABEL $label$5
	*($0) = $6
	*(($0 + [4])) = $10
	*(($0 + [8])) = $9
	if ( ((int_32)$2 == (int_32)$5) ){ goto $label$8 }
	
.LOOP $label$9:
	$8	 = *(($2 + [-12]))
	if ( ($8 == 0) ){ goto $label$10 }
	*(($2 + [-8])) = $8
	CALL _ZdlPv($8)
	
.LABEL $label$10
	$8 = ($2 + [-40])
	$1	 = *(($2 + [-24]))
	if ( ($1 == 0) ){ goto $label$11 }
	*(($2 + [-20])) = $1
	CALL _ZdlPv($1)
	
.LABEL $label$11
	$2 = $8
	if ( ((int_32)$5 != (int_32)$8) ){ goto $label$9 }
	
.LABEL $label$8
	if ( ($5 == 0) ){ goto $label$12 }
	CALL _ZdlPv($5)
	
.LABEL $label$12
	(unreachable)
}

void .FUNC $57 (int_32 $0, int_32 $1)
{
	int_32 $2
	int_32 $3
	int_32 $4
	$2	 = ($global$0 - [16])
	$global$0 = $2
	$3 = [0]
	*($0 + [8]) = [0]
	*($0) = (int_64)0
	*($2) = [0]
	CALL $85($2, $1)
	$4	 = *($2)
	if ( ($4 == 0) ){ goto $label$2 }
	CALL $46($0, $4)
	$3 = *(($0 + [4]))
	$0 = *($0)
	goto $label$1 
	
.LABEL $label$2
	$0 = [0]
	
.LABEL $label$1
	*($2 + [4]) = $0
	*($2) = $0
	*($2 + [8]) = $3
	CALL $86($2, $1)
	CALL $88(CALL $87(CALL $87($2, ($1 + [24])), ($1 + [36])), ($1 + [48]))
	$global$0 = ($2 + [16])
}

int_32 .FUNC $116 (int_32 $0)
{
	int_32 $1
	int_32 $2
	int_32 $3
	int_32 $4
	int_32 $5
	int_32 $6
	int_32 $7
	int_32 $8
	$1 = *($0 + [8388])
	if ( (*([0] + [8504]) == 0) ){ goto $label$2 }
	$2 = *([0] + [8508])
	goto $label$1 
	
.LABEL $label$2
	$2 = (current_memory)
	*([0] + [8504]) = [1]
	$2	 = ($2 << [16])
	*([0] + [8508]) = $2
	
.LABEL $label$1
	$3 = $2
	$5	 = (current_memory)
	$4	 = uint_32(($2 + [65535]) >> [16])
	if ( ((uint_32)$4 <= (uint_32)$5) ){ goto $label$6 }
	($4 - $5)
	$5 = [0]
	if ( ((int_32)$4 != (int_32)(current_memory)) ){ goto $label$5 }
	$3 = *([0] + [8508])
	
.LABEL $label$6
	$5 = [0]
	*([0] + [8508]) = $3
	if ( ((int_32)$2 < (int_32)[0]) ){ goto $label$5 }
	$4 = ((int_32)$1 * (int_32)[12])
	$5	 = ($2 & [65535])
	if ( ((uint_32)$5 > (uint_32)[64512]) ){ goto $label$8 }
	$5 = (($2 + [65536]) - $5)
	goto $label$7 
	
.LABEL $label$8
	$5 = (($2 + [131072]) - ($2 & [131071]))
	
.LABEL $label$7
	$4 = ($0 + $4)
	$2 = ($5 - $2)
	if ( *([0] + [8504]) ){ goto $label$9 }
	$3 = (current_memory)
	*([0] + [8504]) = [1]
	$3	 = ($3 << [16])
	*([0] + [8508]) = $3
	
.LABEL $label$9
	$4 = ($4 + [8192])
	if ( ((int_32)$2 < (int_32)[0]) ){ goto $label$4 }
	$6 = $3
	$8	 = (current_memory)
	$7	 = (($2 + [7]) & [-8])
	$5	 = uint_32((($7 + $3) + [65535]) >> [16])
	if ( ((uint_32)$5 <= (uint_32)$8) ){ goto $label$10 }
	($5 - $8)
	if ( ((int_32)$5 != (int_32)(current_memory)) ){ goto $label$4 }
	$6 = *([0] + [8508])
	
.LABEL $label$10
	*([0] + [8508]) = ($6 + $7)
	if ( ((int_32)$3 == (int_32)[-1]) ){ goto $label$4 }
	$5	 = *($4)
	$1	 = ($0 + ((int_32)$1 * (int_32)[12]))
	$6	 = *(($1 + [8196]))
	if ( ((int_32)($6 + $5) == (int_32)$3) ){ goto $label$3 }
	$7	 = ($1 + [8200])
	$1	 = *($7)
	if ( ((int_32)$5 == (int_32)$1) ){ goto $label$11 }
	*(($6 = ($6 + $1))) = ((*($6) & [-2147483648]) | (([-4] - $1) + $5))
	*($7) = *($4)
	*($6) = (*($6) & [2147483647])
	
.LABEL $label$11
	$4	 = (*($4) + [1])
	*(($4 = ($0 + [8388]))) = $4
	*(($5 = (($0 = ($0 + ((int_32)$4 * (int_32)[12]))) + [8192]))) = $2
	*(($0 + [8196])) = $3
	
.LABEL $label$5
	return $5
	
.LABEL $label$4
	$3	 = ($0 + ((int_32)$1 * (int_32)[12]))
	$1	 = ($3 + [8200])
	$2	 = *($1)
	$5	 = *($4)
	if ( ((int_32)$5 == (int_32)$2) ){ goto $label$12 }
	*(($3 = (*(($3 + [8196])) + $2))) = ((*($3) & [-2147483648]) | (([-4] - $2) + $5))
	*($1) = *($4)
	*($3) = (*($3) & [2147483647])
	
.LABEL $label$12
	$2	 = ($0 + [8388])
	$3	 = (*($2) + [1])
	*($0 + [8384]) = $3
	*($2) = $3
	return [0]
	
.LABEL $label$3
	*($4) = ($5 + $2)
	return $4
}

int_32 .FUNC $117 (int_32 $0, int_32 $1)
{
	$1	 = ((int_32)$1 * (int_32)$0)
	$0	 = CALL $115([8512], $1)
	CALL memset($0, [0], $1)
	return $0
}

int_32 .FUNC $114 (int_32 $0)
{
	return CALL $115([8512], $0)
}

void .FUNC $35 (int_32 $0, int_32 $1, int_32 $2, int_32 $3)
{
	int_32 $4
	int_32 $5
	int_32 $6
	int_32 $7
	int_32 $8
	$4	 = *($0)
	$5	 = ((int_32)(*($0 + [4]) - $4) / (int_32)[24])
	$6	 = ($5 + [1])
	if ( ((uint_32)$6 >= (uint_32)[178956971]) ){ goto $label$2 }
	$7 = [178956970]
	$4	 = ((int_32)(*($0 + [8]) - $4) / (int_32)[24])
	if ( ((uint_32)$4 > (uint_32)[89478484]) ){ goto $label$4 }
	$7	 = ($4 << [1])
	$7	 = ( $6 ? $7 : ($7 <= $6) )
	if ( ($7 == 0) ){ goto $label$3 }
	
.LABEL $label$4
	$4 = CALL _Znwj(((int_32)$7 * (int_32)[24]))
	goto $label$1 
	
.LABEL $label$3
	$7 = [0]
	$4 = [0]
	goto $label$1 
	
.LABEL $label$2
	CALL $105($0)
	
.LABEL $label$1
	$6 = *($1)
	*($1) = [0]
	*(($1 = ($4 + ($8 = ((int_32)$5 * (int_32)[24]))))) = $6
	*($1 + [8]) = *($2)
	*($1 + [16]) = *($3)
	$5 = ($4 + ((int_32)$7 * (int_32)[24]))
	$6 = ($1 + [24])
	$7	 = *($0)
	$2	 = *(($0 + [4]))
	if ( ((int_32)$2 == (int_32)$7) ){ goto $label$6 }
	$1 = (($4 + $8) + [-24])
	
.LOOP $label$7:
	$4	 = ($2 + [-24])
	$3 = *($4)
	*($4) = [0]
	*($1) = $3
	*(($1 + [16])) = *(($2 + [-8]))
	*(($1 + [8])) = *(($2 + [-16]))
	$1 = ($1 + [-24])
	$2 = $4
	if ( ((int_32)$7 != (int_32)$4) ){ goto $label$7 }
	$1 = ($1 + [24])
	$7 = *(($0 + [4]))
	$2 = *($0)
	goto $label$5 
	
.LABEL $label$6
	$2 = $7
	
.LABEL $label$5
	*($0) = $1
	*(($0 + [4])) = $6
	*(($0 + [8])) = $5
	if ( ((int_32)$7 == (int_32)$2) ){ goto $label$8 }
	
.LOOP $label$9:
	$7	 = ($7 + [-24])
	$1 = *($7)
	*($7) = [0]
	if ( ($1 == 0) ){ goto $label$10 }
	CALL _ZdlPv($1)
	
.LABEL $label$10
	if ( ((int_32)$2 != (int_32)$7) ){ goto $label$9 }
	
.LABEL $label$8
	if ( ($2 == 0) ){ goto $label$11 }
	CALL _ZdlPv($2)
	
.LABEL $label$11
	(unreachable)
}

int_32 .FUNC $112 (int_32 $0, int_32 $1, int_32 $2)
{
	int_32 $3
	*(CALL $106())
	$3 = [22]
	if ( ($1 <= [4]) ){ goto $label$2 }
	$1	 = CALL $113($1, $2)
	if ( ($1 == 0) ){ goto $label$1 }
	*($0) = $1
	$3 = [0]
	
.LABEL $label$2
	return $3
	return .LABEL $label$1
}

int_32 .FUNC $113 (int_32 $0, int_32 $1)
{
	int_32 $2
	int_32 $3
	int_32 $4
	int_32 $5
	int_32 $6
	int_32 $7
	$2 = [0]
	$3	 = ([0] - $0)
	if ( ((int_32)($3 & $0) != (int_32)$0) ){ goto $label$2 }
	if ( ((uint_32)$0 > (uint_32)[16]) ){ goto $label$1 }
	return CALL $114($1)
	
.LABEL $label$2
	*(CALL $106()) = [22]
	return [0]
	
.LABEL $label$1
	$4	 = ($0 + [-1])
	$0	 = CALL $114(($4 + $1))
	if ( ($0 == 0) ){ goto $label$5 }
	$2	 = (($4 + $0) & $3)
	if ( ((int_32)$0 == (int_32)$2) ){ goto $label$4 }
	$3	 = ($0 + [-4])
	$4	 = *($3)
	$1	 = ($4 & [7])
	if ( ($1 == 0) ){ goto $label$3 }
	$4	 = ($0 + ($4 & [-8]))
	$5	 = ($4 + [-8])
	$6 = *($5)
	$7	 = ($2 - $0)
	*($3) = ($1 | $7)
	$3	 = ($4 - $2)
	*(($2 + [-4])) = ($3 | $1)
	$1	 = ($6 & [7])
	*(($2 + [-8])) = ($1 | $7)
	*($5) = ($1 | $3)
	CALL $118($0)
	
.LABEL $label$5
	return $2
	
.LABEL $label$4
	return $0
	
.LABEL $label$3
	$0	 = ($2 - $0)
	*(($2 + [-8])) = (*(($0 + [-8])) + $0)
	*(($2 + [-4])) = (*($3) - $0)
	return $2
}

void .FUNC $110 (int_32 $0)
{
	*($0) = [1]
}

void .FUNC $111 (int_32 $0)
{
	*($0) = [0]
}

void .FUNC $118 (int_32 $0)
{
	int_32 $1
	int_32 $2
	int_32 $3
	if ( ($0 == 0) ){ goto $label$2 }
	$1	 = *([0] + [16896])
	if ( ((int_32)$1 < (int_32)[1]) ){ goto $label$2 }
	$2 = [16704]
	$3 = (((int_32)$1 * (int_32)[12]) + [16704])
	
.LOOP $label$3:
	$1	 = *(($2 + [4]))
	if ( ($1 == 0) ){ goto $label$2 }
	if ( ((uint_32)($1 + [4]) > (uint_32)$0) ){ goto $label$4 }
	if ( ((uint_32)($1 + *($2)) > (uint_32)$0) ){ goto $label$1 }
	
.LABEL $label$4
	$2	 = ($2 + [12])
	if ( ($2 <= $3) ){ goto $label$3 }
	
.LABEL $label$2
	return 
	
.LABEL $label$1
	*(($2 = ($0 + [-4]))) = (*($2) & [2147483647])
}

.data 17793 -> ["updater cannot change primary key when modifying an object\00"]
.data 18043 -> ["subtraction overflow\00"]
.data 18021 -> ["subtraction underflow\00"]
.data 17973 -> ["attempt to subtract asset with different symbol\00"]
.data 17742 -> ["cannot modify objects in table of another contract\00"]
.data 17696 -> ["object passed to modify is not in multi_index\00"]
void .FUNC $29 (int_32 $0, int_32 $1, int_64 $2, int_32 $3)
{
	int_32 $4
	int_64 $5
	int_64 $6
	$4	 = ($global$0 - [64])
	$global$0 = $4
	CALL eosio_assert(((int_32)*($1 + [32]) == (int_32)$0), [17696])     # .data 17696 -> ["object passed to modify is not in multi_index"]
	CALL eosio_assert(((int_64)*($0) == (int_64)CALL $fimport$5()), [17742])     # .data 17742 -> ["cannot modify objects in table of another contract"]
	$5 = *($1 + [8])
	$3	 = *($3)
	CALL eosio_assert(((int_64)*($3 + [8]) == (int_64)*(($1 + [24]))), [17973])     # .data 17973 -> ["attempt to subtract asset with different symbol"]
	$6	 = (int_64)
	*($1 + [16]) = $6(*($1 + [16]) - *($3)))
	CALL eosio_assert(((int_64)$6 > (int_64)-4611686018427387904), [18021])     # .data 18021 -> ["subtraction underflow"]
	CALL eosio_assert(((int_64)*($1 + [16]) < (int_64)4611686018427387904), [18043])     # .data 18043 -> ["subtraction overflow"]
	CALL eosio_assert(((int_64)$5 == (int_64)*($1 + [8])), [17793])     # .data 17793 -> ["updater cannot change primary key when modifying an object"]
	*($4 + [40]) = ($4 + [32])
	*($4 + [36]) = $4
	*($4 + [32]) = $4
	*($4 + [48]) = ($4 + [32])
	*($4 + [60]) = ($1 + [16])
	*($4 + [56]) = $1
	CALL $13(($4 + [56]), ($4 + [48]))
	CALL db_update_i64(*($1 + [36]), $2, $4, [32])
	if ( (uint_64)($5 <= *($0 + [16])) ){ goto $label$1 }
	*(($0 + [16])) = ( (int_64)-2 ? ((int_64)$5 + (int_64)1) : ((uint_64)$5 > (uint_64)(int_64)-3) )
	
.LABEL $label$1
	$global$0 = ($4 + [64])
}

.data 17938 -> ["cannot pass end iterator to modify\00"]
.data 18357 -> ["object passed to iterator_to is not in multi_index\00"]
.data 17409 -> ["overdrawn balance\00"]
.data 17385 -> ["no balance object found\00"]
void .FUNC $28 (int_32 $0, int_64 $1, int_64 $2, int_32 $3)
{
	int_32 $4
	int_32 $5
	int_32 $6
	$4	 = ($global$0 - [96])
	$global$0 = $4
	*((($4 + [56]) + [32])) = [0]
	*($4 + [64]) = $1
	*($4 + [72]) = (int_64)-1
	*($4 + [80]) = (int_64)0
	*($4 + [56]) = *($0)
	$5	 = CALL $18(($4 + [56]), *($3 + [8]), [17385])
	CALL eosio_assert(((int_64)*($5 + [16]) >= (int_64)*($3)), [17409])     # .data 17385 -> ["no balance object found"]     # .data 17409 -> ["overdrawn balance"]
	*($4 + [16]) = $3
	CALL $29(($4 + [56]), $5, $2, ($4 + [16]))
	*((($4 + [16]) + [32])) = [0]
	*($4 + [32]) = (int_64)-1
	*($4 + [40]) = (int_64)0
	$2	 = *($0)
	*($4 + [16]) = $2
	*($4 + [24]) = $2
	$5 = [0]
	$6	 = CALL db_find_i64($2, $2, (int_64)7235159544932859904, (int_64)0)
	if ( ((int_32)$6 < (int_32)[0]) ){ goto $label$1 }
	$5	 = CALL $24(($4 + [16]), $6)
	CALL eosio_assert(((int_32)*($5 + [48]) == (int_32)($4 + [16])), [18357])     # .data 18357 -> ["object passed to iterator_to is not in multi_index"]
	
.LABEL $label$1
	$2 = *($0)
	*($4 + [8]) = $3
	CALL eosio_assert(((int_32)$5 != (int_32)[0]), [17938])     # .data 17938 -> ["cannot pass end iterator to modify"]
	CALL $30(($4 + [16]), $5, $2, ($4 + [8]))
	$5	 = *($4 + [40])
	if ( ($5 == 0) ){ goto $label$2 }
	$6	 = ($4 + [44])
	$3	 = *($6)
	if ( ((int_32)$3 == (int_32)$5) ){ goto $label$4 }
	
.LOOP $label$5:
	$3	 = ($3 + [-24])
	$0 = *($3)
	*($3) = [0]
	if ( ($0 == 0) ){ goto $label$6 }
	CALL _ZdlPv($0)
	
.LABEL $label$6
	if ( ((int_32)$5 != (int_32)$3) ){ goto $label$5 }
	$3 = *(($4 + [40]))
	goto $label$3 
	
.LABEL $label$4
	$3 = $5
	
.LABEL $label$3
	*($6) = $5
	CALL _ZdlPv($3)
	
.LABEL $label$2
	$5	 = *($4 + [80])
	if ( ($5 == 0) ){ goto $label$7 }
	$6	 = ($4 + [84])
	$3	 = *($6)
	if ( ((int_32)$3 == (int_32)$5) ){ goto $label$9 }
	
.LOOP $label$10:
	$3	 = ($3 + [-24])
	$0 = *($3)
	*($3) = [0]
	if ( ($0 == 0) ){ goto $label$11 }
	CALL _ZdlPv($0)
	
.LABEL $label$11
	if ( ((int_32)$5 != (int_32)$3) ){ goto $label$10 }
	$3 = *(($4 + [80]))
	goto $label$8 
	
.LABEL $label$9
	$3 = $5
	
.LABEL $label$8
	*($6) = $5
	CALL _ZdlPv($3)
	
.LABEL $label$7
	$global$0 = ($4 + [96])
}

.data 17932 -> ["write\00"]
.data 17793 -> ["updater cannot change primary key when modifying an object\00"]
.data 17742 -> ["cannot modify objects in table of another contract\00"]
.data 17696 -> ["object passed to modify is not in multi_index\00"]
void .FUNC $55 (int_32 $0, int_32 $1, int_64 $2, int_32 $3)
{
	int_32 $4
	int_64 $5
	$4	 = ($global$0 - [16])
	$global$0 = $4
	CALL eosio_assert(((int_32)*($1 + [16]) == (int_32)$0), [17696])     # .data 17696 -> ["object passed to modify is not in multi_index"]
	CALL eosio_assert(((int_64)*($0) == (int_64)CALL $fimport$5()), [17742])     # .data 17742 -> ["cannot modify objects in table of another contract"]
	*($1 + [8]) = *(*($3))
	$5 = *($1)
	CALL eosio_assert([1], [17793])     # .data 17793 -> ["updater cannot change primary key when modifying an object"]
	CALL eosio_assert([1], [17932])     # .data 17932 -> ["write"]
	CALL memcpy($4, $1, [8])
	CALL eosio_assert([1], [17932])     # .data 17932 -> ["write"]
	CALL memcpy(($4 | [8]), ($1 + [8]), [8])
	CALL db_update_i64(*($1 + [20]), $2, $4, [16])
	if ( (uint_64)($5 <= *($0 + [16])) ){ goto $label$1 }
	*(($0 + [16])) = ( (int_64)-2 ? ((int_64)$5 + (int_64)1) : ((uint_64)$5 > (uint_64)(int_64)-3) )
	
.LABEL $label$1
	$global$0 = ($4 + [16])
}

void .FUNC $107 (int_32 $0)
{
}

int_32 .FUNC $106 ()
{
	return [8220]
}

.data 17938 -> ["cannot pass end iterator to modify\00"]
.data 18357 -> ["object passed to iterator_to is not in multi_index\00"]
.data 17409 -> ["overdrawn balance\00"]
.data 17385 -> ["no balance object found\00"]
void .FUNC $21 (int_32 $0, int_64 $1, int_64 $2, int_32 $3)
{
	int_32 $4
	int_32 $5
	int_32 $6
	$4	 = ($global$0 - [96])
	$global$0 = $4
	*(($4 + [88])) = [0]
	*($4 + [64]) = $1
	*($4 + [72]) = (int_64)-1
	*($4 + [80]) = (int_64)0
	*($4 + [56]) = *($0)
	$1	 = *($3 + [8])
	$5	 = CALL $18(($4 + [56]), $1, [17385])
	CALL eosio_assert(((int_64))(*($5) - *($5 + [16])) >= (int_64)*($3)), [17409])     # .data 17385 -> ["no balance object found"]     # .data 17409 -> ["overdrawn balance"]
	if ( ((int_64)$1 != (int_64)*(($5 + [24]))) ){ goto $label$2 }
	*($4 + [16]) = $3
	CALL $22(($4 + [56]), $5, $2, ($4 + [16]))
	goto $label$1 
	
.LABEL $label$2
	*($4 + [16]) = $3
	CALL $23(($4 + [56]), $5, $2, ($4 + [16]))
	
.LABEL $label$1
	$5 = [0]
	*(($4 + [48])) = [0]
	*($4 + [32]) = (int_64)-1
	$2	 = *($0)
	*($4 + [16]) = $2
	*($4 + [24]) = $2
	*($4 + [40]) = (int_64)0
	$6	 = CALL db_find_i64($2, $2, (int_64)7235159544932859904, (int_64)0)
	if ( ((int_32)$6 < (int_32)[0]) ){ goto $label$3 }
	$5	 = CALL $24(($4 + [16]), $6)
	CALL eosio_assert(((int_32)*($5 + [48]) == (int_32)($4 + [16])), [18357])     # .data 18357 -> ["object passed to iterator_to is not in multi_index"]
	
.LABEL $label$3
	$2 = *($0)
	if ( ((int_64)*(($5 + [40])) != (int_64)*(($3 + [8]))) ){ goto $label$6 }
	*($4 + [8]) = $3
	CALL eosio_assert(((int_32)$5 != (int_32)[0]), [17938])     # .data 17938 -> ["cannot pass end iterator to modify"]
	CALL $25(($4 + [16]), $5, $2, ($4 + [8]))
	$0	 = *($4 + [40])
	if ( $0 ){ goto $label$5 }
	goto $label$4 
	
.LABEL $label$6
	*($4 + [8]) = $3
	CALL eosio_assert(((int_32)$5 != (int_32)[0]), [17938])     # .data 17938 -> ["cannot pass end iterator to modify"]
	CALL $26(($4 + [16]), $5, $2, ($4 + [8]))
	$0	 = *($4 + [40])
	if ( ($0 == 0) ){ goto $label$4 }
	
.LABEL $label$5
	$6	 = ($4 + [44])
	$3	 = *($6)
	if ( ((int_32)$3 == (int_32)$0) ){ goto $label$8 }
	
.LOOP $label$9:
	$3	 = ($3 + [-24])
	$5 = *($3)
	*($3) = [0]
	if ( ($5 == 0) ){ goto $label$10 }
	CALL _ZdlPv($5)
	
.LABEL $label$10
	if ( ((int_32)$0 != (int_32)$3) ){ goto $label$9 }
	$3 = *(($4 + [40]))
	goto $label$7 
	
.LABEL $label$8
	$3 = $0
	
.LABEL $label$7
	*($6) = $0
	CALL _ZdlPv($3)
	
.LABEL $label$4
	$0	 = *($4 + [80])
	if ( ($0 == 0) ){ goto $label$11 }
	$6	 = ($4 + [84])
	$3	 = *($6)
	if ( ((int_32)$3 == (int_32)$0) ){ goto $label$13 }
	
.LOOP $label$14:
	$3	 = ($3 + [-24])
	$5 = *($3)
	*($3) = [0]
	if ( ($5 == 0) ){ goto $label$15 }
	CALL _ZdlPv($5)
	
.LABEL $label$15
	if ( ((int_32)$0 != (int_32)$3) ){ goto $label$14 }
	$3 = *(($4 + [80]))
	goto $label$12 
	
.LABEL $label$13
	$3 = $0
	
.LABEL $label$12
	*($6) = $0
	CALL _ZdlPv($3)
	
.LABEL $label$11
	$global$0 = ($4 + [96])
}

.data 17409 -> ["overdrawn balance\00"]
.data 17385 -> ["no balance object found\00"]
void .FUNC $20 (int_32 $0, int_64 $1, int_32 $2)
{
	int_32 $3
	int_32 $4
	int_64 $5
	int_64 $6
	int_64 $7
	int_32 $8
	$3	 = ($global$0 - [80])
	$global$0 = $3
	CALL require_auth(*($0))
	*(($3 + [72])) = [0]
	*($3 + [48]) = $1
	*($3 + [56]) = (int_64)-1
	*($3 + [64]) = (int_64)0
	*($3 + [40]) = *($0)
	$4	 = CALL $18(($3 + [40]), *($2 + [8]), [17385])
	CALL eosio_assert(((int_64))(*($4) - *($4 + [16])) >= (int_64)*($2)), [17409])     # .data 17385 -> ["no balance object found"]     # .data 17409 -> ["overdrawn balance"]
	$5	 = *($2 + [8])
	*((($3 + [24]) + [8])) = $5
	$6 = *($0)
	$7 = *($2)
	*((($3 + [8]) + [8])) = $5
	*($3 + [24]) = $7
	*($3 + [8]) = $7
	CALL $21($0, $1, $6, ($3 + [8]))
	$4	 = *($3 + [64])
	if ( ($4 == 0) ){ goto $label$1 }
	$8	 = ($3 + [68])
	$2	 = *($8)
	if ( ((int_32)$2 == (int_32)$4) ){ goto $label$3 }
	
.LOOP $label$4:
	$2	 = ($2 + [-24])
	$0 = *($2)
	*($2) = [0]
	if ( ($0 == 0) ){ goto $label$5 }
	CALL _ZdlPv($0)
	
.LABEL $label$5
	if ( ((int_32)$4 != (int_32)$2) ){ goto $label$4 }
	$2 = *(($3 + [64]))
	goto $label$2 
	
.LABEL $label$3
	$2 = $4
	
.LABEL $label$2
	*($8) = $4
	CALL _ZdlPv($2)
	
.LABEL $label$1
	$global$0 = ($3 + [80])
}

.data 17793 -> ["updater cannot change primary key when modifying an object\00"]
.data 17742 -> ["cannot modify objects in table of another contract\00"]
.data 17696 -> ["object passed to modify is not in multi_index\00"]
void .FUNC $23 (int_32 $0, int_32 $1, int_64 $2, int_32 $3)
{
	int_32 $4
	int_64 $5
	$4	 = ($global$0 - [64])
	$global$0 = $4
	CALL eosio_assert(((int_32)*($1 + [32]) == (int_32)$0), [17696])     # .data 17696 -> ["object passed to modify is not in multi_index"]
	CALL eosio_assert(((int_64)*($0) == (int_64)CALL $fimport$5()), [17742])     # .data 17742 -> ["cannot modify objects in table of another contract"]
	$3	 = *($3)
	*($1 + [16]) = *($3)
	*(($1 + [24])) = *(($3 + [8]))
	$5 = *($1 + [8])
	CALL eosio_assert([1], [17793])     # .data 17793 -> ["updater cannot change primary key when modifying an object"]
	*($4 + [40]) = ($4 + [32])
	*($4 + [36]) = $4
	*($4 + [32]) = $4
	*($4 + [48]) = ($4 + [32])
	*($4 + [60]) = ($1 + [16])
	*($4 + [56]) = $1
	CALL $13(($4 + [56]), ($4 + [48]))
	CALL db_update_i64(*($1 + [36]), $2, $4, [32])
	if ( (uint_64)($5 <= *($0 + [16])) ){ goto $label$1 }
	*(($0 + [16])) = ( (int_64)-2 ? ((int_64)$5 + (int_64)1) : ((uint_64)$5 > (uint_64)(int_64)-3) )
	
.LABEL $label$1
	$global$0 = ($4 + [64])
}

.data 17793 -> ["updater cannot change primary key when modifying an object\00"]
.data 17914 -> ["addition overflow\00"]
.data 17895 -> ["addition underflow\00"]
.data 17852 -> ["attempt to add asset with different symbol\00"]
.data 17742 -> ["cannot modify objects in table of another contract\00"]
.data 17696 -> ["object passed to modify is not in multi_index\00"]
void .FUNC $22 (int_32 $0, int_32 $1, int_64 $2, int_32 $3)
{
	int_32 $4
	int_64 $5
	int_64 $6
	$4	 = ($global$0 - [64])
	$global$0 = $4
	CALL eosio_assert(((int_32)*($1 + [32]) == (int_32)$0), [17696])     # .data 17696 -> ["object passed to modify is not in multi_index"]
	CALL eosio_assert(((int_64)*($0) == (int_64)CALL $fimport$5()), [17742])     # .data 17742 -> ["cannot modify objects in table of another contract"]
	$5 = *($1 + [8])
	$3	 = *($3)
	CALL eosio_assert(((int_64)*($3 + [8]) == (int_64)*(($1 + [24]))), [17852])     # .data 17852 -> ["attempt to add asset with different symbol"]
	$6	 = ((int_64)*($1 + [16]) + (int_64)*($3))
	*($1 + [16]) = $6
	CALL eosio_assert(((int_64)$6 > (int_64)-4611686018427387904), [17895])     # .data 17895 -> ["addition underflow"]
	CALL eosio_assert(((int_64)*($1 + [16]) < (int_64)4611686018427387904), [17914])     # .data 17914 -> ["addition overflow"]
	CALL eosio_assert(((int_64)$5 == (int_64)*($1 + [8])), [17793])     # .data 17793 -> ["updater cannot change primary key when modifying an object"]
	*($4 + [40]) = ($4 + [32])
	*($4 + [36]) = $4
	*($4 + [32]) = $4
	*($4 + [48]) = ($4 + [32])
	*($4 + [60]) = ($1 + [16])
	*($4 + [56]) = $1
	CALL $13(($4 + [56]), ($4 + [48]))
	CALL db_update_i64(*($1 + [36]), $2, $4, [32])
	if ( (uint_64)($5 <= *($0 + [16])) ){ goto $label$1 }
	*(($0 + [16])) = ( (int_64)-2 ? ((int_64)$5 + (int_64)1) : ((uint_64)$5 > (uint_64)(int_64)-3) )
	
.LABEL $label$1
	$global$0 = ($4 + [64])
}

.data 17793 -> ["updater cannot change primary key when modifying an object\00"]
.data 17914 -> ["addition overflow\00"]
.data 17895 -> ["addition underflow\00"]
.data 17852 -> ["attempt to add asset with different symbol\00"]
.data 17742 -> ["cannot modify objects in table of another contract\00"]
.data 17696 -> ["object passed to modify is not in multi_index\00"]
void .FUNC $25 (int_32 $0, int_32 $1, int_64 $2, int_32 $3)
{
	int_32 $4
	int_64 $5
	int_64 $6
	$4	 = ($global$0 - [96])
	$global$0 = $4
	CALL eosio_assert(((int_32)*($1 + [48]) == (int_32)$0), [17696])     # .data 17696 -> ["object passed to modify is not in multi_index"]
	CALL eosio_assert(((int_64)*($0) == (int_64)CALL $fimport$5()), [17742])     # .data 17742 -> ["cannot modify objects in table of another contract"]
	$5 = *($1)
	$3	 = *($3)
	CALL eosio_assert(((int_64)*($3 + [8]) == (int_64)*(($1 + [40]))), [17852])     # .data 17852 -> ["attempt to add asset with different symbol"]
	$6	 = ((int_64)*($1 + [32]) + (int_64)*($3))
	*($1 + [32]) = $6
	CALL eosio_assert(((int_64)$6 > (int_64)-4611686018427387904), [17895])     # .data 17895 -> ["addition underflow"]
	CALL eosio_assert(((int_64)*($1 + [32]) < (int_64)4611686018427387904), [17914])     # .data 17914 -> ["addition overflow"]
	CALL eosio_assert(((int_64)$5 == (int_64)*($1)), [17793])     # .data 17793 -> ["updater cannot change primary key when modifying an object"]
	*($4 + [64]) = ($4 + [41])
	*($4 + [60]) = $4
	*($4 + [56]) = $4
	*($4 + [72]) = ($4 + [56])
	*($4 + [84]) = ($1 + [8])
	*($4 + [80]) = $1
	*($4 + [88]) = ($1 + [16])
	*($4 + [92]) = ($1 + [32])
	CALL $38(($4 + [80]), ($4 + [72]))
	CALL db_update_i64(*($1 + [52]), $2, $4, [41])
	if ( (uint_64)($5 <= *($0 + [16])) ){ goto $label$1 }
	*(($0 + [16])) = ( (int_64)-2 ? ((int_64)$5 + (int_64)1) : ((uint_64)$5 > (uint_64)(int_64)-3) )
	
.LABEL $label$1
	$global$0 = ($4 + [96])
}

.data 18408 -> ["error reading iterator\00"]
int_32 .FUNC $24 (int_32 $0, int_32 $1)
{
	int_32 $2
	int_32 $3
	int_32 $4
	int_32 $5
	int_64 $6
	int_32 $7
	int_32 $8
	$2	 = ($global$0 - [48])
	$3 = $2
	$global$0 = $2
	$5	 = *(($0 + [28]))
	$4	 = *($0 + [24])
	if ( ((int_32)$4 == (int_32)$5) ){ goto $label$1 }
	
.LOOP $label$3:
	if ( ((int_32)*(($5 + [-8])) == (int_32)$1) ){ goto $label$2 }
	$5	 = ($5 + [-24])
	if ( ((int_32)$4 != (int_32)$5) ){ goto $label$3 }
	goto $label$1 
	
.LABEL $label$2
	if ( ((int_32)$4 == (int_32)$5) ){ goto $label$1 }
	$5 = *(($5 + [-24]))
	$global$0 = ($3 + [48])
	return $5
	
.LABEL $label$1
	$4	 = CALL db_get_i64($1, [0], [0])
	CALL eosio_assert(((int_32)uint_32($4 >> [31]) ^ (int_32)[1]), [18408])     # .data 18408 -> ["error reading iterator"]
	if ( ($4 <= [513]) ){ goto $label$5 }
	$2 = CALL $114($4)
	goto $label$4 
	
.LABEL $label$5
	$2	 = ($2 - (($4 + [15]) & [-16]))
	$global$0 = $2
	
.LABEL $label$4
	CALL db_get_i64($1, $2, $4)
	*($3 + [12]) = $2
	*($3 + [8]) = $2
	*($3 + [16]) = ($2 + $4)
	*(($5 = CALL _Znwj([64])) + [16]) = (int_64)0
	*($5) = (int_64)0
	*($5 + [24]) = (int_64)0
	*($5 + [32]) = (int_64)0
	*($5 + [40]) = (int_64)0
	*($5 + [48]) = $0
	*($3 + [24]) = ($3 + [8])
	*($3 + [36]) = ($5 + [8])
	*($3 + [32]) = $5
	*($3 + [40]) = ($5 + [16])
	*($3 + [44]) = ($5 + [32])
	CALL $79(($3 + [32]), ($3 + [24]))
	*($5 + [52]) = $1
	*($3 + [24]) = $5
	$6	 = *($5)
	*($3 + [32]) = $6
	*($3 + [4]) = $1
	$7	 = ($0 + [28])
	$8	 = *($7)
	if ( ((uint_32)$8 >= (uint_32)*(($0 + [32]))) ){ goto $label$8 }
	*($8 + [8]) = $6
	*($8 + [16]) = $1
	*($3 + [24]) = [0]
	*($8) = $5
	*($7) = ($8 + [24])
	if ( ((uint_32)$4 >= (uint_32)[513]) ){ goto $label$7 }
	goto $label$6 
	
.LABEL $label$8
	CALL $35(($0 + [24]), ($3 + [24]), ($3 + [32]), ($3 + [4]))
	if ( ($4 <= [513]) ){ goto $label$6 }
	
.LABEL $label$7
	CALL $118($2)
	
.LABEL $label$6
	$1 = *($3 + [24])
	*($3 + [24]) = [0]
	if ( ($1 == 0) ){ goto $label$9 }
	CALL _ZdlPv($1)
	
.LABEL $label$9
	$global$0 = ($3 + [48])
	return $5
}

.data 17409 -> ["overdrawn balance\00"]
.data 17385 -> ["no balance object found\00"]
void .FUNC $27 (int_32 $0, int_64 $1, int_32 $2)
{
	int_32 $3
	int_64 $4
	int_64 $5
	int_64 $6
	int_32 $7
	int_32 $8
	$3	 = ($global$0 - [80])
	$global$0 = $3
	CALL require_auth(*($0))
	*(($3 + [72])) = [0]
	*($3 + [48]) = $1
	*($3 + [56]) = (int_64)-1
	*($3 + [64]) = (int_64)0
	*($3 + [40]) = *($0)
	CALL eosio_assert(((int_64)*(CALL $18(($3 + [40]), *($2 + [8]), [17385]) + [16]) >= (int_64)*($2)), [17409])     # .data 17385 -> ["no balance object found"]     # .data 17409 -> ["overdrawn balance"]
	$4	 = *($2 + [8])
	*((($3 + [24]) + [8])) = $4
	$5 = *($0)
	$6 = *($2)
	*((($3 + [8]) + [8])) = $4
	*($3 + [24]) = $6
	*($3 + [8]) = $6
	CALL $28($0, $1, $5, ($3 + [8]))
	$7	 = *($3 + [64])
	if ( ($7 == 0) ){ goto $label$1 }
	$8	 = ($3 + [68])
	$2	 = *($8)
	if ( ((int_32)$2 == (int_32)$7) ){ goto $label$3 }
	
.LOOP $label$4:
	$2	 = ($2 + [-24])
	$0 = *($2)
	*($2) = [0]
	if ( ($0 == 0) ){ goto $label$5 }
	CALL _ZdlPv($0)
	
.LABEL $label$5
	if ( ((int_32)$7 != (int_32)$2) ){ goto $label$4 }
	$2 = *(($3 + [64]))
	goto $label$2 
	
.LABEL $label$3
	$2 = $7
	
.LABEL $label$2
	*($8) = $7
	CALL _ZdlPv($2)
	
.LABEL $label$1
	$global$0 = ($3 + [80])
}

.data 17793 -> ["updater cannot change primary key when modifying an object\00"]
.data 17742 -> ["cannot modify objects in table of another contract\00"]
.data 17696 -> ["object passed to modify is not in multi_index\00"]
void .FUNC $26 (int_32 $0, int_32 $1, int_64 $2, int_32 $3)
{
	int_32 $4
	int_64 $5
	$4	 = ($global$0 - [96])
	$global$0 = $4
	CALL eosio_assert(((int_32)*($1 + [48]) == (int_32)$0), [17696])     # .data 17696 -> ["object passed to modify is not in multi_index"]
	CALL eosio_assert(((int_64)*($0) == (int_64)CALL $fimport$5()), [17742])     # .data 17742 -> ["cannot modify objects in table of another contract"]
	$3	 = *($3)
	*($1 + [32]) = *($3)
	*(($1 + [40])) = *(($3 + [8]))
	$5 = *($1)
	CALL eosio_assert([1], [17793])     # .data 17793 -> ["updater cannot change primary key when modifying an object"]
	*($4 + [64]) = ($4 + [41])
	*($4 + [60]) = $4
	*($4 + [56]) = $4
	*($4 + [72]) = ($4 + [56])
	*($4 + [84]) = ($1 + [8])
	*($4 + [80]) = $1
	*($4 + [88]) = ($1 + [16])
	*($4 + [92]) = ($1 + [32])
	CALL $38(($4 + [80]), ($4 + [72]))
	CALL db_update_i64(*($1 + [52]), $2, $4, [41])
	if ( (uint_64)($5 <= *($0 + [16])) ){ goto $label$1 }
	*(($0 + [16])) = ( (int_64)-2 ? ((int_64)$5 + (int_64)1) : ((uint_64)$5 > (uint_64)(int_64)-3) )
	
.LABEL $label$1
	$global$0 = ($4 + [96])
}

int_32 .FUNC $109 (int_32 $0)
{
	int_32 $1
	int_32 $2
	int_32 $3
	$1 = $0
	if ( (($0 & [3]) == 0) ){ goto $label$3 }
	if ( (*($0) == 0) ){ goto $label$2 }
	$1 = ($0 + [1])
	
.LOOP $label$4:
	if ( (($1 & [3]) == 0) ){ goto $label$3 }
	$2 = *($1)
	$3	 = ($1 + [1])
	$1 = $3
	if ( $2 ){ goto $label$4 }
	return (($3 + [-1]) - $0)
	
.LABEL $label$3
	$1 = ($1 + [-4])
	
.LOOP $label$5:
	$1	 = ($1 + [4])
	$2	 = *($1)
	if ( (((((int_32)$2 ^ (int_32)[-1]) & ($2 + [-16843009])) & [-2139062144]) == 0) ){ goto $label$5 }
	if ( (($2 & [255]) == 0) ){ goto $label$1 }
	
.LOOP $label$6:
	$2 = *($1 + [1])
	$3	 = ($1 + [1])
	$1 = $3
	if ( $2 ){ goto $label$6 }
	return ($3 - $0)
	
.LABEL $label$2
	return ($0 - $0)
	
.LABEL $label$1
	return ($1 - $0)
}

.data 18357 -> ["object passed to iterator_to is not in multi_index\00"]
int_32 .FUNC $69 (int_32 $0, int_64 $1, int_64 $2, int_32 $3)
{
	int_32 $4
	int_32 $5
	int_32 $6
	int_32 $7
	$4	 = ($global$0 - [80])
	$global$0 = $4
	*(($5 = (($4 + [64]) + [8]))) = *(($3 + [8]))
	*($4 + [64]) = *($3)
	*($0) = $1
	*($0 + [8]) = $2
	$3	 = *($5)
	*((($4 + [24]) + [8])) = $3
	$2	 = *($4 + [64])
	*($0 + [16]) = $2
	*(($0 + [24])) = $3
	*($4 + [24]) = $2
	*(($4 + [56])) = [0]
	*($4 + [32]) = $1
	*($4 + [24]) = $1
	*($4 + [40]) = (int_64)-1
	*($4 + [48]) = (int_64)0
	$3	 = CALL db_find_i64($1, $1, (int_64)7174797156354621440, (int_64)0)
	if ( ((int_32)$3 < (int_32)[0]) ){ goto $label$3 }
	CALL eosio_assert(((int_32)*(CALL $77(($4 + [24]), $3) + [16]) == (int_32)($4 + [24])), [18357])     # .data 18357 -> ["object passed to iterator_to is not in multi_index"]
	$6	 = *($4 + [48])
	if ( $6 ){ goto $label$2 }
	goto $label$1 
	
.LABEL $label$3
	CALL $90(($4 + [8]), ($4 + [24]), *($0), ($4 + [16]))
	$6	 = *($4 + [48])
	if ( ($6 == 0) ){ goto $label$1 }
	
.LABEL $label$2
	$7	 = ($4 + [52])
	$3	 = *($7)
	if ( ((int_32)$3 == (int_32)$6) ){ goto $label$5 }
	
.LOOP $label$6:
	$3	 = ($3 + [-24])
	$5 = *($3)
	*($3) = [0]
	if ( ($5 == 0) ){ goto $label$7 }
	CALL _ZdlPv($5)
	
.LABEL $label$7
	if ( ((int_32)$6 != (int_32)$3) ){ goto $label$6 }
	$3 = *(($4 + [48]))
	goto $label$4 
	
.LABEL $label$5
	$3 = $6
	
.LABEL $label$4
	*($7) = $6
	CALL _ZdlPv($3)
	$global$0 = ($4 + [80])
	return $0
	
.LABEL $label$1
	$global$0 = ($4 + [80])
	return $0
}

int_32 .FUNC $68 (int_64 $0, int_64 $1, int_32 $2)
{
	int_32 $3
	int_32 $4
	int_32 $5
	int_32 $6
	int_32 $7
	int_64 $8
	int_32 $9
	int_32 $10
	$3	 = ($global$0 - [256])
	$4 = $3
	$global$0 = $3
	$5 = *($2 + [4])
	$6 = *($2)
	$2 = [0]
	$7	 = CALL action_data_size()
	if ( ($7 == 0) ){ goto $label$1 }
	if ( ($7 <= [513]) ){ goto $label$3 }
	$2 = CALL $114($7)
	goto $label$2 
	
.LABEL $label$3
	$2	 = ($3 - (($7 + [15]) & [-16]))
	$global$0 = $2
	
.LABEL $label$2
	CALL read_action_data($2, $7)
	
.LABEL $label$1
	*($4 + [128]) = (int_64)0
	*($4 + [120]) = [0]
	*($4 + [136]) = (int_64)0
	*($4 + [144]) = (int_64)0
	*($4 + [152]) = (int_64)0
	*($4 + [108]) = $2
	*($4 + [104]) = $2
	*($4 + [112]) = ($2 + $7)
	*($4 + [240]) = ($4 + [104])
	*($4 + [72]) = ($4 + [120])
	CALL $74(($4 + [72]), ($4 + [240]))
	$3	 = *($4 + [112])
	*((($4 + [56]) + [8])) = $3
	*((($4 + [40]) + [8])) = $3
	$8	 = *($4 + [104])
	*($4 + [40]) = $8
	*($4 + [56]) = $8
	CALL $69(($4 + [72]), $0, $1, ($4 + [40]))
	*(($3 = (($4 + [176]) + [8]))) = *($4 + [136])
	*(($9 = (($4 + [160]) + [8]))) = *($4 + [152])
	*($4 + [176]) = *($4 + [128])
	*($4 + [160]) = *($4 + [144])
	$10 = *($4 + [120])
	*((($4 + [208]) + [8])) = *($9)
	*((($4 + [192]) + [8])) = *($3)
	*($4 + [208]) = *($4 + [160])
	*($4 + [192]) = *($4 + [176])
	$3 = (($4 + [72]) + int_32($5 >> [1]))
	if ( (($5 & [1]) == 0) ){ goto $label$4 }
	$6 = *((*($3) + $6))
	
.LABEL $label$4
	$0	 = *((($4 + [192]) + [8]))
	*((($4 + [240]) + [8])) = $0
	$1	 = *((($4 + [208]) + [8]))
	*((($4 + [224]) + [8])) = $1
	*((($4 + [24]) + [8])) = $0
	*((($4 + [8]) + [8])) = $1
	$0	 = *($4 + [192])
	*($4 + [240]) = $0
	$1	 = *($4 + [208])
	*($4 + [224]) = $1
	*($4 + [24]) = $0
	*($4 + [8]) = $1
	CALL void $3((int_32 ($10 & [255])), (int_32 ($4 + [24])), (int_32 ($4 + [8])), (int_32 $6))
	if ( ($7 <= [513]) ){ goto $label$5 }
	CALL $118($2)
	
.LABEL $label$5
	$global$0 = ($4 + [256])
	return [1]
}

int_32 .FUNC $108 (int_32 $0, int_32 $1, int_32 $2)
{
	int_32 $3
	int_32 $4
	CALL $110([8228])
	$3	 = *([0] + [8236])
	if ( ($3 == 0) ){ goto $label$4 }
	$4	 = *([0] + [8240])
	if ( ((int_32)$4 != (int_32)[32]) ){ goto $label$2 }
	goto $label$3 
	
.LABEL $label$4
	$3 = [8244]
	*([0] + [8236]) = [8244]
	$4	 = *([0] + [8240])
	if ( ((int_32)$4 != (int_32)[32]) ){ goto $label$2 }
	
.LABEL $label$3
	$3	 = CALL $117([260], [1])
	if ( ($3 == 0) ){ goto $label$1 }
	$4 = [0]
	*($3) = *([0] + [8236])
	*([0] + [8236]) = $3
	*([0] + [8240]) = [0]
	
.LABEL $label$2
	*([0] + [8240]) = ($4 + [1])
	*((($3 = ($3 + ($4 << [2]))) + [132])) = $1
	*(($3 + [4])) = $0
	CALL $111([8228])
	return [0]
	
.LABEL $label$1
	CALL $111([8228])
	return [-1]
}

int_32 .FUNC $65 (int_64 $0, int_64 $1, int_32 $2)
{
	int_32 $3
	int_32 $4
	int_32 $5
	int_64 $6
	$3	 = ($global$0 - [144])
	$global$0 = $3
	*(($4 = $3) + [136]) = *($2)
	$2 = [0]
	$5	 = CALL action_data_size()
	if ( ($5 == 0) ){ goto $label$1 }
	if ( ($5 <= [513]) ){ goto $label$3 }
	$2 = CALL $114($5)
	goto $label$2 
	
.LABEL $label$3
	$2	 = ($3 - (($5 + [15]) & [-16]))
	$global$0 = $2
	
.LABEL $label$2
	CALL read_action_data($2, $5)
	
.LABEL $label$1
	*(($4 + [112])) = (int_64)0
	*(($4 + [128])) = [0]
	*($4 + [96]) = (int_64)0
	*($4 + [88]) = (int_64)0
	*($4 + [104]) = (int_64)0
	*($4 + [120]) = (int_64)0
	*($4 + [76]) = $2
	*($4 + [72]) = $2
	*($4 + [80]) = ($2 + $5)
	*($4 + [16]) = ($4 + [72])
	*($4 + [40]) = ($4 + [88])
	CALL $72(($4 + [40]), ($4 + [16]))
	$3	 = *($4 + [80])
	*((($4 + [24]) + [8])) = $3
	*(($4 + [8])) = $3
	$6	 = *($4 + [72])
	*($4) = $6
	*($4 + [24]) = $6
	*($4 + [16]) = CALL $69(($4 + [40]), $0, $1, $4)
	*($4 + [20]) = ($4 + [136])
	CALL $73(($4 + [16]), ($4 + [88]))
	if ( ((uint_32)$5 >= (uint_32)[513]) ){ goto $label$6 }
	$2 = [1]
	if ( (*($4 + [120]) & [1]) ){ goto $label$5 }
	goto $label$4 
	
.LABEL $label$6
	CALL $118($2)
	$2 = [1]
	if ( ((*($4 + [120]) & [1]) == 0) ){ goto $label$4 }
	
.LABEL $label$5
	CALL _ZdlPv(*(($4 + [128])))
	$global$0 = ($4 + [144])
	return $2
	
.LABEL $label$4
	$global$0 = ($4 + [144])
	return $2
}

.data 18431 -> ["read\00"]
int_32 .FUNC $64 (int_64 $0, int_64 $1, int_32 $2)
{
	int_32 $3
	int_32 $4
	int_32 $5
	int_32 $6
	int_64 $7
	$3	 = ($global$0 - [144])
	$global$0 = $3
	*(($4 = $3) + [136]) = *($2)
	$2 = [0]
	$5	 = CALL action_data_size()
	if ( ($5 == 0) ){ goto $label$1 }
	if ( ($5 <= [513]) ){ goto $label$3 }
	$2 = CALL $114($5)
	goto $label$2 
	
.LABEL $label$3
	$2	 = ($3 - (($5 + [15]) & [-16]))
	$global$0 = $2
	
.LABEL $label$2
	CALL read_action_data($2, $5)
	
.LABEL $label$1
	*(($3 = (($4 + [96]) + [16]))) = (int_64)0
	*(($4 + [128])) = [0]
	*($4 + [104]) = (int_64)0
	*($4 + [96]) = (int_64)0
	*($4 + [120]) = (int_64)0
	*($4 + [88]) = ($2 + $5)
	*($4 + [80]) = $2
	CALL eosio_assert(((uint_32)$5 > (uint_32)[7]), [18431])     # .data 18431 -> ["read"]
	CALL memcpy(($4 + [96]), $2, [8])
	$6	 = ($5 & [-8])
	CALL eosio_assert(((int_32)$6 != (int_32)[8]), [18431])     # .data 18431 -> ["read"]
	CALL memcpy((($4 + [96]) + [8]), ($2 + [8]), [8])
	*($4 + [48]) = (int_64)0
	CALL eosio_assert(((int_32)$6 != (int_32)[16]), [18431])     # .data 18431 -> ["read"]
	CALL memcpy(($4 + [48]), ($2 + [16]), [8])
	*($3) = *($4 + [48])
	*($4 + [84]) = ($2 + [24])
	CALL $70(($4 + [80]), (($4 + [96]) + [24]))
	$3	 = *($4 + [88])
	*((($4 + [32]) + [8])) = $3
	*((($4 + [8]) + [8])) = $3
	$7	 = *($4 + [80])
	*($4 + [8]) = $7
	*($4 + [32]) = $7
	*($4 + [24]) = CALL $69(($4 + [48]), $0, $1, ($4 + [8]))
	*($4 + [28]) = ($4 + [136])
	CALL $71(($4 + [24]), ($4 + [96]))
	if ( ((uint_32)$5 >= (uint_32)[513]) ){ goto $label$6 }
	$2 = [1]
	if ( (*($4 + [120]) & [1]) ){ goto $label$5 }
	goto $label$4 
	
.LABEL $label$6
	CALL $118($2)
	$2 = [1]
	if ( ((*($4 + [120]) & [1]) == 0) ){ goto $label$4 }
	
.LABEL $label$5
	CALL _ZdlPv(*(($4 + [128])))
	$global$0 = ($4 + [144])
	return $2
	
.LABEL $label$4
	$global$0 = ($4 + [144])
	return $2
}

.data 18431 -> ["read\00"]
int_32 .FUNC $67 (int_64 $0, int_64 $1, int_32 $2)
{
	int_32 $3
	int_32 $4
	int_32 $5
	int_32 $6
	int_32 $7
	$3	 = ($global$0 - [80])
	$4 = $3
	$global$0 = $3
	$5 = *($2 + [4])
	$6 = *($2)
	$7	 = CALL action_data_size()
	if ( ($7 == 0) ){ goto $label$4 }
	if ( ($7 <= [513]) ){ goto $label$3 }
	$2 = CALL $114($7)
	goto $label$2 
	
.LABEL $label$4
	$2 = [0]
	goto $label$1 
	
.LABEL $label$3
	$2	 = ($3 - (($7 + [15]) & [-16]))
	$global$0 = $2
	
.LABEL $label$2
	CALL read_action_data($2, $7)
	
.LABEL $label$1
	*($4 + [72]) = (int_64)0
	CALL eosio_assert(((uint_32)$7 > (uint_32)[7]), [18431])     # .data 18431 -> ["read"]
	CALL memcpy(($4 + [72]), $2, [8])
	$3	 = ($2 + $7)
	*((($4 + [8]) + [8])) = $3
	*($4 + [28]) = ($2 + [8])
	*($4 + [24]) = $2
	*($4 + [32]) = $3
	*($4 + [8]) = *($4 + [24])
	CALL $69(($4 + [40]), $0, $1, ($4 + [8]))
	$3 = (($4 + [40]) + int_32($5 >> [1]))
	$0 = *($4 + [72])
	if ( (($5 & [1]) == 0) ){ goto $label$5 }
	$6 = *((*($3) + $6))
	
.LABEL $label$5
	CALL void $3((int_32 $0), (int_64 $6))
	if ( ($7 <= [513]) ){ goto $label$6 }
	CALL $118($2)
	
.LABEL $label$6
	$global$0 = ($4 + [80])
	return [1]
}

.data 18431 -> ["read\00"]
int_32 .FUNC $66 (int_64 $0, int_64 $1, int_32 $2)
{
	int_32 $3
	int_32 $4
	int_32 $5
	int_32 $6
	int_32 $7
	int_32 $8
	$3	 = ($global$0 - [160])
	$4 = $3
	$global$0 = $3
	$5 = *($2 + [4])
	$6 = *($2)
	$7	 = CALL action_data_size()
	if ( ($7 == 0) ){ goto $label$4 }
	if ( ($7 <= [513]) ){ goto $label$3 }
	$2 = CALL $114($7)
	goto $label$2 
	
.LABEL $label$4
	$2 = [0]
	goto $label$1 
	
.LABEL $label$3
	$2	 = ($3 - (($7 + [15]) & [-16]))
	$global$0 = $2
	
.LABEL $label$2
	CALL read_action_data($2, $7)
	
.LABEL $label$1
	*(($3 = (($4 + [88]) + [16]))) = (int_64)0
	*($4 + [96]) = (int_64)0
	*($4 + [88]) = (int_64)0
	CALL eosio_assert(((uint_32)$7 > (uint_32)[7]), [18431])     # .data 18431 -> ["read"]
	CALL memcpy(($4 + [88]), $2, [8])
	$8	 = ($7 & [-8])
	CALL eosio_assert(((int_32)$8 != (int_32)[8]), [18431])     # .data 18431 -> ["read"]
	CALL memcpy((($4 + [88]) + [8]), ($2 + [8]), [8])
	*($4 + [56]) = (int_64)0
	CALL eosio_assert(((int_32)$8 != (int_32)[16]), [18431])     # .data 18431 -> ["read"]
	CALL memcpy(($4 + [56]), ($2 + [16]), [8])
	*($3) = *($4 + [56])
	$8	 = ($2 + $7)
	*((($4 + [24]) + [8])) = $8
	*($4 + [44]) = ($2 + [24])
	*($4 + [40]) = $2
	*($4 + [48]) = $8
	*($4 + [24]) = *($4 + [40])
	CALL $69(($4 + [56]), $0, $1, ($4 + [24]))
	*(($8 = (($4 + [112]) + [8]))) = *($3)
	*($4 + [112]) = *($4 + [96])
	$0 = *($4 + [88])
	*((($4 + [128]) + [8])) = *($8)
	*($4 + [128]) = *($4 + [112])
	$3 = (($4 + [56]) + int_32($5 >> [1]))
	if ( (($5 & [1]) == 0) ){ goto $label$5 }
	$6 = *((*($3) + $6))
	
.LABEL $label$5
	$1	 = *((($4 + [128]) + [8]))
	*((($4 + [144]) + [8])) = $1
	*((($4 + [8]) + [8])) = $1
	$1	 = *($4 + [128])
	*($4 + [8]) = $1
	*($4 + [144]) = $1
	CALL void $3((int_32 $0), (int_64 ($4 + [8])), (int_32 $6))
	if ( ($7 <= [513]) ){ goto $label$6 }
	CALL $118($2)
	
.LABEL $label$6
	$global$0 = ($4 + [160])
	return [1]
}

.data 18586 -> ["attempt to remove object that was not in multi_index\00"]
.data 18536 -> ["cannot erase objects in table of another contract\00"]
.data 18491 -> ["object passed to erase is not in multi_index\00"]
void .FUNC $61 (int_32 $0, int_32 $1)
{
	int_32 $2
	int_32 $3
	int_32 $4
	int_32 $5
	int_64 $6
	int_32 $7
	int_32 $8
	CALL eosio_assert(((int_32)*($1 + [40]) == (int_32)$0), [18491])     # .data 18491 -> ["object passed to erase is not in multi_index"]
	CALL eosio_assert(((int_64)*($0) == (int_64)CALL $fimport$5()), [18536])     # .data 18536 -> ["cannot erase objects in table of another contract"]
	$2	 = *($0 + [24])
	$3 = $2
	$4	 = ($0 + [28])
	$5	 = *($4)
	if ( ((int_32)$2 == (int_32)$5) ){ goto $label$1 }
	$6	 = *($1)
	if ( ((int_64)*(*(($5 + [-24]))) != (int_64)$6) ){ goto $label$2 }
	$3 = $5
	goto $label$1 
	
.LABEL $label$2
	$7 = ($2 + [24])
	
.LOOP $label$4:
	if ( ((int_32)$7 == (int_32)$5) ){ goto $label$3 }
	$8 = ($5 + [-48])
	$3	 = ($5 + [-24])
	$5 = $3
	if ( ((int_64)*(*($8)) != (int_64)$6) ){ goto $label$4 }
	goto $label$1 
	
.LABEL $label$3
	$3 = $2
	
.LABEL $label$1
	CALL eosio_assert(((int_32)$3 != (int_32)$2), [18586])     # .data 18586 -> ["attempt to remove object that was not in multi_index"]
	$2	 = *($4)
	if ( ((int_32)$3 == (int_32)$2) ){ goto $label$7 }
	$5 = $3
	
.LOOP $label$8:
	$8 = *($5)
	*($5) = [0]
	$7	 = ($5 + [-24])
	$3 = *($7)
	*($7) = $8
	if ( ($3 == 0) ){ goto $label$9 }
	CALL _ZdlPv($3)
	
.LABEL $label$9
	*(($5 + [-8])) = *(($5 + [16]))
	*(($5 + [-16])) = *(($5 + [8]))
	$5	 = ($5 + [24])
	if ( ((int_32)$2 != (int_32)$5) ){ goto $label$8 }
	$8 = ($5 + [-24])
	$3	 = *(($0 + [28]))
	if ( ((int_32)($3 + [24]) != (int_32)$5) ){ goto $label$6 }
	goto $label$5 
	
.LABEL $label$7
	$8 = ($3 + [-24])
	
.LABEL $label$6
	
.LOOP $label$10:
	$3	 = ($3 + [-24])
	$5 = *($3)
	*($3) = [0]
	if ( ($5 == 0) ){ goto $label$11 }
	CALL _ZdlPv($5)
	
.LABEL $label$11
	if ( ((int_32)$8 != (int_32)$3) ){ goto $label$10 }
	
.LABEL $label$5
	*(($0 + [28])) = $8
	CALL db_remove_i64(*($1 + [44]))
}

.data 18408 -> ["error reading iterator\00"]
int_32 .FUNC $60 (int_32 $0, int_32 $1)
{
	int_32 $2
	int_32 $3
	int_32 $4
	int_32 $5
	int_64 $6
	int_32 $7
	int_32 $8
	$2	 = ($global$0 - [48])
	$3 = $2
	$global$0 = $2
	$5	 = *(($0 + [28]))
	$4	 = *($0 + [24])
	if ( ((int_32)$4 == (int_32)$5) ){ goto $label$1 }
	
.LOOP $label$3:
	if ( ((int_32)*(($5 + [-8])) == (int_32)$1) ){ goto $label$2 }
	$5	 = ($5 + [-24])
	if ( ((int_32)$4 != (int_32)$5) ){ goto $label$3 }
	goto $label$1 
	
.LABEL $label$2
	if ( ((int_32)$4 == (int_32)$5) ){ goto $label$1 }
	$5 = *(($5 + [-24]))
	$global$0 = ($3 + [48])
	return $5
	
.LABEL $label$1
	$4	 = CALL db_get_i64($1, [0], [0])
	CALL eosio_assert(((int_32)uint_32($4 >> [31]) ^ (int_32)[1]), [18408])     # .data 18408 -> ["error reading iterator"]
	if ( ($4 <= [513]) ){ goto $label$5 }
	$2 = CALL $114($4)
	goto $label$4 
	
.LABEL $label$5
	$2	 = ($2 - (($4 + [15]) & [-16]))
	$global$0 = $2
	
.LABEL $label$4
	CALL db_get_i64($1, $2, $4)
	*($3 + [12]) = $2
	*($3 + [8]) = $2
	*($3 + [16]) = ($2 + $4)
	*(($5 = CALL _Znwj([56])) + [24]) = (int_64)0
	*($5 + [16]) = (int_64)0
	*($5 + [40]) = $0
	*($3 + [24]) = ($3 + [8])
	*($3 + [36]) = ($5 + [8])
	*($3 + [32]) = $5
	*($3 + [40]) = ($5 + [16])
	*($3 + [44]) = ($5 + [32])
	CALL $89(($3 + [32]), ($3 + [24]))
	*($5 + [44]) = $1
	*($3 + [24]) = $5
	$6	 = *($5)
	*($3 + [32]) = $6
	*($3 + [4]) = $1
	$7	 = ($0 + [28])
	$8	 = *($7)
	if ( ((uint_32)$8 >= (uint_32)*(($0 + [32]))) ){ goto $label$8 }
	*($8 + [8]) = $6
	*($8 + [16]) = $1
	*($3 + [24]) = [0]
	*($8) = $5
	*($7) = ($8 + [24])
	if ( ((uint_32)$4 >= (uint_32)[513]) ){ goto $label$7 }
	goto $label$6 
	
.LABEL $label$8
	CALL $52(($0 + [24]), ($3 + [24]), ($3 + [32]), ($3 + [4]))
	if ( ($4 <= [513]) ){ goto $label$6 }
	
.LABEL $label$7
	CALL $118($2)
	
.LABEL $label$6
	$1 = *($3 + [24])
	*($3 + [24]) = [0]
	if ( ($1 == 0) ){ goto $label$9 }
	CALL _ZdlPv($1)
	
.LABEL $label$9
	$global$0 = ($3 + [48])
	return $5
}

void .FUNC apply (int_64 $0, int_64 $1, int_64 $2)
{
	int_32 $3
	$3	 = ($global$0 - [176])
	$global$0 = $3
	CALL memory()
	if ( ((int_64)$1 != (int_64)$0) ){ goto $label$1 }
	if ( ((int_64)$2 <= (int_64)-3106564276286914561) ){ goto $label$11 }
	if ( ((int_64)$2 > (int_64)4982871454518345727) ){ goto $label$10 }
	if ( ((int_64)$2 == (int_64)-3106564276286914560) ){ goto $label$8 }
	if ( ((int_64)$2 == (int_64)-3102536759825661952) ){ goto $label$7 }
	if ( ((int_64)$2 != (int_64)4516881727834030080) ){ goto $label$1 }
	*($3 + [156]) = [0]
	*($3 + [152]) = [1]
	*($3 + [16]) = *($3 + [152])
	CALL $64($1, $1, ($3 + [16]))
	goto $label$1 
	
.LABEL $label$11
	if ( ((int_64)$2 <= (int_64)-4708640292171939841) ){ goto $label$9 }
	if ( ((int_64)$2 == (int_64)-4708640292171939840) ){ goto $label$6 }
	if ( ((int_64)$2 == (int_64)-4157661383434960896) ){ goto $label$5 }
	if ( ((int_64)$2 != (int_64)-3617168760277827584) ){ goto $label$1 }
	*($3 + [132]) = [0]
	*($3 + [128]) = [2]
	*($3 + [40]) = *($3 + [128])
	CALL $65($1, $1, ($3 + [40]))
	goto $label$1 
	
.LABEL $label$10
	if ( ((int_64)$2 == (int_64)4982871454518345728) ){ goto $label$4 }
	if ( ((int_64)$2 == (int_64)8516769789752901632) ){ goto $label$3 }
	if ( ((int_64)$2 != (int_64)5031766152489992192) ){ goto $label$1 }
	*($3 + [172]) = [0]
	*($3 + [168]) = [3]
	*($3) = *($3 + [168])
	CALL $66($1, $1, $3)
	goto $label$1 
	
.LABEL $label$9
	if ( ((int_64)$2 == (int_64)-8281838239757631488) ){ goto $label$2 }
	if ( ((int_64)$2 != (int_64)-7807295961876660224) ){ goto $label$1 }
	*($3 + [124]) = [0]
	*($3 + [120]) = [4]
	*($3 + [48]) = *($3 + [120])
	CALL $64($1, $1, ($3 + [48]))
	goto $label$1 
	
.LABEL $label$8
	*($3 + [140]) = [0]
	*($3 + [136]) = [5]
	*($3 + [32]) = *($3 + [136])
	CALL $66($1, $1, ($3 + [32]))
	goto $label$1 
	
.LABEL $label$7
	*($3 + [108]) = [0]
	*($3 + [104]) = [6]
	*($3 + [64]) = *($3 + [104])
	CALL $66($1, $1, ($3 + [64]))
	goto $label$1 
	
.LABEL $label$6
	*($3 + [100]) = [0]
	*($3 + [96]) = [7]
	*($3 + [72]) = *($3 + [96])
	CALL $67($1, $1, ($3 + [72]))
	goto $label$1 
	
.LABEL $label$5
	*($3 + [116]) = [0]
	*($3 + [112]) = [8]
	*($3 + [56]) = *($3 + [112])
	CALL $66($1, $1, ($3 + [56]))
	goto $label$1 
	
.LABEL $label$4
	*($3 + [92]) = [0]
	*($3 + [88]) = [9]
	*($3 + [80]) = *($3 + [88])
	CALL $68($1, $1, ($3 + [80]))
	goto $label$1 
	
.LABEL $label$3
	*($3 + [164]) = [0]
	*($3 + [160]) = [10]
	*($3 + [8]) = *($3 + [160])
	CALL $64($1, $1, ($3 + [8]))
	goto $label$1 
	
.LABEL $label$2
	*($3 + [148]) = [0]
	*($3 + [144]) = [11]
	*($3 + [24]) = *($3 + [144])
	CALL $66($1, $1, ($3 + [24]))
	
.LABEL $label$1
	CALL $107([0])
	$global$0 = ($3 + [176])
}

.data 17793 -> ["updater cannot change primary key when modifying an object\00"]
.data 17742 -> ["cannot modify objects in table of another contract\00"]
.data 17696 -> ["object passed to modify is not in multi_index\00"]
.data 17938 -> ["cannot pass end iterator to modify\00"]
.data 18357 -> ["object passed to iterator_to is not in multi_index\00"]
void .FUNC $62 (int_32 $0, int_32 $1, int_32 $2, int_32 $3)
{
	int_32 $4
	int_64 $5
	int_32 $6
	int_32 $7
	int_64 $8
	$4	 = ($global$0 - [144])
	$global$0 = $4
	CALL require_auth(*($0))
	*((($4 + [8]) + [32])) = [0]
	*($4 + [24]) = (int_64)-1
	$5	 = *($0)
	*($4 + [8]) = $5
	*($4 + [16]) = $5
	*($4 + [32]) = (int_64)0
	$6 = [0]
	$7	 = CALL db_find_i64($5, $5, (int_64)7235159544932859904, (int_64)0)
	if ( ((int_32)$7 < (int_32)[0]) ){ goto $label$1 }
	$6	 = CALL $24(($4 + [8]), $7)
	CALL eosio_assert(((int_32)*($6 + [48]) == (int_32)($4 + [8])), [18357])     # .data 18357 -> ["object passed to iterator_to is not in multi_index"]
	
.LABEL $label$1
	$8 = *($0)
	CALL eosio_assert(((int_32)$6 != (int_32)[0]), [17938])     # .data 17938 -> ["cannot pass end iterator to modify"]
	CALL eosio_assert(((int_32)*($6 + [48]) == (int_32)($4 + [8])), [17696])     # .data 17696 -> ["object passed to modify is not in multi_index"]
	CALL eosio_assert(((int_64)*($4 + [8]) == (int_64)CALL $fimport$5()), [17742])     # .data 17742 -> ["cannot modify objects in table of another contract"]
	*($6 + [8]) = $1
	*(($6 + [24])) = *(($2 + [8]))
	*($6 + [16]) = *($2)
	*($6 + [32]) = *($3)
	*(($6 + [40])) = *(($3 + [8]))
	$5 = *($6)
	CALL eosio_assert([1], [17793])     # .data 17793 -> ["updater cannot change primary key when modifying an object"]
	*($4 + [112]) = (($4 + [48]) + [41])
	*($4 + [108]) = ($4 + [48])
	*($4 + [104]) = ($4 + [48])
	*($4 + [120]) = ($4 + [104])
	*($4 + [132]) = ($6 + [8])
	*($4 + [128]) = $6
	*($4 + [136]) = ($6 + [16])
	*($4 + [140]) = ($6 + [32])
	CALL $38(($4 + [128]), ($4 + [120]))
	CALL db_update_i64(*($6 + [52]), $8, ($4 + [48]), [41])
	$6	 = (($4 + [8]) + [16])
	if ( (uint_64)($5 <= *($6)) ){ goto $label$2 }
	*($6) = ( (int_64)-2 ? ((int_64)$5 + (int_64)1) : ((uint_64)$5 > (uint_64)(int_64)-3) )
	
.LABEL $label$2
	$2	 = *($4 + [32])
	if ( ($2 == 0) ){ goto $label$3 }
	$3	 = ($4 + [36])
	$6	 = *($3)
	if ( ((int_32)$6 == (int_32)$2) ){ goto $label$5 }
	
.LOOP $label$6:
	$6	 = ($6 + [-24])
	$0 = *($6)
	*($6) = [0]
	if ( ($0 == 0) ){ goto $label$7 }
	CALL _ZdlPv($0)
	
.LABEL $label$7
	if ( ((int_32)$2 != (int_32)$6) ){ goto $label$6 }
	$6 = *(($4 + [32]))
	goto $label$4 
	
.LABEL $label$5
	$6 = $2
	
.LABEL $label$4
	*($3) = $2
	CALL _ZdlPv($6)
	
.LABEL $label$3
	$global$0 = ($4 + [144])
}

void .FUNC _ZdaPvSt11align_val_t (int_32 $0, int_32 $1)
{
	CALL _ZdlPvSt11align_val_t($0, $1)
}

void .FUNC _ZdlPvSt11align_val_t (int_32 $0, int_32 $1)
{
	if ( ($0 == 0) ){ goto $label$1 }
	CALL $118($0)
	
.LABEL $label$1
}

int_32 .FUNC $103 (int_32 $0, int_32 $1)
{
	int_32 $2
	int_32 $3
	int_32 $4
	*($0) = (int_64)0
	*(($2 = ($0 + [8]))) = [0]
	if ( (*($1) & [1]) ){ goto $label$1 }
	*($0) = *($1)
	*($2) = *(($1 + [8]))
	return $0
	
.LABEL $label$1
	$2	 = *($1 + [4])
	if ( ((uint_32)$2 >= (uint_32)[-16]) ){ goto $label$2 }
	$3 = *($1 + [8])
	if ( ((uint_32)$2 >= (uint_32)[11]) ){ goto $label$4 }
	*($0) = ($2 << [1])
	$1 = ($0 + [1])
	if ( $2 ){ goto $label$3 }
	*(($1 + $2)) = [0]
	return $0
	
.LABEL $label$4
	$4	 = (($2 + [16]) & [-16])
	$1 = CALL _Znwj($4)
	*($0) = ($4 | [1])
	*($0 + [8]) = $1
	*($0 + [4]) = $2
	
.LABEL $label$3
	CALL memcpy($1, $3, $2)
	*(($1 + $2)) = [0]
	return $0
	
.LABEL $label$2
	CALL abort()
	return (unreachable)
}

void .FUNC $102 (int_32 $0)
{
	CALL abort()
	(unreachable)
}

void .FUNC $105 (int_32 $0)
{
	CALL abort()
	(unreachable)
}

void .FUNC $104 (int_32 $0, int_32 $1)
{
	int_32 $2
	int_32 $3
	int_32 $4
	int_32 $5
	int_32 $6
	int_32 $7
	int_32 $8
	if ( ((uint_32)$1 >= (uint_32)[-16]) ){ goto $label$4 }
	$2	 = *($0)
	if ( ($2 & [1]) ){ goto $label$6 }
	$3 = uint_32($2 >> [1])
	$4 = [10]
	goto $label$5 
	
.LABEL $label$6
	$2	 = *($0)
	$4 = (($2 & [-2]) + [-1])
	$3 = *($0 + [4])
	
.LABEL $label$5
	$5 = [10]
	$1	 = ( $3 ? $1 : ((uint_32)$3 > (uint_32)$1) )
	if ( ($1 <= [11]) ){ goto $label$7 }
	$5 = ((($1 + [16]) & [-16]) + [-1])
	
.LABEL $label$7
	if ( ((int_32)$5 == (int_32)$4) ){ goto $label$10 }
	if ( ((int_32)$5 != (int_32)[10]) ){ goto $label$11 }
	$6 = [1]
	$1 = ($0 + [1])
	$4 = *($0 + [8])
	$7 = [0]
	$8 = [1]
	if ( ($2 & [1]) ){ goto $label$8 }
	goto $label$3 
	
.LABEL $label$11
	$1 = CALL _Znwj(($5 + [1]))
	if ( ((uint_32)$5 > (uint_32)$4) ){ goto $label$9 }
	if ( $1 ){ goto $label$9 }
	
.LABEL $label$10
	return (unreachable)
	
.LABEL $label$9
	$2	 = *($0)
	if ( ($2 & [1]) ){ goto $label$12 }
	$7 = [1]
	$4 = ($0 + [1])
	$6 = [0]
	$8 = [1]
	if ( (($2 & [1]) == 0) ){ goto $label$3 }
	goto $label$8 
	
.LABEL $label$12
	$4 = *($0 + [8])
	$6 = [1]
	$7 = [1]
	$8 = [1]
	if ( (($2 & [1]) == 0) ){ goto $label$3 }
	
.LABEL $label$8
	$2	 = (*($0 + [4]) + [1])
	if ( ($2 == 0) ){ goto $label$1 }
	goto $label$2 
	
.LABEL $label$4
	CALL abort()
	
.LABEL $label$3
	$2	 = (uint_32(($2 & [254]) >> $8) + [1])
	if ( ($2 == 0) ){ goto $label$1 }
	
.LABEL $label$2
	CALL memcpy($1, $4, $2)
	
.LABEL $label$1
	if ( ($6 == 0) ){ goto $label$13 }
	CALL _ZdlPv($4)
	
.LABEL $label$13
	if ( ($7 == 0) ){ goto $label$14 }
	*($0 + [4]) = $3
	*($0 + [8]) = $1
	*($0) = (($5 + [1]) | [1])
	return 
	
.LABEL $label$14
	*($0) = ($3 << [1])
}

.data 18431 -> ["read\00"]
void .FUNC $89 (int_32 $0, int_32 $1)
{
	int_32 $2
	int_32 $3
	int_32 $4
	int_32 $5
	$2	 = ($global$0 - [16])
	$global$0 = $2
	$3 = *($0)
	$4	 = *($1)
	CALL eosio_assert(((uint_32)(*($4 + [8]) - *($4 + [4])) > (uint_32)[7]), [18431])     # .data 18431 -> ["read"]
	CALL memcpy($3, *($4 + [4]), [8])
	*($4 + [4]) = (*($4 + [4]) + [8])
	$3 = *($0 + [4])
	$4	 = *($1)
	CALL eosio_assert(((uint_32)(*($4 + [8]) - *($4 + [4])) > (uint_32)[7]), [18431])     # .data 18431 -> ["read"]
	CALL memcpy($3, *($4 + [4]), [8])
	*($4 + [4]) = (*($4 + [4]) + [8])
	$3 = *($0 + [8])
	$4	 = *($1)
	CALL eosio_assert(((uint_32)(*($4 + [8]) - *($4 + [4])) > (uint_32)[7]), [18431])     # .data 18431 -> ["read"]
	CALL memcpy($3, *($4 + [4]), [8])
	$5	 = (*($4 + [4]) + [8])
	*($4 + [4]) = $5
	*($2 + [8]) = (int_64)0
	CALL eosio_assert(((uint_32)(*($4 + [8]) - $5) > (uint_32)[7]), [18431])     # .data 18431 -> ["read"]
	CALL memcpy(($2 + [8]), *($4 + [4]), [8])
	*($3 + [8]) = *($2 + [8])
	*($4 + [4]) = (*($4 + [4]) + [8])
	$0 = *($0 + [12])
	$4	 = *($1)
	CALL eosio_assert(((uint_32)(*($4 + [8]) - *($4 + [4])) > (uint_32)[7]), [18431])     # .data 18431 -> ["read"]
	CALL memcpy($0, *($4 + [4]), [8])
	*($4 + [4]) = (*($4 + [4]) + [8])
	$global$0 = ($2 + [16])
}

.data 17932 -> ["write\00"]
int_32 .FUNC $88 (int_32 $0, int_32 $1)
{
	int_32 $2
	int_64 $3
	int_32 $4
	int_32 $5
	int_32 $6
	int_32 $7
	$2	 = ($global$0 - [16])
	$global$0 = $2
	$3 = (CASTING uint_64)(uint_32 int_32((*($1 + [4]) - *($1)) >> [4]))
	$4 = *($0 + [4])
	$5 = ($0 + [8])
	
.LOOP $label$1:
	$6 = (CASTING uint_32)(uint_64 $3)
	$3	 = (uint_64)$3 >> (uint_64)(int_64)7
	$7	 = ((int_64)$3) != (int_64)0
	*($2 + [15]) = (($7) << [7]) | ($6 & [127]))
	CALL eosio_assert(((int_32)(*($5) - $4) > (int_32)[0]), [17932])     # .data 17932 -> ["write"]
	$6	 = ($0 + [4])
	CALL memcpy(*($6), ($2 + [15]), [1])
	$4	 = (*($6) + [1])
	*($6) = $4
	if ( $7 ){ goto $label$1 }
	$7	 = *(($1 + [4]))
	$6	 = *($1)
	if ( ((int_32)$6 == (int_32)$7) ){ goto $label$2 }
	$5 = ($0 + [8])
	
.LOOP $label$3:
	CALL eosio_assert(((int_32)(*($5) - $4) > (int_32)[1]), [17932])     # .data 17932 -> ["write"]
	$4	 = ($0 + [4])
	CALL memcpy(*($4), $6, [2])
	*($4) = (*($4) + [2])
	CALL $76($0, ($6 + [4]))
	$6	 = ($6 + [16])
	if ( ((int_32)$6 == (int_32)$7) ){ goto $label$2 }
	$4 = *($4)
	goto $label$3 
	
.LABEL $label$2
	$global$0 = ($2 + [16])
	return $0
}

.data 17932 -> ["write\00"]
int_32 .FUNC $87 (int_32 $0, int_32 $1)
{
	int_32 $2
	int_64 $3
	int_32 $4
	int_32 $5
	int_32 $6
	int_32 $7
	int_32 $8
	$2	 = ($global$0 - [16])
	$global$0 = $2
	$3 = (CASTING uint_64)(uint_32 ((int_32)(*($1 + [4]) - *($1)) / (int_32)[40]))
	$4 = *($0 + [4])
	$5 = ($0 + [8])
	$6 = ($0 + [4])
	
.LOOP $label$1:
	$7 = (CASTING uint_32)(uint_64 $3)
	$3	 = (uint_64)$3 >> (uint_64)(int_64)7
	$8	 = ((int_64)$3) != (int_64)0
	*($2 + [15]) = (($8) << [7]) | ($7 & [127]))
	CALL eosio_assert(((int_32)(*($5) - $4) > (int_32)[0]), [17932])     # .data 17932 -> ["write"]
	CALL memcpy(*($6), ($2 + [15]), [1])
	$4	 = (*($6) + [1])
	*($6) = $4
	if ( $8 ){ goto $label$1 }
	$5	 = *(($1 + [4]))
	$7	 = *($1)
	if ( ((int_32)$7 == (int_32)$5) ){ goto $label$2 }
	$6 = ($0 + [4])
	
.LOOP $label$3:
	$8	 = ($0 + [8])
	CALL eosio_assert(((int_32)(*($8) - $4) > (int_32)[7]), [17932])     # .data 17932 -> ["write"]
	CALL memcpy(*($6), $7, [8])
	$4	 = (*($6) + [8])
	*($6) = $4
	CALL eosio_assert(((int_32)(*($8) - $4) > (int_32)[7]), [17932])     # .data 17932 -> ["write"]
	CALL memcpy(*($6), ($7 + [8]), [8])
	*($6) = (*($6) + [8])
	CALL $76(CALL $75($0, ($7 + [16])), ($7 + [28]))
	$7	 = ($7 + [40])
	if ( ((int_32)$7 == (int_32)$5) ){ goto $label$2 }
	$4 = *($6)
	goto $label$3 
	
.LABEL $label$2
	$global$0 = ($2 + [16])
	return $0
}

.data 17932 -> ["write\00"]
int_32 .FUNC $86 (int_32 $0, int_32 $1)
{
	int_32 $2
	int_32 $3
	int_32 $4
	int_64 $5
	int_32 $6
	int_32 $7
	$2	 = ($global$0 - [16])
	$global$0 = $2
	CALL eosio_assert(((int_32)(*($0 + [8]) - *($0 + [4])) > (int_32)[3]), [17932])     # .data 17932 -> ["write"]
	CALL memcpy(*($0 + [4]), $1, [4])
	$3	 = (*($0 + [4]) + [4])
	*($0 + [4]) = $3
	CALL eosio_assert(((int_32)(*($0 + [8]) - $3) > (int_32)[1]), [17932])     # .data 17932 -> ["write"]
	CALL memcpy(*($0 + [4]), ($1 + [4]), [2])
	$3	 = (*($0 + [4]) + [2])
	*($0 + [4]) = $3
	CALL eosio_assert(((int_32)(*($0 + [8]) - $3) > (int_32)[3]), [17932])     # .data 17932 -> ["write"]
	CALL memcpy(*($0 + [4]), ($1 + [8]), [4])
	$4	 = (*($0 + [4]) + [4])
	*($0 + [4]) = $4
	$5 = *($1 + [12])
	
.LOOP $label$1:
	$3 = (CASTING uint_32)(uint_64 $5)
	$5	 = (uint_64)$5 >> (uint_64)(int_64)7
	$6	 = ((int_64)$5) != (int_64)0
	*($2 + [14]) = (($6) << [7]) | ($3 & [127]))
	CALL eosio_assert(((int_32)(*(($0 + [8])) - $4) > (int_32)[0]), [17932])     # .data 17932 -> ["write"]
	$3	 = ($0 + [4])
	CALL memcpy(*($3), ($2 + [14]), [1])
	$4	 = (*($3) + [1])
	*($3) = $4
	if ( $6 ){ goto $label$1 }
	$7	 = ($0 + [8])
	CALL eosio_assert(((int_32)(*($7) - $4) > (int_32)[0]), [17932])     # .data 17932 -> ["write"]
	$3	 = ($0 + [4])
	CALL memcpy(*($3), ($1 + [16]), [1])
	$4	 = (*($3) + [1])
	*($3) = $4
	$5 = *($1 + [20])
	
.LOOP $label$2:
	$6 = (CASTING uint_32)(uint_64 $5)
	$5	 = (uint_64)$5 >> (uint_64)(int_64)7
	$1	 = ((int_64)$5) != (int_64)0
	*($2 + [15]) = (($1) << [7]) | ($6 & [127]))
	CALL eosio_assert(((int_32)(*($7) - $4) > (int_32)[0]), [17932])     # .data 17932 -> ["write"]
	CALL memcpy(*($3), ($2 + [15]), [1])
	$4	 = (*($3) + [1])
	*($3) = $4
	if ( $1 ){ goto $label$2 }
	$global$0 = ($2 + [16])
	return $0
}

int_32 .FUNC $85 (int_32 $0, int_32 $1)
{
	int_32 $2
	int_64 $3
	int_32 $4
	int_32 $5
	int_32 $6
	int_32 $7
	int_32 $8
	$2	 = *($0)
	*($0) = ($2 + [10])
	$2 = ($2 + [11])
	$3 = *($1 + [12])
	
.LOOP $label$1:
	$2 = ($2 + [1])
	$3	 = (uint_64)$3 >> (uint_64)(int_64)7
	if ( ((int_64)$3) != (int_64)0) ){ goto $label$1 }
	*($0) = $2
	$3 = *($1 + [20])
	
.LOOP $label$2:
	$2 = ($2 + [1])
	$3	 = (uint_64)$3 >> (uint_64)(int_64)7
	if ( ((int_64)$3) != (int_64)0) ){ goto $label$2 }
	*($0) = $2
	$5	 = *($1 + [24])
	$4	 = *(($1 + [28]))
	$3 = (CASTING uint_64)(uint_32 ((int_32)($4 - $5) / (int_32)[40]))
	
.LOOP $label$3:
	$2 = ($2 + [1])
	$3	 = (uint_64)$3 >> (uint_64)(int_64)7
	if ( ((int_64)$3) != (int_64)0) ){ goto $label$3 }
	*($0) = $2
	if ( ((int_32)$5 == (int_32)$4) ){ goto $label$4 }
	
.LOOP $label$5:
	$2 = ($2 + [16])
	$7	 = *($5 + [16])
	$6	 = *(($5 + [20]))
	$8	 = ($6 - $7)
	$3 = (CASTING uint_64)(uint_32 int_32($8 >> [4]))
	
.LOOP $label$6:
	$2 = ($2 + [1])
	$3	 = (uint_64)$3 >> (uint_64)(int_64)7
	if ( ((int_64)$3) != (int_64)0) ){ goto $label$6 }
	if ( ((int_32)$7 == (int_32)$6) ){ goto $label$7 }
	$2 = (($8 & [-16]) + $2)
	
.LABEL $label$7
	$7	 = *($5 + [28])
	$6	 = *(($5 + [32]))
	$2 = (($2 + $6) - $7)
	$3 = (CASTING uint_64)(uint_32 ($6 - $7))
	
.LOOP $label$8:
	$2 = ($2 + [1])
	$3	 = (uint_64)$3 >> (uint_64)(int_64)7
	if ( ((int_64)$3) != (int_64)0) ){ goto $label$8 }
	$5	 = ($5 + [40])
	if ( ((int_32)$5 != (int_32)$4) ){ goto $label$5 }
	*($0) = $2
	
.LABEL $label$4
	$5	 = *($1 + [36])
	$4	 = *(($1 + [40]))
	$3 = (CASTING uint_64)(uint_32 ((int_32)($4 - $5) / (int_32)[40]))
	
.LOOP $label$9:
	$2 = ($2 + [1])
	$3	 = (uint_64)$3 >> (uint_64)(int_64)7
	if ( ((int_64)$3) != (int_64)0) ){ goto $label$9 }
	*($0) = $2
	if ( ((int_32)$5 == (int_32)$4) ){ goto $label$10 }
	
.LOOP $label$11:
	$2 = ($2 + [16])
	$7	 = *($5 + [16])
	$6	 = *(($5 + [20]))
	$8	 = ($6 - $7)
	$3 = (CASTING uint_64)(uint_32 int_32($8 >> [4]))
	
.LOOP $label$12:
	$2 = ($2 + [1])
	$3	 = (uint_64)$3 >> (uint_64)(int_64)7
	if ( ((int_64)$3) != (int_64)0) ){ goto $label$12 }
	if ( ((int_32)$7 == (int_32)$6) ){ goto $label$13 }
	$2 = (($8 & [-16]) + $2)
	
.LABEL $label$13
	$7	 = *($5 + [28])
	$6	 = *(($5 + [32]))
	$2 = (($2 + $6) - $7)
	$3 = (CASTING uint_64)(uint_32 ($6 - $7))
	
.LOOP $label$14:
	$2 = ($2 + [1])
	$3	 = (uint_64)$3 >> (uint_64)(int_64)7
	if ( ((int_64)$3) != (int_64)0) ){ goto $label$14 }
	$5	 = ($5 + [40])
	if ( ((int_32)$5 != (int_32)$4) ){ goto $label$11 }
	*($0) = $2
	
.LABEL $label$10
	$5	 = *($1 + [48])
	$8	 = *(($1 + [52]))
	$3 = (CASTING uint_64)(uint_32 int_32(($8 - $5) >> [4]))
	
.LOOP $label$15:
	$2 = ($2 + [1])
	$3	 = (uint_64)$3 >> (uint_64)(int_64)7
	if ( ((int_64)$3) != (int_64)0) ){ goto $label$15 }
	*($0) = $2
	if ( ((int_32)$5 == (int_32)$8) ){ goto $label$16 }
	
.LOOP $label$17:
	$7	 = *($5 + [4])
	$6	 = *(($5 + [8]))
	$2 = ((($2 + $6) + [2]) - $7)
	$3 = (CASTING uint_64)(uint_32 ($6 - $7))
	
.LOOP $label$18:
	$2 = ($2 + [1])
	$3	 = (uint_64)$3 >> (uint_64)(int_64)7
	if ( ((int_64)$3) != (int_64)0) ){ goto $label$18 }
	$5	 = ($5 + [16])
	if ( ((int_32)$5 != (int_32)$8) ){ goto $label$17 }
	*($0) = $2
	
.LABEL $label$16
	return $0
}

.data 18431 -> ["read\00"]
void .FUNC $84 (int_32 $0, int_32 $1)
{
	int_32 $2
	int_32 $3
	int_32 $4
	int_32 $5
	$2	 = ($global$0 - [16])
	$global$0 = $2
	$3 = *($0)
	$4	 = *($1)
	CALL eosio_assert(((uint_32)(*($4 + [8]) - *($4 + [4])) > (uint_32)[7]), [18431])     # .data 18431 -> ["read"]
	CALL memcpy($3, *($4 + [4]), [8])
	$5	 = (*($4 + [4]) + [8])
	*($4 + [4]) = $5
	*($2 + [8]) = (int_64)0
	CALL eosio_assert(((uint_32)(*($4 + [8]) - $5) > (uint_32)[7]), [18431])     # .data 18431 -> ["read"]
	CALL memcpy(($2 + [8]), *($4 + [4]), [8])
	*($3 + [8]) = *($2 + [8])
	*($4 + [4]) = (*($4 + [4]) + [8])
	$0 = *($0 + [4])
	$4	 = *($1)
	CALL eosio_assert(((uint_32)(*($4 + [8]) - *($4 + [4])) > (uint_32)[7]), [18431])     # .data 18431 -> ["read"]
	CALL memcpy($0, *($4 + [4]), [8])
	$1	 = (*($4 + [4]) + [8])
	*($4 + [4]) = $1
	*($2 + [8]) = (int_64)0
	CALL eosio_assert(((uint_32)(*($4 + [8]) - $1) > (uint_32)[7]), [18431])     # .data 18431 -> ["read"]
	CALL memcpy(($2 + [8]), *($4 + [4]), [8])
	*($0 + [8]) = *($2 + [8])
	*($4 + [4]) = (*($4 + [4]) + [8])
	$global$0 = ($2 + [16])
}

.data 17932 -> ["write\00"]
int_32 .FUNC $83 (int_32 $0, int_32 $1)
{
	int_32 $2
	int_32 $3
	int_64 $4
	int_32 $5
	int_32 $6
	int_32 $7
	int_32 $8
	$2	 = ($global$0 - [16])
	$global$0 = $2
	$3	 = *($1)
	$4 = (CASTING uint_64)(uint_32 ( *($1 + [4]) ? uint_32($3 >> [1]) : ($3 & [1]) ))
	$5 = *($0 + [4])
	$6 = ($0 + [8])
	$3 = ($0 + [4])
	
.LOOP $label$1:
	$7 = (CASTING uint_32)(uint_64 $4)
	$4	 = (uint_64)$4 >> (uint_64)(int_64)7
	$8	 = ((int_64)$4) != (int_64)0
	*($2 + [15]) = (($8) << [7]) | ($7 & [127]))
	CALL eosio_assert(((int_32)(*($6) - $5) > (int_32)[0]), [17932])     # .data 17932 -> ["write"]
	CALL memcpy(*($3), ($2 + [15]), [1])
	$5	 = (*($3) + [1])
	*($3) = $5
	if ( $8 ){ goto $label$1 }
	$7	 = ($3 & [1])
	$3	 = *($1)
	$3	 = ( *(($1 + [4])) ? uint_32($3 >> [1]) : $7 )
	if ( ($3 == 0) ){ goto $label$2 }
	$8 = *($1 + [8])
	CALL eosio_assert(((int_32)(*(($0 + [8])) - $5) >= (int_32)$3), [17932])     # .data 17932 -> ["write"]
	$5	 = ($0 + [4])
	CALL memcpy(*($5), ( $8 ? ($1 + [1]) : $7 ), $3)
	*($5) = (*($5) + $3)
	
.LABEL $label$2
	$global$0 = ($2 + [16])
	return $0
}

.data 17932 -> ["write\00"]
void .FUNC $82 (int_32 $0, int_32 $1)
{
	int_32 $2
	int_32 $3
	int_32 $4
	$2	 = ($global$0 - [16])
	$global$0 = $2
	$3 = *($0)
	$4	 = *($1)
	CALL eosio_assert(((int_32)(*($4 + [8]) - *($4 + [4])) > (int_32)[7]), [17932])     # .data 17932 -> ["write"]
	CALL memcpy(*($4 + [4]), $3, [8])
	*($4 + [4]) = (*($4 + [4]) + [8])
	$0 = *($0)
	$4	 = *($1)
	CALL eosio_assert(((int_32)(*($4 + [8]) - *($4 + [4])) > (int_32)[7]), [17932])     # .data 17932 -> ["write"]
	CALL memcpy(*($4 + [4]), ($0 + [8]), [8])
	*($4 + [4]) = (*($4 + [4]) + [8])
	$4	 = *($1)
	CALL eosio_assert(((int_32)(*($4 + [8]) - *($4 + [4])) > (int_32)[7]), [17932])     # .data 17932 -> ["write"]
	CALL memcpy(*($4 + [4]), ($0 + [16]), [8])
	$3	 = (*($4 + [4]) + [8])
	*($4 + [4]) = $3
	*($2 + [8]) = *(($0 + [24]))
	CALL eosio_assert(((int_32)(*($4 + [8]) - $3) > (int_32)[7]), [17932])     # .data 17932 -> ["write"]
	CALL memcpy(*($4 + [4]), ($2 + [8]), [8])
	*($4 + [4]) = (*($4 + [4]) + [8])
	CALL $83(*($1), ($0 + [32]))
	$global$0 = ($2 + [16])
}

void .FUNC $81 (int_32 $0, int_32 $1, int_32 $2, int_32 $3)
{
	int_32 $4
	int_32 $5
	int_32 $6
	int_32 $7
	int_32 $8
	$4	 = *($0)
	$5	 = ((int_32)(*($0 + [4]) - $4) / (int_32)[24])
	$6	 = ($5 + [1])
	if ( ((uint_32)$6 >= (uint_32)[178956971]) ){ goto $label$2 }
	$7 = [178956970]
	$4	 = ((int_32)(*($0 + [8]) - $4) / (int_32)[24])
	if ( ((uint_32)$4 > (uint_32)[89478484]) ){ goto $label$4 }
	$7	 = ($4 << [1])
	$7	 = ( $6 ? $7 : ($7 <= $6) )
	if ( ($7 == 0) ){ goto $label$3 }
	
.LABEL $label$4
	$4 = CALL _Znwj(((int_32)$7 * (int_32)[24]))
	goto $label$1 
	
.LABEL $label$3
	$7 = [0]
	$4 = [0]
	goto $label$1 
	
.LABEL $label$2
	CALL $105($0)
	
.LABEL $label$1
	$6 = *($1)
	*($1) = [0]
	*(($1 = ($4 + ($8 = ((int_32)$5 * (int_32)[24]))))) = $6
	*($1 + [8]) = *($2)
	*($1 + [16]) = *($3)
	$5 = ($4 + ((int_32)$7 * (int_32)[24]))
	$6 = ($1 + [24])
	$7	 = *($0)
	$2	 = *(($0 + [4]))
	if ( ((int_32)$2 == (int_32)$7) ){ goto $label$6 }
	$1 = (($4 + $8) + [-24])
	
.LOOP $label$7:
	$4	 = ($2 + [-24])
	$3 = *($4)
	*($4) = [0]
	*($1) = $3
	*(($1 + [16])) = *(($2 + [-8]))
	*(($1 + [8])) = *(($2 + [-16]))
	$1 = ($1 + [-24])
	$2 = $4
	if ( ((int_32)$7 != (int_32)$4) ){ goto $label$7 }
	$1 = ($1 + [24])
	$7 = *(($0 + [4]))
	$2 = *($0)
	goto $label$5 
	
.LABEL $label$6
	$2 = $7
	
.LABEL $label$5
	*($0) = $1
	*(($0 + [4])) = $6
	*(($0 + [8])) = $5
	if ( ((int_32)$7 == (int_32)$2) ){ goto $label$8 }
	
.LOOP $label$9:
	$7	 = ($7 + [-24])
	$1 = *($7)
	*($7) = [0]
	if ( ($1 == 0) ){ goto $label$10 }
	CALL _ZdlPv($1)
	
.LABEL $label$10
	if ( ((int_32)$2 != (int_32)$7) ){ goto $label$9 }
	
.LABEL $label$8
	if ( ($2 == 0) ){ goto $label$11 }
	CALL _ZdlPv($2)
	
.LABEL $label$11
	(unreachable)
}

.data 18431 -> ["read\00"]
void .FUNC $80 (int_32 $0, int_32 $1)
{
	int_32 $2
	int_32 $3
	int_32 $4
	int_32 $5
	$2	 = ($global$0 - [16])
	$global$0 = $2
	$3 = *($0)
	$4	 = *($1)
	CALL eosio_assert(((uint_32)(*($4 + [8]) - *($4 + [4])) > (uint_32)[7]), [18431])     # .data 18431 -> ["read"]
	CALL memcpy($3, *($4 + [4]), [8])
	$5	 = (*($4 + [4]) + [8])
	*($4 + [4]) = $5
	*($2 + [8]) = (int_64)0
	CALL eosio_assert(((uint_32)(*($4 + [8]) - $5) > (uint_32)[7]), [18431])     # .data 18431 -> ["read"]
	CALL memcpy(($2 + [8]), *($4 + [4]), [8])
	*($3 + [8]) = *($2 + [8])
	*($4 + [4]) = (*($4 + [4]) + [8])
	$3 = *($0 + [4])
	$4	 = *($1)
	CALL eosio_assert(((uint_32)(*($4 + [8]) - *($4 + [4])) > (uint_32)[7]), [18431])     # .data 18431 -> ["read"]
	CALL memcpy($3, *($4 + [4]), [8])
	$5	 = (*($4 + [4]) + [8])
	*($4 + [4]) = $5
	*($2 + [8]) = (int_64)0
	CALL eosio_assert(((uint_32)(*($4 + [8]) - $5) > (uint_32)[7]), [18431])     # .data 18431 -> ["read"]
	CALL memcpy(($2 + [8]), *($4 + [4]), [8])
	*($3 + [8]) = *($2 + [8])
	*($4 + [4]) = (*($4 + [4]) + [8])
	$0 = *($0 + [8])
	$4	 = *($1)
	CALL eosio_assert(((uint_32)(*($4 + [8]) - *($4 + [4])) > (uint_32)[7]), [18431])     # .data 18431 -> ["read"]
	CALL memcpy($0, *($4 + [4]), [8])
	*($4 + [4]) = (*($4 + [4]) + [8])
	$global$0 = ($2 + [16])
}

.data 18431 -> ["read\00"]
void .FUNC $72 (int_32 $0, int_32 $1)
{
	int_32 $2
	int_32 $3
	int_32 $4
	$2	 = ($global$0 - [16])
	$global$0 = $2
	$3 = *($0)
	$4	 = *($1)
	CALL eosio_assert(((uint_32)(*($4 + [8]) - *($4 + [4])) > (uint_32)[7]), [18431])     # .data 18431 -> ["read"]
	CALL memcpy($3, *($4 + [4]), [8])
	*($4 + [4]) = (*($4 + [4]) + [8])
	$0 = *($0)
	$4	 = *($1)
	CALL eosio_assert(((uint_32)(*($4 + [8]) - *($4 + [4])) > (uint_32)[7]), [18431])     # .data 18431 -> ["read"]
	CALL memcpy(($0 + [8]), *($4 + [4]), [8])
	*($4 + [4]) = (*($4 + [4]) + [8])
	$4	 = *($1)
	CALL eosio_assert(((uint_32)(*($4 + [8]) - *($4 + [4])) > (uint_32)[7]), [18431])     # .data 18431 -> ["read"]
	CALL memcpy(($0 + [16]), *($4 + [4]), [8])
	$3	 = (*($4 + [4]) + [8])
	*($4 + [4]) = $3
	*($2 + [8]) = (int_64)0
	CALL eosio_assert(((uint_32)(*($4 + [8]) - $3) > (uint_32)[7]), [18431])     # .data 18431 -> ["read"]
	CALL memcpy(($2 + [8]), *($4 + [4]), [8])
	*(($0 + [24])) = *($2 + [8])
	*($4 + [4]) = (*($4 + [4]) + [8])
	CALL $70(*($1), ($0 + [32]))
	$global$0 = ($2 + [16])
}

void .FUNC $73 (int_32 $0, int_32 $1)
{
	int_32 $2
	int_32 $3
	int_64 $4
	int_64 $5
	int_32 $6
	int_32 $7
	$2	 = ($global$0 - [96])
	$global$0 = $2
	*(($3 = (($2 + [32]) + [8]))) = *(($1 + [24]))
	*($2 + [32]) = *($1 + [16])
	$4 = *($1 + [8])
	$5 = *($1)
	$1 = CALL $103(($2 + [16]), ($1 + [32]))
	*((($2 + [48]) + [8])) = *($3)
	*($2 + [48]) = *($2 + [32])
	$0	 = *($0 + [4])
	$6	 = *($0 + [4])
	$3 = (*($0) + int_32($6 >> [1]))
	$0 = *($0)
	if ( (($6 & [1]) == 0) ){ goto $label$1 }
	$0 = *((*($3) + $0))
	
.LABEL $label$1
	*(($7 = (($2 + [80]) + [8]))) = *((($2 + [48]) + [8]))
	*($2 + [80]) = *($2 + [48])
	$6 = CALL $103(($2 + [64]), $1)
	*(($2 + [8])) = *($7)
	*($2) = *($2 + [80])
	CALL void $3((int_32 $5), (int_64 $4), (int_64 $2), (int_32 $6), (int_32 $0))
	if ( (*($2 + [64]) & [1]) ){ goto $label$4 }
	if ( (*($1) & [1]) ){ goto $label$3 }
	goto $label$2 
	
.LABEL $label$4
	CALL _ZdlPv(*($6 + [8]))
	if ( ((*($1) & [1]) == 0) ){ goto $label$2 }
	
.LABEL $label$3
	CALL _ZdlPv(*($1 + [8]))
	$global$0 = ($2 + [96])
	return 
	
.LABEL $label$2
	$global$0 = ($2 + [96])
}

int_32 .FUNC $70 (int_32 $0, int_32 $1)
{
	int_32 $2
	int_32 $3
	int_32 $4
	int_32 $5
	int_32 $6
	int_32 $7
	$2	 = ($global$0 - [32])
	$global$0 = $2
	*($2 + [24]) = [0]
	*($2 + [16]) = (int_64)0
	CALL $92($0, ($2 + [16]))
	$3	 = *($2 + [16])
	$4	 = (*($2 + [20]) - $3)
	if ( ($4 == 0) ){ goto $label$8 }
	*(($2 + [8])) = [0]
	*($2) = (int_64)0
	if ( ((uint_32)$4 >= (uint_32)[-16]) ){ goto $label$3 }
	if ( ((uint_32)$4 > (uint_32)[10]) ){ goto $label$7 }
	*($2) = ($4 << [1])
	$5 = ($2 | [1])
	goto $label$6 
	
.LABEL $label$8
	if ( (*($1) & [1]) ){ goto $label$5 }
	*($1) = [0]
	$3 = ($1 + [8])
	goto $label$4 
	
.LABEL $label$7
	$6	 = (($4 + [16]) & [-16])
	$5 = CALL _Znwj($6)
	*($2) = ($6 | [1])
	*($2 + [8]) = $5
	*($2 + [4]) = $4
	
.LABEL $label$6
	$7 = $4
	$6 = $5
	
.LOOP $label$9:
	*($6) = *($3)
	$6 = ($6 + [1])
	$3 = ($3 + [1])
	$7	 = ($7 + [-1])
	if ( $7 ){ goto $label$9 }
	*(($5 + $4)) = [0]
	if ( (*($1) & [1]) ){ goto $label$11 }
	*($1) = [0]
	goto $label$10 
	
.LABEL $label$11
	*(*($1 + [8])) = [0]
	*($1 + [4]) = [0]
	
.LABEL $label$10
	CALL $104($1, [0])
	*(($1 + [8])) = *(($2 + [8]))
	*($1) = *($2)
	$3	 = *($2 + [16])
	if ( ($3 == 0) ){ goto $label$1 }
	goto $label$2 
	
.LABEL $label$5
	*(*($1 + [8])) = [0]
	*($1 + [4]) = [0]
	$3 = ($1 + [8])
	
.LABEL $label$4
	CALL $104($1, [0])
	*($3) = [0]
	*($1) = (int_64)0
	$3	 = *($2 + [16])
	if ( $3 ){ goto $label$2 }
	goto $label$1 
	
.LABEL $label$3
	CALL $102($2)
	
.LABEL $label$2
	*($2 + [20]) = $3
	CALL _ZdlPv($3)
	
.LABEL $label$1
	$global$0 = ($2 + [32])
	(unreachable)
	return $0
}

void .FUNC $71 (int_32 $0, int_32 $1)
{
	int_32 $2
	int_32 $3
	int_64 $4
	int_32 $5
	int_32 $6
	$2	 = ($global$0 - [96])
	$global$0 = $2
	*(($3 = (($2 + [32]) + [8]))) = *(($1 + [16]))
	*($2 + [32]) = *($1 + [8])
	$4 = *($1)
	$1 = CALL $103(($2 + [16]), ($1 + [24]))
	*((($2 + [48]) + [8])) = *($3)
	*($2 + [48]) = *($2 + [32])
	$0	 = *($0 + [4])
	$5	 = *($0 + [4])
	$3 = (*($0) + int_32($5 >> [1]))
	$0 = *($0)
	if ( (($5 & [1]) == 0) ){ goto $label$1 }
	$0 = *((*($3) + $0))
	
.LABEL $label$1
	*(($6 = (($2 + [80]) + [8]))) = *((($2 + [48]) + [8]))
	*($2 + [80]) = *($2 + [48])
	$5 = CALL $103(($2 + [64]), $1)
	*(($2 + [8])) = *($6)
	*($2) = *($2 + [80])
	CALL void $3((int_32 $4), (int_64 $2), (int_32 $5), (int_32 $0))
	if ( (*($2 + [64]) & [1]) ){ goto $label$4 }
	if ( (*($1) & [1]) ){ goto $label$3 }
	goto $label$2 
	
.LABEL $label$4
	CALL _ZdlPv(*($5 + [8]))
	if ( ((*($1) & [1]) == 0) ){ goto $label$2 }
	
.LABEL $label$3
	CALL _ZdlPv(*($1 + [8]))
	$global$0 = ($2 + [96])
	return 
	
.LABEL $label$2
	$global$0 = ($2 + [96])
}

.data 17932 -> ["write\00"]
int_32 .FUNC $76 (int_32 $0, int_32 $1)
{
	int_32 $2
	int_64 $3
	int_32 $4
	int_32 $5
	int_32 $6
	int_32 $7
	int_32 $8
	$2	 = ($global$0 - [16])
	$global$0 = $2
	$3 = (CASTING uint_64)(uint_32 (*($1 + [4]) - *($1)))
	$4 = *($0 + [4])
	$5 = ($0 + [8])
	$6 = ($0 + [4])
	
.LOOP $label$1:
	$7 = (CASTING uint_32)(uint_64 $3)
	$3	 = (uint_64)$3 >> (uint_64)(int_64)7
	$8	 = ((int_64)$3) != (int_64)0
	*($2 + [15]) = (($8) << [7]) | ($7 & [127]))
	CALL eosio_assert(((int_32)(*($5) - $4) > (int_32)[0]), [17932])     # .data 17932 -> ["write"]
	CALL memcpy(*($6), ($2 + [15]), [1])
	$4	 = (*($6) + [1])
	*($6) = $4
	if ( $8 ){ goto $label$1 }
	$7	 = *($1)
	$6	 = (*(($1 + [4])) - $7)
	CALL eosio_assert(((int_32)(*(($0 + [8])) - $4) >= (int_32)$6), [17932])     # .data 17932 -> ["write"]
	$4	 = ($0 + [4])
	CALL memcpy(*($4), $7, $6)
	*($4) = (*($4) + $6)
	$global$0 = ($2 + [16])
	return $0
}

.data 18431 -> ["read\00"]
.data 18408 -> ["error reading iterator\00"]
int_32 .FUNC $77 (int_32 $0, int_32 $1)
{
	int_32 $2
	int_32 $3
	int_32 $4
	int_32 $5
	int_64 $6
	int_32 $7
	int_32 $8
	$2	 = ($global$0 - [32])
	$3 = $2
	$global$0 = $2
	$5	 = *(($0 + [28]))
	$4	 = *($0 + [24])
	if ( ((int_32)$4 == (int_32)$5) ){ goto $label$1 }
	
.LOOP $label$3:
	if ( ((int_32)*(($5 + [-8])) == (int_32)$1) ){ goto $label$2 }
	$5	 = ($5 + [-24])
	if ( ((int_32)$4 != (int_32)$5) ){ goto $label$3 }
	goto $label$1 
	
.LABEL $label$2
	if ( ((int_32)$4 == (int_32)$5) ){ goto $label$1 }
	$5 = *(($5 + [-24]))
	$global$0 = ($3 + [32])
	return $5
	
.LABEL $label$1
	$4	 = CALL db_get_i64($1, [0], [0])
	CALL eosio_assert(((int_32)uint_32($4 >> [31]) ^ (int_32)[1]), [18408])     # .data 18408 -> ["error reading iterator"]
	if ( ($4 <= [513]) ){ goto $label$5 }
	$2 = CALL $114($4)
	goto $label$4 
	
.LABEL $label$5
	$2	 = ($2 - (($4 + [15]) & [-16]))
	$global$0 = $2
	
.LABEL $label$4
	CALL db_get_i64($1, $2, $4)
	*(($5 = CALL _Znwj([32])) + [16]) = $0
	*($5) = (int_64)0
	CALL eosio_assert(((uint_32)$4 > (uint_32)[7]), [18431])     # .data 18431 -> ["read"]
	CALL memcpy($5, $2, [8])
	CALL eosio_assert(((int_32)($4 & [-8]) != (int_32)[8]), [18431])     # .data 18431 -> ["read"]
	CALL memcpy(($5 + [8]), ($2 + [8]), [8])
	*($5 + [20]) = $1
	*($3 + [24]) = $5
	$6	 = *($5)
	*($3 + [16]) = $6
	*($3 + [12]) = $1
	$7	 = ($0 + [28])
	$8	 = *($7)
	if ( ((uint_32)$8 >= (uint_32)*(($0 + [32]))) ){ goto $label$8 }
	*($8 + [8]) = $6
	*($8 + [16]) = $1
	*($3 + [24]) = [0]
	*($8) = $5
	*($7) = ($8 + [24])
	if ( ((uint_32)$4 >= (uint_32)[513]) ){ goto $label$7 }
	goto $label$6 
	
.LABEL $label$8
	CALL $78(($0 + [24]), ($3 + [24]), ($3 + [16]), ($3 + [12]))
	if ( ($4 <= [513]) ){ goto $label$6 }
	
.LABEL $label$7
	CALL $118($2)
	
.LABEL $label$6
	$1 = *($3 + [24])
	*($3 + [24]) = [0]
	if ( ($1 == 0) ){ goto $label$9 }
	CALL _ZdlPv($1)
	
.LABEL $label$9
	$global$0 = ($3 + [32])
	return $5
}

.data 18431 -> ["read\00"]
void .FUNC $74 (int_32 $0, int_32 $1)
{
	int_32 $2
	int_32 $3
	int_32 $4
	$2	 = ($global$0 - [16])
	$global$0 = $2
	$3 = *($0)
	$4	 = *($1)
	CALL eosio_assert(((int_32)*($4 + [8]) != (int_32)*($4 + [4])), [18431])     # .data 18431 -> ["read"]
	CALL memcpy($3, *($4 + [4]), [1])
	*($4 + [4]) = (*($4 + [4]) + [1])
	$0 = *($0)
	$4	 = *($1)
	CALL eosio_assert(((uint_32)(*($4 + [8]) - *($4 + [4])) > (uint_32)[7]), [18431])     # .data 18431 -> ["read"]
	CALL memcpy(($0 + [8]), *($4 + [4]), [8])
	$3	 = (*($4 + [4]) + [8])
	*($4 + [4]) = $3
	*($2 + [8]) = (int_64)0
	CALL eosio_assert(((uint_32)(*($4 + [8]) - $3) > (uint_32)[7]), [18431])     # .data 18431 -> ["read"]
	CALL memcpy(($2 + [8]), *($4 + [4]), [8])
	*($0 + [16]) = *($2 + [8])
	*($4 + [4]) = (*($4 + [4]) + [8])
	$4	 = *($1)
	CALL eosio_assert(((uint_32)(*($4 + [8]) - *($4 + [4])) > (uint_32)[7]), [18431])     # .data 18431 -> ["read"]
	CALL memcpy(($0 + [24]), *($4 + [4]), [8])
	$1	 = (*($4 + [4]) + [8])
	*($4 + [4]) = $1
	*($2 + [8]) = (int_64)0
	CALL eosio_assert(((uint_32)(*($4 + [8]) - $1) > (uint_32)[7]), [18431])     # .data 18431 -> ["read"]
	CALL memcpy(($2 + [8]), *($4 + [4]), [8])
	*($0 + [32]) = *($2 + [8])
	*($4 + [4]) = (*($4 + [4]) + [8])
	$global$0 = ($2 + [16])
}

.data 18489 -> ["\00"]
.data 18487 -> [".\00"]
void .FUNC $39 (int_32 $0)
{
	int_32 $1
	int_32 $2
	int_64 $3
	int_32 $4
	int_64 $5
	int_32 $6
	int_64 $7
	int_32 $8
	int_64 $9
	int_64 $10
	$1	 = ($global$0 - [16])
	$2 = $1
	$global$0 = $1
	$3	 = *($0 + [8])
	$4 = (CASTING uint_32)(uint_64 $3)
	$5	 = ((int_64)$3 & (int_64)255)
	$6	 = (int_64)($5 == 0)
	if ( $6 ){ goto $label$2 }
	$3 = ((int_64)$5 + (int_64)1)
	$7 = (int_64)1
	
.LOOP $label$3:
	$7 = ((int_64)$7 * (int_64)10)
	$3	 = ((int_64)$3 + (int_64)-1)
	if ( ((int_64)$3 > (int_64)1) ){ goto $label$3 }
	goto $label$1 
	
.LABEL $label$2
	$7 = (int_64)1
	
.LABEL $label$1
	$4	 = ($4 & [255])
	$8	 = ($1 - (($4 + [16]) & [496]))
	$global$0 = $8
	*(($1 = ($8 + $4))) = [0]
	$9 = *($0)
	if ( $6 ){ goto $label$4 }
	$5 = ((int_64)$5 + (int_64)1)
	$3 = ((int_64)$9 % (int_64)$7)
	$1 = ($1 + [-1])
	
.LOOP $label$5:
	$10	 = ((int_64)$3 / (int_64)10)
	*($1) = ((CASTING uint_32)(uint_64 (int_64))($3 - ((int_64)$10 * (int_64)10))) + [48])
	$1 = ($1 + [-1])
	$3 = $10
	$5	 = ((int_64)$5 + (int_64)-1)
	if ( ((int_64)$5 > (int_64)1) ){ goto $label$5 }
	
.LABEL $label$4
	CALL printi(((int_64)$9 / (int_64)$7))
	CALL prints([18487])     # .data 18487 -> ["."]
	CALL prints_l($8, $4)
	CALL prints([18489])     # .data 18489 -> [""]
	$3	 = (uint_64)*(($0 + [8])) >> (uint_64)(int_64)8
	if ( (int_64)($3) == 0) ){ goto $label$6 }
	$1 = [0]
	
.LOOP $label$8:
	*((($2 + [9]) + $1)) = $3
	$0 = ($1 + [1])
	if ( ((uint_32)$1 > (uint_32)[5]) ){ goto $label$7 }
	$1 = $0
	$3	 = (uint_64)$3 >> (uint_64)(int_64)8
	if ( ((int_64)$3) != (int_64)0) ){ goto $label$8 }
	
.LABEL $label$7
	CALL prints_l(($2 + [9]), $0)
	
.LABEL $label$6
	$global$0 = ($2 + [16])
}

.data 17793 -> ["updater cannot change primary key when modifying an object\00"]
.data 17020 -> ["invalid symbol name\00"]
.data 17647 -> ["magnitude of asset amount must be less than 2^62\00"]
.data 18266 -> ["only uppercase letters allowed in symbol_code string\00"]
.data 18221 -> ["string is too long to be a valid symbol_code\00"]
.data 17532 -> ["BIT\00"]
.data 17742 -> ["cannot modify objects in table of another contract\00"]
.data 17696 -> ["object passed to modify is not in multi_index\00"]
void .FUNC $36 (int_32 $0, int_32 $1, int_64 $2)
{
	int_32 $3
	int_32 $4
	int_64 $5
	int_32 $6
	int_64 $7
	int_32 $8
	int_64 $9
	int_64 $10
	int_32 $11
	int_32 $12
	$3	 = ($global$0 - [48])
	$4 = $3
	$global$0 = $3
	CALL eosio_assert(((int_32)*($1 + [48]) == (int_32)$0), [17696])     # .data 17696 -> ["object passed to modify is not in multi_index"]
	CALL eosio_assert(((int_64)*($0) == (int_64)CALL $fimport$5()), [17742])     # .data 17742 -> ["cannot modify objects in table of another contract"]
	$5 = *($1)
	$6	 = CALL $109([17532])
	if ( ($6 <= [8]) ){ goto $label$4 }     # .data 17532 -> ["BIT"]
	CALL eosio_assert([0], [18221])     # .data 18221 -> ["string is too long to be a valid symbol_code"]
	goto $label$3 
	
.LABEL $label$4
	if ( ($6 == 0) ){ goto $label$2 }
	
.LABEL $label$3
	$7 = (int_64)0
	
.LOOP $label$5:
	$8	 = *(($6 + [17531]))
	if ( ((($8 + [-65]) & [255]) <= [26]) ){ goto $label$6 }
	CALL eosio_assert([0], [18266])     # .data 18266 -> ["only uppercase letters allowed in symbol_code string"]
	
.LABEL $label$6
	$7 = ((int_64)((int_64)$7 << (int_64)8) | (int_64)((int_64)(CASTING uint_64)(uint_32 $8) << (int_64)56) >> (int_64)56))
	$6	 = ($6 + [-1])
	if ( $6 ){ goto $label$5 }
	$9 = ((int_64)((int_64)$7 << (int_64)8) | (int_64)4)
	goto $label$1 
	
.LABEL $label$2
	$9 = (int_64)4
	
.LABEL $label$1
	CALL eosio_assert([1], [17647])     # .data 17647 -> ["magnitude of asset amount must be less than 2^62"]
	$7 = (uint_64)$9 >> (uint_64)(int_64)8)
	$6 = [0]
	
.LOOP $label$9:
	if ( ((uint_32)(((CASTING uint_32)(uint_64 $7) << [24]) + [-1073741825]) > (uint_32)[452984830]) ){ goto $label$8 }
	$10 = (uint_64)$7 >> (uint_64)(int_64)8)
	if ( ((int_64)((int_64)$7 & (int_64)65280) == (int_64)0) ){ goto $label$10 }
	$7 = $10
	$8 = [1]
	$11	 = $6
	$6 = ($11 + [1])
	if ( ((int_32)$11 < (int_32)[6]) ){ goto $label$9 }
	goto $label$7 
	
.LABEL $label$10
	$7 = $10
	
.LOOP $label$11:
	if ( ((int_64)((int_64)$7 & (int_64)65280) != (int_64)0) ){ goto $label$8 }
	$7 = (uint_64)$7 >> (uint_64)(int_64)8)
	$8 = ((int_32)$6 < (int_32)[6])
	$11	 = ($6 + [1])
	$6 = $11
	if ( $8 ){ goto $label$11 }
	$8 = [1]
	$6 = ($11 + [1])
	if ( ((int_32)$11 < (int_32)[6]) ){ goto $label$9 }
	goto $label$7 
	
.LABEL $label$8
	$8 = [0]
	
.LABEL $label$7
	CALL eosio_assert($8, [17020])     # .data 17020 -> ["invalid symbol name"]
	*(($1 + [24])) = $9
	*($1 + [16]) = (int_64)0
	*($1 + [8]) = [100]
	$6	 = CALL $109([17532])
	if ( ($6 <= [8]) ){ goto $label$15 }     # .data 17532 -> ["BIT"]
	CALL eosio_assert([0], [18221])     # .data 18221 -> ["string is too long to be a valid symbol_code"]
	goto $label$14 
	
.LABEL $label$15
	if ( ($6 == 0) ){ goto $label$13 }
	
.LABEL $label$14
	$7 = (int_64)0
	
.LOOP $label$16:
	$8	 = *(($6 + [17531]))
	if ( ((($8 + [-65]) & [255]) <= [26]) ){ goto $label$17 }
	CALL eosio_assert([0], [18266])     # .data 18266 -> ["only uppercase letters allowed in symbol_code string"]
	
.LABEL $label$17
	$7 = ((int_64)((int_64)$7 << (int_64)8) | (int_64)((int_64)(CASTING uint_64)(uint_32 $8) << (int_64)56) >> (int_64)56))
	$6	 = ($6 + [-1])
	if ( $6 ){ goto $label$16 }
	$9 = ((int_64)((int_64)$7 << (int_64)8) | (int_64)4)
	goto $label$12 
	
.LABEL $label$13
	$9 = (int_64)4
	
.LABEL $label$12
	$12 = ($1 + [8])
	CALL eosio_assert([1], [17647])     # .data 17647 -> ["magnitude of asset amount must be less than 2^62"]
	$7 = (uint_64)$9 >> (uint_64)(int_64)8)
	$6 = [0]
	
.LOOP $label$20:
	if ( ((uint_32)(((CASTING uint_32)(uint_64 $7) << [24]) + [-1073741825]) > (uint_32)[452984830]) ){ goto $label$19 }
	$10 = (uint_64)$7 >> (uint_64)(int_64)8)
	if ( ((int_64)((int_64)$7 & (int_64)65280) == (int_64)0) ){ goto $label$21 }
	$7 = $10
	$8 = [1]
	$11	 = $6
	$6 = ($11 + [1])
	if ( ((int_32)$11 < (int_32)[6]) ){ goto $label$20 }
	goto $label$18 
	
.LABEL $label$21
	$7 = $10
	
.LOOP $label$22:
	if ( ((int_64)((int_64)$7 & (int_64)65280) != (int_64)0) ){ goto $label$19 }
	$7 = (uint_64)$7 >> (uint_64)(int_64)8)
	$8 = ((int_32)$6 < (int_32)[6])
	$11	 = ($6 + [1])
	$6 = $11
	if ( $8 ){ goto $label$22 }
	$8 = [1]
	$6 = ($11 + [1])
	if ( ((int_32)$11 < (int_32)[6]) ){ goto $label$20 }
	goto $label$18 
	
.LABEL $label$19
	$8 = [0]
	
.LABEL $label$18
	CALL eosio_assert($8, [17020])     # .data 17020 -> ["invalid symbol name"]
	*(($1 + [40])) = $9
	*($1 + [32]) = (int_64)0
	CALL eosio_assert(((int_64)$5 == (int_64)*($1)), [17793])     # .data 17793 -> ["updater cannot change primary key when modifying an object"]
	$8	 = $3
	$6	 = ($8 + [-48])
	$global$0 = $6
	*($4 + [12]) = $6
	*($4 + [8]) = $6
	*($4 + [16]) = ($8 + [-7])
	*($4 + [24]) = ($4 + [8])
	*($4 + [36]) = $12
	*($4 + [32]) = $1
	*($4 + [40]) = ($1 + [16])
	*($4 + [44]) = ($1 + [32])
	CALL $38(($4 + [32]), ($4 + [24]))
	CALL db_update_i64(*($1 + [52]), $2, $6, [41])
	if ( (uint_64)($5 <= *($0 + [16])) ){ goto $label$23 }
	*(($0 + [16])) = ( (int_64)-2 ? ((int_64)$5 + (int_64)1) : ((uint_64)$5 > (uint_64)(int_64)-3) )
	
.LABEL $label$23
	$global$0 = ($4 + [48])
}

.data 18357 -> ["object passed to iterator_to is not in multi_index\00"]
int_32 .FUNC $37 (int_32 $0, int_64 $1, int_32 $2)
{
	int_32 $3
	int_32 $4
	int_32 $5
	int_32 $6
	$4	 = *(($0 + [28]))
	$3	 = *($0 + [24])
	if ( ((int_32)$3 == (int_32)$4) ){ goto $label$1 }
	
.LOOP $label$3:
	$5	 = ($4 + [-24])
	$6	 = *($5)
	if ( ((int_64)*($6) == (int_64)$1) ){ goto $label$2 }
	$4 = $5
	if ( ((int_32)$3 != (int_32)$5) ){ goto $label$3 }
	goto $label$1 
	
.LABEL $label$2
	if ( ((int_32)$3 == (int_32)$4) ){ goto $label$1 }
	CALL eosio_assert(((int_32)*($6 + [48]) == (int_32)$0), [18357])     # .data 18357 -> ["object passed to iterator_to is not in multi_index"]
	CALL eosio_assert(((int_32)$6 != (int_32)[0]), $2)
	return $6
	
.LABEL $label$1
	$5 = [0]
	$4	 = CALL db_find_i64(*($0), *($0 + [8]), (int_64)7235159544932859904, $1)
	if ( ((int_32)$4 < (int_32)[0]) ){ goto $label$4 }
	$5	 = CALL $24($0, $4)
	CALL eosio_assert(((int_32)*($5 + [48]) == (int_32)$0), [18357])     # .data 18357 -> ["object passed to iterator_to is not in multi_index"]
	
.LABEL $label$4
	CALL eosio_assert(((int_32)$5 != (int_32)[0]), $2)
	return $5
}

void .FUNC $78 (int_32 $0, int_32 $1, int_32 $2, int_32 $3)
{
	int_32 $4
	int_32 $5
	int_32 $6
	int_32 $7
	int_32 $8
	$4	 = *($0)
	$5	 = ((int_32)(*($0 + [4]) - $4) / (int_32)[24])
	$6	 = ($5 + [1])
	if ( ((uint_32)$6 >= (uint_32)[178956971]) ){ goto $label$2 }
	$7 = [178956970]
	$4	 = ((int_32)(*($0 + [8]) - $4) / (int_32)[24])
	if ( ((uint_32)$4 > (uint_32)[89478484]) ){ goto $label$4 }
	$7	 = ($4 << [1])
	$7	 = ( $6 ? $7 : ($7 <= $6) )
	if ( ($7 == 0) ){ goto $label$3 }
	
.LABEL $label$4
	$4 = CALL _Znwj(((int_32)$7 * (int_32)[24]))
	goto $label$1 
	
.LABEL $label$3
	$7 = [0]
	$4 = [0]
	goto $label$1 
	
.LABEL $label$2
	CALL $105($0)
	
.LABEL $label$1
	$6 = *($1)
	*($1) = [0]
	*(($1 = ($4 + ($8 = ((int_32)$5 * (int_32)[24]))))) = $6
	*($1 + [8]) = *($2)
	*($1 + [16]) = *($3)
	$5 = ($4 + ((int_32)$7 * (int_32)[24]))
	$6 = ($1 + [24])
	$7	 = *($0)
	$2	 = *(($0 + [4]))
	if ( ((int_32)$2 == (int_32)$7) ){ goto $label$6 }
	$1 = (($4 + $8) + [-24])
	
.LOOP $label$7:
	$4	 = ($2 + [-24])
	$3 = *($4)
	*($4) = [0]
	*($1) = $3
	*(($1 + [16])) = *(($2 + [-8]))
	*(($1 + [8])) = *(($2 + [-16]))
	$1 = ($1 + [-24])
	$2 = $4
	if ( ((int_32)$7 != (int_32)$4) ){ goto $label$7 }
	$1 = ($1 + [24])
	$7 = *(($0 + [4]))
	$2 = *($0)
	goto $label$5 
	
.LABEL $label$6
	$2 = $7
	
.LABEL $label$5
	*($0) = $1
	*(($0 + [4])) = $6
	*(($0 + [8])) = $5
	if ( ((int_32)$7 == (int_32)$2) ){ goto $label$8 }
	
.LOOP $label$9:
	$7	 = ($7 + [-24])
	$1 = *($7)
	*($7) = [0]
	if ( ($1 == 0) ){ goto $label$10 }
	CALL _ZdlPv($1)
	
.LABEL $label$10
	if ( ((int_32)$2 != (int_32)$7) ){ goto $label$9 }
	
.LABEL $label$8
	if ( ($2 == 0) ){ goto $label$11 }
	CALL _ZdlPv($2)
	
.LABEL $label$11
	(unreachable)
}

.data 18431 -> ["read\00"]
void .FUNC $79 (int_32 $0, int_32 $1)
{
	int_32 $2
	int_32 $3
	int_32 $4
	int_32 $5
	$2	 = ($global$0 - [16])
	$global$0 = $2
	$3 = *($0)
	$4	 = *($1)
	CALL eosio_assert(((uint_32)(*($4 + [8]) - *($4 + [4])) > (uint_32)[7]), [18431])     # .data 18431 -> ["read"]
	CALL memcpy($3, *($4 + [4]), [8])
	*($4 + [4]) = (*($4 + [4]) + [8])
	$3 = *($0 + [4])
	$4	 = *($1)
	CALL eosio_assert(((int_32)*($4 + [8]) != (int_32)*($4 + [4])), [18431])     # .data 18431 -> ["read"]
	CALL memcpy($3, *($4 + [4]), [1])
	*($4 + [4]) = (*($4 + [4]) + [1])
	$3 = *($0 + [8])
	$4	 = *($1)
	CALL eosio_assert(((uint_32)(*($4 + [8]) - *($4 + [4])) > (uint_32)[7]), [18431])     # .data 18431 -> ["read"]
	CALL memcpy($3, *($4 + [4]), [8])
	$5	 = (*($4 + [4]) + [8])
	*($4 + [4]) = $5
	*($2 + [8]) = (int_64)0
	CALL eosio_assert(((uint_32)(*($4 + [8]) - $5) > (uint_32)[7]), [18431])     # .data 18431 -> ["read"]
	CALL memcpy(($2 + [8]), *($4 + [4]), [8])
	*($3 + [8]) = *($2 + [8])
	*($4 + [4]) = (*($4 + [4]) + [8])
	$0 = *($0 + [12])
	$4	 = *($1)
	CALL eosio_assert(((uint_32)(*($4 + [8]) - *($4 + [4])) > (uint_32)[7]), [18431])     # .data 18431 -> ["read"]
	CALL memcpy($0, *($4 + [4]), [8])
	$1	 = (*($4 + [4]) + [8])
	*($4 + [4]) = $1
	*($2 + [8]) = (int_64)0
	CALL eosio_assert(((uint_32)(*($4 + [8]) - $1) > (uint_32)[7]), [18431])     # .data 18431 -> ["read"]
	CALL memcpy(($2 + [8]), *($4 + [4]), [8])
	*($0 + [8]) = *($2 + [8])
	*($4 + [4]) = (*($4 + [4]) + [8])
	$global$0 = ($2 + [16])
}

.data 18357 -> ["object passed to iterator_to is not in multi_index\00"]
int_32 .FUNC $32 (int_32 $0, int_64 $1, int_32 $2)
{
	int_32 $3
	int_32 $4
	int_32 $5
	int_32 $6
	$4	 = *(($0 + [28]))
	$3	 = *($0 + [24])
	if ( ((int_32)$3 == (int_32)$4) ){ goto $label$1 }
	
.LOOP $label$3:
	$5	 = ($4 + [-24])
	$6	 = *($5)
	if ( ((int_64)*($6 + [8]) == (int_64)$1) ){ goto $label$2 }
	$4 = $5
	if ( ((int_32)$3 != (int_32)$5) ){ goto $label$3 }
	goto $label$1 
	
.LABEL $label$2
	if ( ((int_32)$3 == (int_32)$4) ){ goto $label$1 }
	CALL eosio_assert(((int_32)*($6 + [40]) == (int_32)$0), [18357])     # .data 18357 -> ["object passed to iterator_to is not in multi_index"]
	CALL eosio_assert(((int_32)$6 != (int_32)[0]), $2)
	return $6
	
.LABEL $label$1
	$5 = [0]
	$4	 = CALL db_find_i64(*($0), *($0 + [8]), (int_64)-4157508551318700032, $1)
	if ( ((int_32)$4 < (int_32)[0]) ){ goto $label$4 }
	$5	 = CALL $4($0, $4)
	CALL eosio_assert(((int_32)*($5 + [40]) == (int_32)$0), [18357])     # .data 18357 -> ["object passed to iterator_to is not in multi_index"]
	
.LABEL $label$4
	CALL eosio_assert(((int_32)$5 != (int_32)[0]), $2)
	return $5
}

.data 17291 -> ["active\00"]
.data 18320 -> ["\94G\00\00"]
.data 17125 -> ["token with symbol does not exist, create token before issue\00"]
.data 17546 -> ["asset\00"]
.data 17536 -> ["sym_name:\00"]
.data 17793 -> ["updater cannot change primary key when modifying an object\00"]
.data 17914 -> ["addition overflow\00"]
.data 17895 -> ["addition underflow\00"]
.data 17852 -> ["attempt to add asset with different symbol\00"]
.data 17742 -> ["cannot modify objects in table of another contract\00"]
.data 17696 -> ["object passed to modify is not in multi_index\00"]
.data 17020 -> ["invalid symbol name\00"]
.data 17647 -> ["magnitude of asset amount must be less than 2^62\00"]
.data 17477 -> ["unable to find key\00"]
.data 17938 -> ["cannot pass end iterator to modify\00"]
.data 18436 -> ["cannot create objects in table of another contract\00"]
.data 17532 -> ["BIT\00"]
.data 18357 -> ["object passed to iterator_to is not in multi_index\00"]
.data 17231 -> ["symbol precision mismatch\00"]
.data 18266 -> ["only uppercase letters allowed in symbol_code string\00"]
.data 18221 -> ["string is too long to be a valid symbol_code\00"]
.data 17528 -> ["EOS\00"]
void .FUNC $33 (int_32 $0, int_64 $1, int_32 $2, int_32 $3)
{
	int_32 $4
	int_32 $5
	int_32 $6
	int_64 $7
	int_32 $8
	int_32 $9
	int_32 $10
	int_64 $11
	int_64 $12
	$4	 = ($global$0 - [272])
	$global$0 = $4
	$5	 = *([0] + [8204])
	$6	 = ($5 & [1])
	*($4 + [192]) = ( *([0] + [8212]) ? [8205] : $6 )
	*($4 + [196]) = ( *([0] + [8208]) ? uint_32($5 >> [1]) : $6 )
	*($4 + [16]) = *($4 + [192])
	CALL require_auth(*(CALL $10(($4 + [200]), ($4 + [16]))))
	$5	 = CALL $109([17528])
	if ( ($5 <= [8]) ){ goto $label$4 }     # .data 17528 -> ["EOS"]
	CALL eosio_assert([0], [18221])     # .data 18221 -> ["string is too long to be a valid symbol_code"]
	goto $label$3 
	
.LABEL $label$4
	if ( ($5 == 0) ){ goto $label$2 }
	
.LABEL $label$3
	$7 = (int_64)0
	
.LOOP $label$5:
	$6	 = *(($5 + [17527]))
	if ( ((($6 + [-65]) & [255]) <= [26]) ){ goto $label$6 }
	CALL eosio_assert([0], [18266])     # .data 18266 -> ["only uppercase letters allowed in symbol_code string"]
	
.LABEL $label$6
	$7 = ((int_64)((int_64)$7 << (int_64)8) | (int_64)((int_64)(CASTING uint_64)(uint_32 $6) << (int_64)56) >> (int_64)56))
	$5	 = ($5 + [-1])
	if ( $5 ){ goto $label$5 }
	$7 = ((int_64)$7 << (int_64)8)
	goto $label$1 
	
.LABEL $label$2
	$7 = (int_64)0
	
.LABEL $label$1
	CALL eosio_assert(((int_64)*($2 + [8]) == (int_64)((int_64)$7 | (int_64)4)), [17231])     # .data 17231 -> ["symbol precision mismatch"]
	*(($6 = ($4 + [184]))) = [0]
	*($4 + [168]) = (int_64)-1
	$7	 = *($0)
	*($4 + [152]) = $7
	*($4 + [160]) = $7
	*($4 + [176]) = (int_64)0
	$5	 = CALL db_find_i64($7, $7, (int_64)7235159544932859904, (int_64)0)
	if ( ((int_32)$5 < (int_32)[0]) ){ goto $label$14 }
	$8	 = CALL $24(($4 + [152]), $5)
	CALL eosio_assert(((int_32)*($8 + [48]) == (int_32)($4 + [152])), [18357])     # .data 18357 -> ["object passed to iterator_to is not in multi_index"]
	$5	 = CALL $109([17532])
	if ( ((uint_32)$5 <= (uint_32)[7]) ){ goto $label$13 }     # .data 17532 -> ["BIT"]
	CALL eosio_assert([0], [18221])     # .data 18221 -> ["string is too long to be a valid symbol_code"]
	goto $label$12 
	
.LABEL $label$14
	*($4 + [96]) = *($0)
	CALL eosio_assert(((int_64)*($4 + [152]) == (int_64)CALL $fimport$5()), [18436])     # .data 18436 -> ["cannot create objects in table of another contract"]
	*($4 + [212]) = ($4 + [80])
	*($4 + [208]) = ($4 + [152])
	*($4 + [216]) = ($4 + [96])
	*(($5 = CALL _Znwj([64])) + [16]) = (int_64)0
	*($5) = (int_64)0
	*($5 + [24]) = (int_64)0
	*($5 + [32]) = (int_64)0
	*($5 + [40]) = (int_64)0
	*($5 + [48]) = ($4 + [152])
	CALL $34(($4 + [208]), $5)
	*($4 + [136]) = $5
	$7	 = *($5)
	*($4 + [208]) = $7
	$9	 = *($5 + [52])
	*($4 + [256]) = $9
	$10	 = ($4 + [180])
	$8	 = *($10)
	if ( ((uint_32)$8 >= (uint_32)*($6)) ){ goto $label$11 }
	*($8 + [8]) = $7
	*($8 + [16]) = $9
	*($4 + [136]) = [0]
	*($8) = $5
	*($10) = ($8 + [24])
	$5 = *($4 + [136])
	*($4 + [136]) = [0]
	if ( $5 ){ goto $label$10 }
	goto $label$7 
	
.LABEL $label$13
	if ( ($5 == 0) ){ goto $label$9 }
	
.LABEL $label$12
	$7 = (int_64)0
	
.LOOP $label$15:
	$6	 = *(($5 + [17531]))
	if ( ((($6 + [-65]) & [255]) <= [26]) ){ goto $label$16 }
	CALL eosio_assert([0], [18266])     # .data 18266 -> ["only uppercase letters allowed in symbol_code string"]
	
.LABEL $label$16
	$7 = ((int_64)((int_64)$7 << (int_64)8) | (int_64)((int_64)(CASTING uint_64)(uint_32 $6) << (int_64)56) >> (int_64)56))
	$5	 = ($5 + [-1])
	if ( $5 ){ goto $label$15 }
	$7 = ((int_64)$7 << (int_64)8)
	goto $label$8 
	
.LABEL $label$11
	CALL $35(($4 + [176]), ($4 + [136]), ($4 + [208]), ($4 + [256]))
	$5 = *($4 + [136])
	*($4 + [136]) = [0]
	if ( ($5 == 0) ){ goto $label$7 }
	
.LABEL $label$10
	CALL _ZdlPv($5)
	goto $label$7 
	
.LABEL $label$9
	$7 = (int_64)0
	
.LABEL $label$8
	if ( ((int_64)*(($8 + [24])) == (int_64)((int_64)$7 | (int_64)4)) ){ goto $label$7 }
	$7 = *($0)
	CALL eosio_assert([1], [17938])     # .data 17938 -> ["cannot pass end iterator to modify"]
	CALL $36(($4 + [152]), $8, $7)
	
.LABEL $label$7
	$7 = (int_64)0
	$8 = CALL $37(($4 + [152]), (int_64)0, [17477])     # .data 17477 -> ["unable to find key"]
	$9	 = *($8 + [8])
	$11	 = ((int_64)*($2) * (int_64)((int_64)(CASTING uint_64)(uint_32 $9) & (int_64)255))
	$11 = ((int_64)((int_64)$11 / (int_64)10) + (int_64)$11)
	$12 = *($8 + [16])
	$5	 = CALL $109([17532])
	if ( ($5 <= [8]) ){ goto $label$19 }     # .data 17532 -> ["BIT"]
	CALL eosio_assert([0], [18221])     # .data 18221 -> ["string is too long to be a valid symbol_code"]
	goto $label$18 
	
.LABEL $label$19
	if ( ($5 == 0) ){ goto $label$17 }
	
.LABEL $label$18
	$7 = (int_64)0
	
.LOOP $label$20:
	$6	 = *(($5 + [17531]))
	if ( ((($6 + [-65]) & [255]) <= [26]) ){ goto $label$21 }
	CALL eosio_assert([0], [18266])     # .data 18266 -> ["only uppercase letters allowed in symbol_code string"]
	
.LABEL $label$21
	$7 = ((int_64)((int_64)$7 << (int_64)8) | (int_64)((int_64)(CASTING uint_64)(uint_32 $6) << (int_64)56) >> (int_64)56))
	$5	 = ($5 + [-1])
	if ( $5 ){ goto $label$20 }
	$7 = ((int_64)$7 << (int_64)8)
	
.LABEL $label$17
	$12 = ((int_64)$11 + (int_64)$12)
	$10 = ($8 + [8])
	*($4 + [144]) = ((int_64)$7 | (int_64)4)
	*($4 + [136]) = $11
	CALL eosio_assert((uint_64)(((int_64)$11 + (int_64)4611686018427387903) <= (int_64)9223372036854775807), [17647])     # .data 17647 -> ["magnitude of asset amount must be less than 2^62"]
	$7 = (uint_64)*($4 + [144]) >> (uint_64)(int_64)8)
	$5 = [0]
	
.LOOP $label$24:
	if ( ((uint_32)(((CASTING uint_32)(uint_64 $7) << [24]) + [-1073741825]) > (uint_32)[452984830]) ){ goto $label$23 }
	$11 = (uint_64)$7 >> (uint_64)(int_64)8)
	if ( ((int_64)((int_64)$7 & (int_64)65280) == (int_64)0) ){ goto $label$25 }
	$7 = $11
	$6 = [1]
	$2	 = $5
	$5 = ($2 + [1])
	if ( ((int_32)$2 < (int_32)[6]) ){ goto $label$24 }
	goto $label$22 
	
.LABEL $label$25
	$7 = $11
	
.LOOP $label$26:
	if ( ((int_64)((int_64)$7 & (int_64)65280) != (int_64)0) ){ goto $label$23 }
	$7 = (uint_64)$7 >> (uint_64)(int_64)8)
	$6 = ((int_32)$5 < (int_32)[6])
	$2	 = ($5 + [1])
	$5 = $2
	if ( $6 ){ goto $label$26 }
	$6 = [1]
	$5 = ($2 + [1])
	if ( ((int_32)$2 < (int_32)[6]) ){ goto $label$24 }
	goto $label$22 
	
.LABEL $label$23
	$6 = [0]
	
.LABEL $label$22
	CALL eosio_assert($6, [17020])     # .data 17020 -> ["invalid symbol name"]
	$5	 = ($8 + [16])
	if ( ((uint_64)((uint_64)$12 / (uint_64)(int_64)1500000000000) <= (uint_64)((uint_64)*($5) / (uint_64)(int_64)1500000000000)) ){ goto $label$27 }
	$9 = ((uint_32)(($9 & [255]) << [2]) / (uint_32)[5])
	
.LABEL $label$27
	$11 = *($0)
	CALL eosio_assert(((int_32)*($8 + [48]) == (int_32)($4 + [152])), [17696])     # .data 17696 -> ["object passed to modify is not in multi_index"]
	CALL eosio_assert(((int_64)*($4 + [152]) == (int_64)CALL $fimport$5()), [17742])     # .data 17742 -> ["cannot modify objects in table of another contract"]
	$7 = *($8)
	$6	 = (($4 + [136]) + [8])
	CALL eosio_assert(((int_64)*($6) == (int_64)*(($8 + [24]))), [17852])     # .data 17852 -> ["attempt to add asset with different symbol"]
	$12	 = ((int_64)*($8 + [16]) + (int_64)*($4 + [136]))
	*($8 + [16]) = $12
	CALL eosio_assert(((int_64)$12 > (int_64)-4611686018427387904), [17895])     # .data 17895 -> ["addition underflow"]
	CALL eosio_assert(((int_64)*($8 + [16]) < (int_64)4611686018427387904), [17914])     # .data 17914 -> ["addition overflow"]
	*(($8 + [8])) = $9
	CALL eosio_assert(((int_64)$7 == (int_64)*($8)), [17793])     # .data 17793 -> ["updater cannot change primary key when modifying an object"]
	*($4 + [264]) = (($4 + [208]) + [41])
	*($4 + [260]) = ($4 + [208])
	*($4 + [256]) = ($4 + [208])
	*($4 + [80]) = ($4 + [256])
	*($4 + [100]) = $10
	*($4 + [96]) = $8
	*($4 + [104]) = $5
	*($4 + [108]) = ($8 + [32])
	CALL $38(($4 + [96]), ($4 + [80]))
	CALL db_update_i64(*($8 + [52]), $11, ($4 + [208]), [41])
	if ( (uint_64)($7 <= *((($4 + [152]) + [16]))) ){ goto $label$28 }
	*(($4 + [168])) = ( (int_64)-2 ? ((int_64)$7 + (int_64)1) : ((uint_64)$7 > (uint_64)(int_64)-3) )
	
.LABEL $label$28
	$7 = *($6)
	CALL prints([17536])     # .data 17536 -> ["sym_name:"]
	CALL printui($7)
	CALL prints([17546])     # .data 17546 -> ["asset"]
	CALL $39(($4 + [136]))
	*((($4 + [96]) + [32])) = [0]
	*($4 + [112]) = (int_64)-1
	*($4 + [120]) = (int_64)0
	$11	 = *($0)
	*($4 + [96]) = $11
	$12	 = (uint_64)$7 >> (uint_64)(int_64)8
	*($4 + [104]) = $12)
	$9 = [0]
	$5	 = CALL db_find_i64($11, $12, (int_64)-4157508551318700032, $7)
	if ( ((int_32)$5 < (int_32)[0]) ){ goto $label$29 }
	$9	 = CALL $4(($4 + [96]), $5)
	CALL eosio_assert(((int_32)*($9 + [40]) == (int_32)($4 + [96])), [18357])     # .data 18357 -> ["object passed to iterator_to is not in multi_index"]
	
.LABEL $label$29
	CALL eosio_assert(((int_32)$9 != (int_32)[0]), [17125])     # .data 17125 -> ["token with symbol does not exist, create token before issue"]
	if ( ((int_64)$1 == (int_64)0) ){ goto $label$33 }
	$6 = [0]
	$2 = *([0] + [18320])     # .data 18320 -> ["\94G"]
	
.LOOP $label$35:
	*((($4 + [208]) + ($5 = $6))) = *(($2 + (CASTING uint_32)(uint_64 (uint_64)((int_64)$1 & (int_64)-576460752303423488) >> (uint_64)( (int_64)60 ? (int_64)59 : ((int_32)$5 == (int_32)[12]) )))))
	$6 = ($5 + [1])
	if ( ((uint_32)$5 > (uint_32)[11]) ){ goto $label$34 }
	$1	 = ((int_64)$1 << (int_64)5)
	if ( ((int_64)$1 != (int_64)0) ){ goto $label$35 }
	
.LABEL $label$34
	*(($4 + [88])) = [0]
	*($4 + [80]) = (int_64)0
	if ( ((uint_32)$6 >= (uint_32)[11]) ){ goto $label$32 }
	*($4 + [80]) = ($6 << [1])
	$2 = (($4 + [80]) | [1])
	goto $label$31 
	
.LABEL $label$33
	*(($4 + [88])) = [0]
	*($4 + [80]) = (int_64)0
	*($4 + [80]) = [0]
	$5 = (($4 + [80]) | [1])
	goto $label$30 
	
.LABEL $label$32
	$8	 = (($6 + [16]) & [-16])
	$2 = CALL _Znwj($8)
	*($4 + [80]) = ($8 | [1])
	*($4 + [88]) = $2
	*($4 + [84]) = $6
	
.LABEL $label$31
	$8 = ($5 + [1])
	$5 = [0]
	
.LOOP $label$36:
	*(($2 + $5)) = *((($4 + [208]) + $5))
	$5	 = ($5 + [1])
	if ( ((int_32)$8 != (int_32)$5) ){ goto $label$36 }
	$5 = ($2 + $6)
	
.LABEL $label$30
	*($5) = [0]
	$7 = *($0)
	$1 = *($9 + [32])
	*($4 + [256]) = [17291]     # .data 17291 -> ["active"]
	*($4 + [260]) = CALL $109([17291])     # .data 17291 -> ["active"]
	*($4 + [8]) = *($4 + [256])
	$11 = *(CALL $10(($4 + [208]), ($4 + [8])))
	$5	 = *([0] + [8192])
	$6	 = ($5 & [1])
	*($4 + [24]) = ( *([0] + [8200]) ? [8193] : $6 )
	*($4 + [28]) = ( *([0] + [8196]) ? uint_32($5 >> [1]) : $6 )
	*($4) = *($4 + [24])
	$5 = CALL $10(($4 + [32]), $4)
	*(($6 = (($4 + [40]) + [16]))) = *(($4 + [144]))
	*($4 + [40]) = *($5)
	*($4 + [48]) = *($4 + [136])
	CALL $103(($4 + [64]), ($4 + [80]))
	*(($5 = CALL _Znwj([16]))) = $1
	*($5 + [8]) = $11
	*((($4 + [208]) + [16])) = *($6)
	$6	 = (($4 + [40]) + [32])
	*(($2 = (($4 + [208]) + [32]))) = *($6)
	*($6) = [0]
	*($4 + [256]) = $5
	$5	 = ($5 + [16])
	*($4 + [264]) = $5
	*($4 + [260]) = $5
	*($4 + [208]) = *($4 + [40])
	*($4 + [216]) = *($4 + [48])
	*($4 + [232]) = *($4 + [64])
	*($4 + [64]) = (int_64)0
	CALL $40($7, (int_64)8516769789752901632, ($4 + [256]), ($4 + [208]))
	if ( ((*($4 + [232]) & [1]) == 0) ){ goto $label$37 }
	CALL _ZdlPv(*($2))
	
.LABEL $label$37
	$5	 = *($4 + [256])
	if ( ($5 == 0) ){ goto $label$38 }
	*($4 + [260]) = $5
	CALL _ZdlPv($5)
	
.LABEL $label$38
	if ( (*(($4 + [64])) & [1]) ){ goto $label$46 }
	if ( (*($4 + [80]) & [1]) ){ goto $label$45 }
	goto $label$44 
	
.LABEL $label$46
	CALL _ZdlPv(*(($4 + [72])))
	if ( ((*($4 + [80]) & [1]) == 0) ){ goto $label$44 }
	
.LABEL $label$45
	CALL _ZdlPv(*($4 + [88]))
	$2	 = *($4 + [120])
	if ( $2 ){ goto $label$43 }
	goto $label$42 
	
.LABEL $label$44
	$2	 = *($4 + [120])
	if ( ($2 == 0) ){ goto $label$42 }
	
.LABEL $label$43
	$8	 = ($4 + [124])
	$5	 = *($8)
	if ( ((int_32)$5 == (int_32)$2) ){ goto $label$41 }
	
.LOOP $label$47:
	$5	 = ($5 + [-24])
	$6 = *($5)
	*($5) = [0]
	if ( ($6 == 0) ){ goto $label$48 }
	CALL _ZdlPv($6)
	
.LABEL $label$48
	if ( ((int_32)$2 != (int_32)$5) ){ goto $label$47 }
	$5 = *(($4 + [120]))
	*($8) = $2
	CALL _ZdlPv($5)
	$2	 = *($4 + [176])
	if ( $2 ){ goto $label$40 }
	goto $label$39 
	
.LABEL $label$42
	$2	 = *($4 + [176])
	if ( ($2 == 0) ){ goto $label$39 }
	goto $label$40 
	
.LABEL $label$41
	*($8) = $2
	CALL _ZdlPv($2)
	$2	 = *($4 + [176])
	if ( ($2 == 0) ){ goto $label$39 }
	
.LABEL $label$40
	$8	 = ($4 + [180])
	$5	 = *($8)
	if ( ((int_32)$5 == (int_32)$2) ){ goto $label$50 }
	
.LOOP $label$51:
	$5	 = ($5 + [-24])
	$6 = *($5)
	*($5) = [0]
	if ( ($6 == 0) ){ goto $label$52 }
	CALL _ZdlPv($6)
	
.LABEL $label$52
	if ( ((int_32)$2 != (int_32)$5) ){ goto $label$51 }
	$5 = *(($4 + [176]))
	goto $label$49 
	
.LABEL $label$50
	$5 = $2
	
.LABEL $label$49
	*($8) = $2
	CALL _ZdlPv($5)
	$global$0 = ($4 + [272])
	return 
	
.LABEL $label$39
	$global$0 = ($4 + [272])
}

.data 17793 -> ["updater cannot change primary key when modifying an object\00"]
.data 18043 -> ["subtraction overflow\00"]
.data 18021 -> ["subtraction underflow\00"]
.data 17973 -> ["attempt to subtract asset with different symbol\00"]
.data 17742 -> ["cannot modify objects in table of another contract\00"]
.data 17696 -> ["object passed to modify is not in multi_index\00"]
void .FUNC $30 (int_32 $0, int_32 $1, int_64 $2, int_32 $3)
{
	int_32 $4
	int_64 $5
	int_64 $6
	$4	 = ($global$0 - [96])
	$global$0 = $4
	CALL eosio_assert(((int_32)*($1 + [48]) == (int_32)$0), [17696])     # .data 17696 -> ["object passed to modify is not in multi_index"]
	CALL eosio_assert(((int_64)*($0) == (int_64)CALL $fimport$5()), [17742])     # .data 17742 -> ["cannot modify objects in table of another contract"]
	$5 = *($1)
	$3	 = *($3)
	CALL eosio_assert(((int_64)*($3 + [8]) == (int_64)*(($1 + [40]))), [17973])     # .data 17973 -> ["attempt to subtract asset with different symbol"]
	$6	 = (int_64)
	*($1 + [32]) = $6(*($1 + [32]) - *($3)))
	CALL eosio_assert(((int_64)$6 > (int_64)-4611686018427387904), [18021])     # .data 18021 -> ["subtraction underflow"]
	CALL eosio_assert(((int_64)*($1 + [32]) < (int_64)4611686018427387904), [18043])     # .data 18043 -> ["subtraction overflow"]
	CALL eosio_assert(((int_64)$5 == (int_64)*($1)), [17793])     # .data 17793 -> ["updater cannot change primary key when modifying an object"]
	*($4 + [64]) = ($4 + [41])
	*($4 + [60]) = $4
	*($4 + [56]) = $4
	*($4 + [72]) = ($4 + [56])
	*($4 + [84]) = ($1 + [8])
	*($4 + [80]) = $1
	*($4 + [88]) = ($1 + [16])
	*($4 + [92]) = ($1 + [32])
	CALL $38(($4 + [80]), ($4 + [72]))
	CALL db_update_i64(*($1 + [52]), $2, $4, [41])
	if ( (uint_64)($5 <= *($0 + [16])) ){ goto $label$1 }
	*(($0 + [16])) = ( (int_64)-2 ? ((int_64)$5 + (int_64)1) : ((uint_64)$5 > (uint_64)(int_64)-3) )
	
.LABEL $label$1
	$global$0 = ($4 + [96])
}

.data 17096 -> ["memo has more than 256 bytes\00"]
.data 17231 -> ["symbol precision mismatch\00"]
.data 17496 -> ["must transfer positive quantity\00"]
.data 17185 -> ["invalid quantity\00"]
.data 17477 -> ["unable to find key\00"]
.data 17451 -> ["to account does not exist\00"]
.data 17427 -> ["cannot transfer to self\00"]
void .FUNC $31 (int_32 $0, int_64 $1, int_64 $2, int_32 $3, int_32 $4)
{
	int_32 $5
	int_64 $6
	int_32 $7
	int_64 $8
	int_32 $9
	int_64 $10
	int_32 $11
	int_64 $12
	int_32 $13
	$5	 = ($global$0 - [112])
	$global$0 = $5
	CALL eosio_assert(((int_64)$1 != (int_64)$2), [17427])     # .data 17427 -> ["cannot transfer to self"]
	CALL require_auth($1)
	CALL eosio_assert(CALL $fimport$9($2), [17451])     # .data 17451 -> ["to account does not exist"]
	$6 = *($3 + [8])
	$7 = [0]
	*(($5 + [104])) = [0]
	$8	 = (uint_64)$6 >> (uint_64)(int_64)8
	*($5 + [80]) = $8)
	*($5 + [88]) = (int_64)-1
	*($5 + [96]) = (int_64)0
	*($5 + [72]) = *($0)
	$9 = CALL $32(($5 + [72]), $6, [17477])     # .data 17477 -> ["unable to find key"]
	CALL require_recipient($1)
	CALL require_recipient($2)
	$10	 = *($3)
	if ( ((uint_64)((int_64)$10 + (int_64)4611686018427387903) > (uint_64)(int_64)9223372036854775806) ){ goto $label$1 }
	$11 = [0]
	
.LOOP $label$3:
	if ( ((uint_32)(((CASTING uint_32)(uint_64 $8) << [24]) + [-1073741825]) > (uint_32)[452984830]) ){ goto $label$2 }
	$12 = (uint_64)$8 >> (uint_64)(int_64)8)
	if ( ((int_64)((int_64)$8 & (int_64)65280) == (int_64)0) ){ goto $label$4 }
	$8 = $12
	$7 = [1]
	$13	 = $11
	$11 = ($13 + [1])
	if ( ((int_32)$13 < (int_32)[6]) ){ goto $label$3 }
	goto $label$1 
	
.LABEL $label$4
	$8 = $12
	
.LOOP $label$5:
	if ( ((int_64)((int_64)$8 & (int_64)65280) != (int_64)0) ){ goto $label$2 }
	$8 = (uint_64)$8 >> (uint_64)(int_64)8)
	$7 = ((int_32)$11 < (int_32)[6])
	$13	 = ($11 + [1])
	$11 = $13
	if ( $7 ){ goto $label$5 }
	$7 = [1]
	$11 = ($13 + [1])
	if ( ((int_32)$13 < (int_32)[6]) ){ goto $label$3 }
	goto $label$1 
	
.LABEL $label$2
	$7 = [0]
	
.LABEL $label$1
	CALL eosio_assert($7, [17185])     # .data 17185 -> ["invalid quantity"]
	CALL eosio_assert(((int_64)$10 > (int_64)0), [17496])     # .data 17496 -> ["must transfer positive quantity"]
	CALL eosio_assert(((int_64)$6 == (int_64)*($9 + [8])), [17231])     # .data 17231 -> ["symbol precision mismatch"]
	$11	 = *($4)
	if ( ($11 & [1]) ){ goto $label$7 }
	$11 = uint_32($11 >> [1])
	goto $label$6 
	
.LABEL $label$7
	$11 = *($4 + [4])
	
.LABEL $label$6
	CALL eosio_assert(($11 <= [257]), [17096])     # .data 17096 -> ["memo has more than 256 bytes"]
	$11	 = ($3 + [8])
	$6	 = *($11)
	*((($5 + [56]) + [8])) = $6
	$8 = *($3)
	*((($5 + [24]) + [8])) = $6
	*($5 + [24]) = $8
	*($5 + [56]) = $8
	CALL $17($0, $1, ($5 + [24]))
	$6	 = *($11)
	*((($5 + [40]) + [8])) = $6
	$8 = *($3)
	*((($5 + [8]) + [8])) = $6
	*($5 + [8]) = $8
	*($5 + [40]) = $8
	CALL $9($0, $2, ($5 + [8]), $1)
	$13	 = *($5 + [96])
	if ( ($13 == 0) ){ goto $label$8 }
	$3	 = ($5 + [100])
	$11	 = *($3)
	if ( ((int_32)$11 == (int_32)$13) ){ goto $label$10 }
	
.LOOP $label$11:
	$11	 = ($11 + [-24])
	$7 = *($11)
	*($11) = [0]
	if ( ($7 == 0) ){ goto $label$12 }
	CALL _ZdlPv($7)
	
.LABEL $label$12
	if ( ((int_32)$13 != (int_32)$11) ){ goto $label$11 }
	$11 = *(($5 + [96]))
	goto $label$9 
	
.LABEL $label$10
	$11 = $13
	
.LABEL $label$9
	*($3) = $13
	CALL _ZdlPv($11)
	
.LABEL $label$8
	$global$0 = ($5 + [112])
}
